"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/calls/page",{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPCAPolicy: function() { return /* binding */ createPCAPolicy; },\n/* harmony export */   diagnosePCAAccess: function() { return /* binding */ diagnosePCAAccess; },\n/* harmony export */   getAllPCA: function() { return /* binding */ getAllPCA; },\n/* harmony export */   getCallCountByPhone: function() { return /* binding */ getCallCountByPhone; },\n/* harmony export */   getCallDetailsWithPCA: function() { return /* binding */ getCallDetailsWithPCA; },\n/* harmony export */   getCallHistoryByPhone: function() { return /* binding */ getCallHistoryByPhone; },\n/* harmony export */   getCallbacksByCallId: function() { return /* binding */ getCallbacksByCallId; },\n/* harmony export */   getCalls: function() { return /* binding */ getCalls; },\n/* harmony export */   getCallsWithPCAInfo: function() { return /* binding */ getCallsWithPCAInfo; },\n/* harmony export */   getCallsWithPagination: function() { return /* binding */ getCallsWithPagination; },\n/* harmony export */   getLeads: function() { return /* binding */ getLeads; },\n/* harmony export */   getPCAByCallId: function() { return /* binding */ getPCAByCallId; },\n/* harmony export */   hasCallHistory: function() { return /* binding */ hasCallHistory; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   testAllTablesAccess: function() { return /* binding */ testAllTablesAccess; },\n/* harmony export */   testPCAAccess: function() { return /* binding */ testPCAAccess; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://rchgtacvdpavqkrceybo.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJjaGd0YWN2ZHBhdnFrcmNleWJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2OTUyODksImV4cCI6MjA3NjI3MTI4OX0.KZHdrA5sOrrDOUkMkG7H5b6Eb-yxPmrZQVXVBCuKVgg\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Función para obtener todas las llamadas\nasync function getCalls() {\n    const { data, error } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n        ascending: false\n    });\n    if (error) {\n        throw error;\n    }\n    return data;\n}\n// Función para obtener llamadas con información de si tienen PCA\nasync function getCallsWithPCAInfo() {\n    try {\n        // Primero obtenemos todas las llamadas\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"Error fetching calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls) return [];\n        // Luego obtenemos todos los call_ids que tienen PCA\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id\");\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        // No lanzamos error aquí, solo logueamos y continuamos sin PCA info\n        }\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        // Combinamos la información\n        return calls.map((call)=>({\n                ...call,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: false // Ya no usamos callbacks como concepto\n            }));\n    } catch (error) {\n        console.error(\"Error in getCallsWithPCAInfo:\", error);\n        throw error;\n    }\n}\n// Función NUEVA: Obtener llamadas con paginación en servidor (ESCALABLE)\nasync function getCallsWithPagination(params) {\n    try {\n        var _params_filters, _params_filters1;\n        console.log(\"\\uD83D\\uDD0D Obteniendo llamadas paginadas:\", params);\n        let query = supabase.from(\"calls\").select(\"*\", {\n            count: \"exact\"\n        });\n        // Aplicar filtros de búsqueda\n        if (params.search) {\n            query = query.or(\"business_name.ilike.%\".concat(params.search, \"%,owner_name.ilike.%\").concat(params.search, \"%,owner_phone.ilike.%\").concat(params.search, \"%\"));\n        }\n        // Aplicar filtros adicionales\n        if ((_params_filters = params.filters) === null || _params_filters === void 0 ? void 0 : _params_filters.disposition) {\n            query = query.eq(\"disposition\", params.filters.disposition);\n        }\n        // Aplicar ordenamiento\n        const sortBy = params.sortBy || \"call_id\";\n        const sortOrder = params.sortOrder === \"asc\" ? {\n            ascending: true\n        } : {\n            ascending: false\n        };\n        query = query.order(sortBy, sortOrder);\n        // Aplicar paginación\n        const offset = (params.page - 1) * params.limit;\n        query = query.range(offset, offset + params.limit - 1);\n        const { data: calls, count, error: callsError } = await query;\n        if (callsError) {\n            console.error(\"Error fetching paginated calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls || calls.length === 0) {\n            return {\n                data: [],\n                total: count || 0,\n                page: params.page,\n                limit: params.limit,\n                totalPages: Math.ceil((count || 0) / params.limit)\n            };\n        }\n        // Obtener información de PCA solo para las llamadas de esta página\n        const callIds = calls.map((call)=>call.call_id);\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        }\n        // Obtener callbacks asociados a estas calls\n        const { data: callbackData, error: callbackError } = await supabase.from(\"callbacks\").select(\"call_id, callback_owner_name, to_number\").in(\"call_id\", callIds);\n        if (callbackError) {\n            console.error(\"Error fetching callback data:\", callbackError);\n        }\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        const pcaDispositionMap = new Map((pcaData || []).map((pca)=>[\n                pca.call_id,\n                pca.disposition\n            ]));\n        // Crear mapas separados para nombre y teléfono\n        const callbackOwnerNameMap = new Map((callbackData || []).map((callback)=>[\n                callback.call_id,\n                callback.callback_owner_name\n            ]));\n        const callbackOwnerPhoneMap = new Map((callbackData || []).map((callback)=>[\n                callback.call_id,\n                callback.to_number\n            ]));\n        // Combinar información\n        const callsWithInfo = calls.map((call)=>{\n            const callbackOwnerName = callbackOwnerNameMap.get(call.call_id);\n            const callbackOwnerPhone = callbackOwnerPhoneMap.get(call.call_id);\n            const pcaDisposition = pcaDispositionMap.get(call.call_id);\n            return {\n                ...call,\n                // Si hay callback_owner_name, usarlo en lugar del owner_name original\n                owner_name: callbackOwnerName || call.owner_name,\n                // Si hay callback_owner_phone, usarlo en lugar del owner_phone original\n                owner_phone: callbackOwnerPhone || call.owner_phone,\n                // Si hay disposition del PCA, usarlo en lugar del disposition original\n                disposition: pcaDisposition || call.disposition,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: callbackOwnerNameMap.has(call.call_id)\n            };\n        });\n        // Aplicar filtros post-query si es necesario\n        let filteredCalls = callsWithInfo;\n        if (((_params_filters1 = params.filters) === null || _params_filters1 === void 0 ? void 0 : _params_filters1.hasPCA) !== undefined) {\n            filteredCalls = filteredCalls.filter((call)=>call.hasPCA === params.filters.hasPCA);\n        }\n        const totalPages = Math.ceil((count || 0) / params.limit);\n        console.log(\"✅ Devolviendo \".concat(filteredCalls.length, \" llamadas (p\\xe1gina \").concat(params.page, \"/\").concat(totalPages, \") de \").concat(count, \" total\"));\n        return {\n            data: filteredCalls,\n            total: count || 0,\n            page: params.page,\n            limit: params.limit,\n            totalPages\n        };\n    } catch (error) {\n        console.error(\"Error in getCallsWithPagination:\", error);\n        throw error;\n    }\n}\n// Función para obtener callbacks por call_id\nasync function getCallbacksByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).order(\"callback_date\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching callbacks:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getCallbacksByCallId:\", error);\n        throw error;\n    }\n}\n// Función para obtener análisis PCA por call_id\nasync function getPCAByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"*\").eq(\"call_id\", callId).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching PCA data:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getPCAByCallId:\", error);\n        throw error;\n    }\n}\n// Nueva función para obtener información completa del cliente y análisis (calls y callbacks)\nasync function getCallDetailsWithPCA(callId) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCallDetailsWithPCA - buscando callId:\", callId);\n        // Obtener la llamada (siempre existe)\n        const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"\\uD83D\\uDCDE Resultado b\\xfasqueda en calls:\", {\n            callData,\n            callError\n        });\n        if (callError || !callData) {\n            console.error(\"❌ No se encontr\\xf3 la call con ID:\", callId);\n            return {\n                call: null,\n                pca: [],\n                isCallback: false\n            };\n        }\n        // Verificar si esta call tiene un callback asociado\n        const { data: callbackData, error: callbackError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"� Verificando si tiene callback asociado:\", {\n            callbackData,\n            callbackError\n        });\n        // Obtener PCA\n        const pcaData = await getPCAByCallId(callId);\n        if (callbackData && !callbackError) {\n            // Es una call que TAMBIÉN es un callback\n            console.log(\"✅ Call con callback asociado encontrado\");\n            return {\n                call: callData,\n                pca: pcaData,\n                isCallback: true,\n                callback: callbackData\n            };\n        } else {\n            // Es una call normal (sin callback)\n            console.log(\"✅ Call normal (sin callback)\");\n            return {\n                call: callData,\n                pca: pcaData,\n                isCallback: false\n            };\n        }\n    } catch (error) {\n        console.error(\"❌ Error in getCallDetailsWithPCA:\", error);\n        throw error;\n    }\n}\n// Función de debug para ver todos los PCA disponibles\nasync function getAllPCA() {\n    console.log(\"Intentando obtener todos los PCA...\");\n    // Primero intentamos sin límites\n    const { data, error, status, statusText } = await supabase.from(\"pca\").select(\"id, call_id, agent_name, created_at\").order(\"created_at\", {\n        ascending: false\n    });\n    console.log(\"Respuesta PCA:\", {\n        data,\n        error,\n        status,\n        statusText,\n        dataLength: (data === null || data === void 0 ? void 0 : data.length) || 0\n    });\n    if (error) {\n        console.error(\"Error detallado al obtener PCA:\", {\n            message: error.message,\n            details: error.details,\n            hint: error.hint,\n            code: error.code\n        });\n        // Intentamos con un query más simple\n        console.log(\"Intentando query m\\xe1s simple...\");\n        const { data: simpleData, error: simpleError } = await supabase.from(\"pca\").select(\"*\").limit(1);\n        console.log(\"Query simple resultado:\", {\n            simpleData,\n            simpleError\n        });\n        throw error;\n    }\n    console.log(\"PCA obtenidos exitosamente:\", data);\n    return data;\n}\n// Función de debug simple para verificar acceso a PCA\nasync function testPCAAccess() {\n    console.log(\"Testeando acceso a tabla PCA...\");\n    const { data, error, count } = await supabase.from(\"pca\").select(\"*\", {\n        count: \"exact\",\n        head: true\n    });\n    console.log(\"Test PCA - Count:\", count, \"Error:\", error);\n    return {\n        count,\n        error\n    };\n}\n// Función para verificar todas las tablas disponibles\nasync function testAllTablesAccess() {\n    const tables = [\n        \"calls\",\n        \"pca\",\n        \"callbacks\"\n    ];\n    const results = {};\n    for (const table of tables){\n        try {\n            console.log(\"Testeando tabla: \".concat(table));\n            const { data, error, count } = await supabase.from(table).select(\"*\", {\n                count: \"exact\",\n                head: true\n            });\n            results[table] = {\n                count,\n                error: (error === null || error === void 0 ? void 0 : error.message) || null\n            };\n            console.log(\"\".concat(table, \": \").concat(count, \" registros, error:\"), error === null || error === void 0 ? void 0 : error.message);\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Error desconocido\";\n            results[table] = {\n                count: 0,\n                error: errorMessage\n            };\n            console.error(\"Error en tabla \".concat(table, \":\"), err);\n        }\n    }\n    return results;\n}\n// Función específica para diagnosticar el problema de PCA\nasync function diagnosePCAAccess() {\n    console.log(\"\\uD83D\\uDD0D Diagnosticando acceso a tabla PCA...\");\n    const tests = [];\n    // Test 1: Count básico\n    try {\n        const { count, error } = await supabase.from(\"pca\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: !error,\n            result: \"Count: \".concat(count),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 2: Select simple con límite\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id\").limit(1);\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 3: Select específico\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id, call_id\").limit(3);\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message,\n            sampleData: data\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 4: Verificar si RLS está causando el problema\n    try {\n        // Intentamos hacer un query con bypass de RLS si es posible\n        const { data, error } = await supabase.rpc(\"get_pca_count\") // Esta función no existe, pero el error nos dará información\n        ;\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: !error,\n            result: \"RPC call\",\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: false,\n            result: \"RPC no disponible\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    console.log(\"\\uD83D\\uDCCA Resultados del diagn\\xf3stico:\", tests);\n    return tests;\n}\n// Función para crear una política temporal de RLS\nasync function createPCAPolicy() {\n    console.log(\"\\uD83D\\uDD27 Intentando crear pol\\xedtica de acceso para PCA...\");\n    try {\n        // Intentamos ejecutar un comando SQL para crear una política\n        const { data, error } = await supabase.rpc(\"create_pca_policy\");\n        return {\n            success: !error,\n            error: error === null || error === void 0 ? void 0 : error.message\n        };\n    } catch (err) {\n        return {\n            success: false,\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        };\n    }\n}\n// Función para obtener todos los leads (números únicos con su información más reciente)\nasync function getLeads() {\n    console.log(\"\\uD83D\\uDCDE Obteniendo todos los leads...\");\n    // Primero obtenemos todas las calls\n    const { data: callsData, error: callsError } = await supabase.from(\"calls\").select(\"*\").not(\"to_number\", \"is\", null).order(\"call_id\", {\n        ascending: false\n    });\n    if (callsError) {\n        console.error(\"❌ Error obteniendo calls:\", callsError);\n        throw callsError;\n    }\n    if (!callsData) return [];\n    // Obtener todas las dispositions del PCA para los call_ids\n    const callIds = callsData.map((call)=>call.call_id);\n    const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n    // Crear un mapa para acceso rápido a las dispositions del PCA\n    const pcaMap = new Map();\n    if (pcaData) {\n        pcaData.forEach((pca)=>{\n            pcaMap.set(pca.call_id, pca.disposition);\n        });\n    }\n    const data = callsData;\n    // Agrupamos por to_number y tomamos la información más reciente\n    const leadsMap = new Map();\n    for (const call of data){\n        if (!call.to_number) continue;\n        const existingLead = leadsMap.get(call.to_number);\n        if (!existingLead) {\n            // Primera vez que vemos este número\n            leadsMap.set(call.to_number, {\n                phone_number: call.to_number,\n                business_name: call.business_name,\n                owner_name: call.owner_name,\n                owner_email: call.owner_email,\n                location_type: call.location_type,\n                address_street: call.address_street,\n                address_city: call.address_city,\n                address_state: call.address_state,\n                address_zip: call.address_zip,\n                total_calls: 1,\n                last_call_date: call.call_id,\n                last_disposition: pcaMap.get(call.call_id) || call.disposition,\n                agreed_amount: call.agreed_amount\n            });\n        } else {\n            // Actualizamos el conteo\n            existingLead.total_calls++;\n            // Si esta llamada es más reciente (call_id mayor), actualizamos la info\n            if (call.call_id > existingLead.last_call_date) {\n                existingLead.business_name = call.business_name || existingLead.business_name;\n                existingLead.owner_name = call.owner_name || existingLead.owner_name;\n                existingLead.owner_email = call.owner_email || existingLead.owner_email;\n                existingLead.location_type = call.location_type || existingLead.location_type;\n                existingLead.address_street = call.address_street || existingLead.address_street;\n                existingLead.address_city = call.address_city || existingLead.address_city;\n                existingLead.address_state = call.address_state || existingLead.address_state;\n                existingLead.address_zip = call.address_zip || existingLead.address_zip;\n                existingLead.last_call_date = call.call_id;\n                existingLead.last_disposition = pcaMap.get(call.call_id) || call.disposition;\n                existingLead.agreed_amount = call.agreed_amount || existingLead.agreed_amount;\n            }\n        }\n    }\n    const leads = Array.from(leadsMap.values());\n    console.log(\"✅ Encontrados \".concat(leads.length, \" leads \\xfanicos\"));\n    return leads;\n}\n// Función para obtener historial completo (calls + callbacks) por número de teléfono\nasync function getCallHistoryByPhone(phoneNumber) {\n    console.log(\"\\uD83D\\uDCDE Obteniendo historial completo para: \".concat(phoneNumber));\n    try {\n        // Obtener llamadas regulares\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"❌ Error obteniendo llamadas:\", callsError);\n            throw callsError;\n        }\n        console.log(\"\\uD83D\\uDCDE Encontradas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas para \").concat(phoneNumber));\n        // Obtener callbacks para ese número\n        const { data: callbacks, error: callbacksError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"\\uD83D\\uDD04 Encontrados \".concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks para \").concat(phoneNumber));\n        if (callbacksError) {\n            console.error(\"❌ Error obteniendo callbacks:\", callbacksError);\n        // No lanzamos error, solo logueamos\n        }\n        // Obtener dispositions del PCA para las calls\n        let pcaMap = new Map();\n        let callbackMap = new Map();\n        if (calls && calls.length > 0) {\n            const callIds = calls.map((call)=>call.call_id);\n            // Obtener dispositions del PCA\n            const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n            if (pcaData) {\n                pcaData.forEach((pca)=>{\n                    pcaMap.set(pca.call_id, pca.disposition);\n                });\n            }\n            // Obtener callbacks asociados a estas calls\n            const { data: associatedCallbacks } = await supabase.from(\"callbacks\").select(\"*\").in(\"call_id\", callIds);\n            if (associatedCallbacks) {\n                associatedCallbacks.forEach((callback)=>{\n                    if (callback.call_id) {\n                        callbackMap.set(callback.call_id, callback);\n                    } else {\n                        console.log(\"⚠️ Callback \".concat(callback.id, \" no tiene call_id\"));\n                    }\n                });\n            }\n            console.log(\"\\uD83D\\uDD17 Calls con callbacks asociados: \".concat(Array.from(callbackMap.keys()).join(\", \")));\n            console.log(\"\\uD83D\\uDCCB Todos los call_ids de calls: \".concat((calls || []).map((c)=>c.call_id).join(\", \")));\n            console.log(\"\\uD83D\\uDCCB Todos los call_ids de callbacks: \".concat((callbacks || []).map((c)=>c.call_id).join(\", \")));\n        }\n        // Combinar y marcar el tipo - SIN DUPLICAR\n        const allInteractions = [\n            // Procesar solo las calls que NO tienen callback asociado (mostrarlas como calls normales)\n            ...(calls || []).filter((call)=>{\n                const hasCallback = callbackMap.has(call.call_id);\n                console.log(\"\\uD83D\\uDCDE Call \".concat(call.call_id, ': disposition=\"').concat(call.disposition, '\", hasCallback=').concat(hasCallback));\n                return !hasCallback;\n            }).map((call)=>{\n                const pcaDisposition = pcaMap.get(call.call_id) || call.disposition;\n                const result = {\n                    ...call,\n                    type: \"call\",\n                    date: call.call_id,\n                    display_date: call.call_id,\n                    disposition: pcaDisposition\n                };\n                console.log(\"\\uD83D\\uDCDE Call \".concat(call.call_id, ': disposition=\"').concat(pcaDisposition, '\"'));\n                return result;\n            }),\n            // Procesar TODOS los callbacks (incluye los que tienen call asociada y los independientes)\n            ...(callbacks || []).map((callback)=>{\n                const associatedCall = calls === null || calls === void 0 ? void 0 : calls.find((call)=>call.call_id === callback.call_id);\n                const pcaDisposition = associatedCall ? pcaMap.get(callback.call_id) || associatedCall.disposition : callback.disposition;\n                const result = {\n                    ...callback,\n                    type: \"callback\",\n                    date: callback.created_at || callback.id,\n                    display_date: callback.callback_time || callback.created_at || callback.id,\n                    // Si tiene call asociada, usar algunos datos de la call (como address, business_name original)\n                    ...associatedCall ? {\n                        business_name: associatedCall.business_name,\n                        owner_name: callback.callback_owner_name || associatedCall.owner_name,\n                        address_street: associatedCall.address_street,\n                        address_city: associatedCall.address_city,\n                        address_state: associatedCall.address_state,\n                        owner_phone: associatedCall.owner_phone,\n                        agreed_amount: associatedCall.agreed_amount,\n                        disposition: pcaDisposition\n                    } : {\n                        business_name: callback.business_name,\n                        owner_name: callback.callback_owner_name,\n                        agreed_amount: undefined,\n                        disposition: callback.disposition\n                    },\n                    // Información específica del callback\n                    callback_time: callback.callback_time,\n                    callback_owner_name: callback.callback_owner_name\n                };\n                console.log(\"\\uD83D\\uDD04 Callback \".concat(callback.id || callback.call_id, \": \").concat(associatedCall ? \"con call asociada\" : \"independiente\", ', owner=\"').concat(callback.callback_owner_name, '\"'));\n                return result;\n            })\n        ];\n        // Ordenar por fecha (más recientes primero)\n        allInteractions.sort((a, b)=>{\n            if (a.date > b.date) return -1;\n            if (a.date < b.date) return 1;\n            return 0;\n        });\n        console.log(\"✅ Procesadas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas (\").concat((calls || []).filter((call)=>!callbackMap.has(call.call_id)).length, \" calls + \").concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks) para \").concat(phoneNumber));\n        return allInteractions;\n    } catch (error) {\n        console.error(\"❌ Error obteniendo historial completo:\", error);\n        throw error;\n    }\n}\n// Función para contar cuántas llamadas tiene un número\nasync function getCallCountByPhone(phoneNumber) {\n    const { count, error } = await supabase.from(\"calls\").select(\"call_id\", {\n        count: \"exact\",\n        head: true\n    }).eq(\"to_number\", phoneNumber);\n    if (error) {\n        console.error(\"❌ Error contando llamadas:\", error);\n        return 0;\n    }\n    return count || 0;\n}\n// Función para verificar si una llamada tiene historial\nasync function hasCallHistory(callId) {\n    // Primero obtenemos el to_number de la llamada actual\n    const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"to_number\").eq(\"call_id\", callId).single();\n    if (callError || !(callData === null || callData === void 0 ? void 0 : callData.to_number)) {\n        return {\n            hasHistory: false,\n            count: 0\n        };\n    }\n    const phoneNumber = callData.to_number;\n    const count = await getCallCountByPhone(phoneNumber);\n    return {\n        hasHistory: count > 1,\n        count,\n        phoneNumber\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDb0Q7QUFFcEQsTUFBTUMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBRTFELE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSSxpQkFBZ0I7QUE0RmxFLDBDQUEwQztBQUNuQyxlQUFlRztJQUNwQixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUgsU0FDM0JJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDLFdBQVc7UUFBRUMsV0FBVztJQUFNO0lBRXZDLElBQUlKLE9BQU87UUFDVCxNQUFNQTtJQUNSO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLGlFQUFpRTtBQUMxRCxlQUFlTTtJQUNwQixJQUFJO1FBQ0YsdUNBQXVDO1FBQ3ZDLE1BQU0sRUFBRU4sTUFBTU8sS0FBSyxFQUFFTixPQUFPTyxVQUFVLEVBQUUsR0FBRyxNQUFNVixTQUM5Q0ksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUMsV0FBVztZQUFFQyxXQUFXO1FBQU07UUFFdkMsSUFBSUcsWUFBWTtZQUNkQyxRQUFRUixLQUFLLENBQUMseUJBQXlCTztZQUN2QyxNQUFNQTtRQUNSO1FBRUEsSUFBSSxDQUFDRCxPQUFPLE9BQU8sRUFBRTtRQUVyQixvREFBb0Q7UUFDcEQsTUFBTSxFQUFFUCxNQUFNVSxPQUFPLEVBQUVULE9BQU9VLFFBQVEsRUFBRSxHQUFHLE1BQU1iLFNBQzlDSSxJQUFJLENBQUMsT0FDTEMsTUFBTSxDQUFDO1FBRVYsSUFBSVEsVUFBVTtZQUNaRixRQUFRUixLQUFLLENBQUMsNEJBQTRCVTtRQUMxQyxvRUFBb0U7UUFDdEU7UUFFQSxNQUFNQyxlQUFlLElBQUlDLElBQUlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksR0FBRyxDQUFD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QUU7UUFDckMsT0FBTztZQUFFOEYsWUFBWTtZQUFPekgsT0FBTztRQUFFO0lBQ3ZDO0lBRUEsTUFBTWtHLGNBQWN4RCxTQUFTZixTQUFTO0lBQ3RDLE1BQU0zQixRQUFRLE1BQU11SCxvQkFBb0JyQjtJQUV4QyxPQUFPO1FBQ0x1QixZQUFZekgsUUFBUTtRQUNwQkE7UUFDQWtHO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3N1cGFiYXNlLnRzPzA2ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5cbmNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIVxuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkhXG5cbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KVxuXG4vLyBEZWZpbmlyIGVsIHRpcG8gZGUgZGF0b3MgcGFyYSBsYSB0YWJsYSBjYWxsc1xuZXhwb3J0IGludGVyZmFjZSBDYWxsIHtcbiAgY2FsbF9pZDogc3RyaW5nXG4gIGFnZW50X2lkPzogc3RyaW5nXG4gIGFnZW50X25hbWU/OiBzdHJpbmdcbiAgdHJhbnNjcmlwdD86IHN0cmluZ1xuICBkaXNwb3NpdGlvbj86IHN0cmluZ1xuICBidXNpbmVzc19uYW1lPzogc3RyaW5nXG4gIG93bmVyX25hbWU/OiBzdHJpbmdcbiAgb3duZXJfcGhvbmU/OiBzdHJpbmdcbiAgb3duZXJfZW1haWw/OiBzdHJpbmdcbiAgbG9jYXRpb25fdHlwZT86IHN0cmluZ1xuICBhZGRyZXNzX3N0cmVldD86IHN0cmluZ1xuICBhZGRyZXNzX2NpdHk/OiBzdHJpbmdcbiAgYWRkcmVzc19zdGF0ZT86IHN0cmluZ1xuICBhZGRyZXNzX3ppcD86IHN0cmluZ1xuICBhZ3JlZWRfYW1vdW50PzogbnVtYmVyXG4gIG1vbnRobHlfYW1vdW50PzogbnVtYmVyXG4gIHllYXJseV9hbW91bnQ/OiBudW1iZXJcbiAgY29tcGFueV9rZXk/OiBzdHJpbmdcbiAgYWdlbnRfZXh0ZXJuYWxfaWQ/OiBzdHJpbmdcbiAgYWRkcmVzc19saW5lMj86IHN0cmluZ1xuICBidXNpbmVzc19ob3Vycz86IHN0cmluZ1xuICBvdGhlcl9sb2NhdGlvbnM/OiBzdHJpbmdcbiAgZnJvbV9udW1iZXI/OiBzdHJpbmdcbiAgdG9fbnVtYmVyPzogc3RyaW5nXG59XG5cbi8vIFRpcG8gZXh0ZW5kaWRvIHBhcmEgbGxhbWFkYXMgY29uIGluZm9ybWFjacOzbiBkZSBQQ0FcbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFdpdGhQQ0FJbmZvIGV4dGVuZHMgQ2FsbCB7XG4gIGhhc1BDQTogYm9vbGVhblxuICBoYXNDYWxsYmFja3M/OiBib29sZWFuXG59XG5cbi8vIERlZmluaXIgZWwgdGlwbyBkZSBkYXRvcyBwYXJhIGxhIHRhYmxhIGNhbGxiYWNrc1xuZXhwb3J0IGludGVyZmFjZSBDYWxsYmFjayB7XG4gIGlkOiBzdHJpbmdcbiAgaWRfdXVpZF9vbGQ6IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIGxlYWRfaWQ/OiBzdHJpbmdcbiAgY2FsbF9pZD86IHN0cmluZ1xuICBjb21wYW55X2lkPzogc3RyaW5nXG4gIGFnZW50X2lkPzogc3RyaW5nXG4gIGRpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIGNhbGxiYWNrX293bmVyX25hbWU6IHN0cmluZ1xuICBjYWxsYmFja190aW1lPzogc3RyaW5nXG4gIGNhbGxiYWNrX3dpbmRvd19ub3RlPzogc3RyaW5nXG4gIHBheWxvYWQ/OiBhbnlcbiAgYWdlbnRfZXh0ZXJuYWxfaWQ/OiBzdHJpbmdcbiAgbGVhZF9zdGF0ZT86IHN0cmluZ1xuICBsZWFkX2NpdHk/OiBzdHJpbmdcbiAgbGVhZF96aXA/OiBzdHJpbmdcbiAgY2FsbF9zdGFydGVkX2F0Pzogc3RyaW5nXG4gIGNhbGxlcl90ej86IHN0cmluZ1xuICB0el9hbWJpZ3VvdXM/OiBib29sZWFuXG4gIGNhbGxiYWNrX3RpbWVfdGV4dF9yYXc/OiBzdHJpbmdcbiAgZXZlbnRfdHlwZT86IHN0cmluZ1xuICBmcm9tX251bWJlcj86IHN0cmluZ1xuICB0b19udW1iZXI/OiBzdHJpbmdcbn1cblxuLy8gRGVmaW5pciBlbCB0aXBvIGRlIGRhdG9zIHBhcmEgbGEgdGFibGEgcGNhXG5leHBvcnQgaW50ZXJmYWNlIFBDQSB7XG4gIGlkOiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIGNhbGxfaWQ6IHN0cmluZ1xuICBhZ2VudF9uYW1lPzogc3RyaW5nXG4gIGRpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIGNhbGxfc3VjY2Vzc2Z1bD86IGJvb2xlYW5cbiAgdXNlcl9zZW50aW1lbnQ/OiBzdHJpbmdcbiAgZHVyYXRpb25fbXM/OiBudW1iZXJcbiAgc3RhcnRfdGltZXN0YW1wPzogc3RyaW5nXG4gIGVuZF90aW1lc3RhbXA/OiBzdHJpbmdcbiAgZGlzY29ubmVjdGlvbl9yZWFzb24/OiBzdHJpbmdcbiAgY2FsbF9zdW1tYXJ5Pzogc3RyaW5nXG4gIHRyYW5zY3JpcHQ/OiBzdHJpbmdcbiAgcmVjb3JkaW5nX3VybD86IHN0cmluZ1xuICByZWNvcmRpbmdfbXVsdGlfY2hhbm5lbF91cmw/OiBzdHJpbmdcbiAgcHVibGljX2xvZ191cmw/OiBzdHJpbmdcbiAgY2FsbF9jb3N0PzogbnVtYmVyXG4gIGFuYWx5c2lzPzogYW55XG4gIGN1c3RvbV9hbmFseXNpc19kYXRhPzogYW55XG4gIGxsbV90b2tlbl91c2FnZT86IGFueVxuICB1cGRhdGVkX2F0OiBzdHJpbmdcbiAgYWdlbnRfZXh0ZXJuYWxfaWQ/OiBzdHJpbmdcbiAgZnJvbV9udW1iZXI/OiBzdHJpbmdcbiAgdG9fbnVtYmVyPzogc3RyaW5nXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciB0b2RhcyBsYXMgbGxhbWFkYXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxscygpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnY2FsbHMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5vcmRlcignY2FsbF9pZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yXG4gIH1cblxuICByZXR1cm4gZGF0YSBhcyBDYWxsW11cbn1cblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIGxsYW1hZGFzIGNvbiBpbmZvcm1hY2nDs24gZGUgc2kgdGllbmVuIFBDQVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxzV2l0aFBDQUluZm8oKTogUHJvbWlzZTxDYWxsV2l0aFBDQUluZm9bXT4ge1xuICB0cnkge1xuICAgIC8vIFByaW1lcm8gb2J0ZW5lbW9zIHRvZGFzIGxhcyBsbGFtYWRhc1xuICAgIGNvbnN0IHsgZGF0YTogY2FsbHMsIGVycm9yOiBjYWxsc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLm9yZGVyKCdjYWxsX2lkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBpZiAoY2FsbHNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FsbHM6JywgY2FsbHNFcnJvcilcbiAgICAgIHRocm93IGNhbGxzRXJyb3JcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxzKSByZXR1cm4gW11cblxuICAgIC8vIEx1ZWdvIG9idGVuZW1vcyB0b2RvcyBsb3MgY2FsbF9pZHMgcXVlIHRpZW5lbiBQQ0FcbiAgICBjb25zdCB7IGRhdGE6IHBjYURhdGEsIGVycm9yOiBwY2FFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnY2FsbF9pZCcpXG5cbiAgICBpZiAocGNhRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFBDQSBkYXRhOicsIHBjYUVycm9yKVxuICAgICAgLy8gTm8gbGFuemFtb3MgZXJyb3IgYXF1w60sIHNvbG8gbG9ndWVhbW9zIHkgY29udGludWFtb3Mgc2luIFBDQSBpbmZvXG4gICAgfVxuXG4gICAgY29uc3QgY2FsbHNXaXRoUENBID0gbmV3IFNldChwY2FEYXRhPy5tYXAocGNhID0+IHBjYS5jYWxsX2lkKSB8fCBbXSlcblxuICAgIC8vIENvbWJpbmFtb3MgbGEgaW5mb3JtYWNpw7NuXG4gICAgcmV0dXJuIGNhbGxzLm1hcChjYWxsID0+ICh7XG4gICAgICAuLi5jYWxsLFxuICAgICAgaGFzUENBOiBjYWxsc1dpdGhQQ0EuaGFzKGNhbGwuY2FsbF9pZCksXG4gICAgICBoYXNDYWxsYmFja3M6IGZhbHNlIC8vIFlhIG5vIHVzYW1vcyBjYWxsYmFja3MgY29tbyBjb25jZXB0b1xuICAgIH0pKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENhbGxzV2l0aFBDQUluZm86JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyDwn5OKIFBBR0lOQUNJw5NOIEVTQ0FMQUJMRSBQQVJBIFBST0RVQ0NJw5NOXG5cbi8vIEludGVyZmF6IHBhcmEgcGFyw6FtZXRyb3MgZGUgcGFnaW5hY2nDs25cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGlvblBhcmFtcyB7XG4gIHBhZ2U6IG51bWJlclxuICBsaW1pdDogbnVtYmVyXG4gIHNlYXJjaD86IHN0cmluZ1xuICBmaWx0ZXJzPzoge1xuICAgIGhhc1BDQT86IGJvb2xlYW5cbiAgICBkaXNwb3NpdGlvbj86IHN0cmluZ1xuICB9XG4gIHNvcnRCeT86IHN0cmluZ1xuICBzb3J0T3JkZXI/OiAnYXNjJyB8ICdkZXNjJ1xufVxuXG4vLyBJbnRlcmZheiBwYXJhIHJlc3B1ZXN0YSBwYWdpbmFkYVxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0ZWRSZXNwb25zZTxUPiB7XG4gIGRhdGE6IFRbXVxuICB0b3RhbDogbnVtYmVyXG4gIHBhZ2U6IG51bWJlclxuICBsaW1pdDogbnVtYmVyXG4gIHRvdGFsUGFnZXM6IG51bWJlclxufVxuXG4vLyBGdW5jacOzbiBOVUVWQTogT2J0ZW5lciBsbGFtYWRhcyBjb24gcGFnaW5hY2nDs24gZW4gc2Vydmlkb3IgKEVTQ0FMQUJMRSlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsc1dpdGhQYWdpbmF0aW9uKHBhcmFtczogUGFnaW5hdGlvblBhcmFtcyk6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8Q2FsbFdpdGhQQ0FJbmZvPj4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIE9idGVuaWVuZG8gbGxhbWFkYXMgcGFnaW5hZGFzOicsIHBhcmFtcylcbiAgICBcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxzJylcbiAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnIH0pXG5cbiAgICAvLyBBcGxpY2FyIGZpbHRyb3MgZGUgYsO6c3F1ZWRhXG4gICAgaWYgKHBhcmFtcy5zZWFyY2gpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkub3IoYGJ1c2luZXNzX25hbWUuaWxpa2UuJSR7cGFyYW1zLnNlYXJjaH0lLG93bmVyX25hbWUuaWxpa2UuJSR7cGFyYW1zLnNlYXJjaH0lLG93bmVyX3Bob25lLmlsaWtlLiUke3BhcmFtcy5zZWFyY2h9JWApXG4gICAgfVxuXG4gICAgLy8gQXBsaWNhciBmaWx0cm9zIGFkaWNpb25hbGVzXG4gICAgaWYgKHBhcmFtcy5maWx0ZXJzPy5kaXNwb3NpdGlvbikge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnZGlzcG9zaXRpb24nLCBwYXJhbXMuZmlsdGVycy5kaXNwb3NpdGlvbilcbiAgICB9XG5cbiAgICAvLyBBcGxpY2FyIG9yZGVuYW1pZW50b1xuICAgIGNvbnN0IHNvcnRCeSA9IHBhcmFtcy5zb3J0QnkgfHwgJ2NhbGxfaWQnXG4gICAgY29uc3Qgc29ydE9yZGVyID0gcGFyYW1zLnNvcnRPcmRlciA9PT0gJ2FzYycgPyB7IGFzY2VuZGluZzogdHJ1ZSB9IDogeyBhc2NlbmRpbmc6IGZhbHNlIH1cbiAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKHNvcnRCeSwgc29ydE9yZGVyKVxuXG4gICAgLy8gQXBsaWNhciBwYWdpbmFjacOzblxuICAgIGNvbnN0IG9mZnNldCA9IChwYXJhbXMucGFnZSAtIDEpICogcGFyYW1zLmxpbWl0XG4gICAgcXVlcnkgPSBxdWVyeS5yYW5nZShvZmZzZXQsIG9mZnNldCArIHBhcmFtcy5saW1pdCAtIDEpXG5cbiAgICBjb25zdCB7IGRhdGE6IGNhbGxzLCBjb3VudCwgZXJyb3I6IGNhbGxzRXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XG5cbiAgICBpZiAoY2FsbHNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGFnaW5hdGVkIGNhbGxzOicsIGNhbGxzRXJyb3IpXG4gICAgICB0aHJvdyBjYWxsc0Vycm9yXG4gICAgfVxuXG4gICAgaWYgKCFjYWxscyB8fCBjYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICB0b3RhbDogY291bnQgfHwgMCxcbiAgICAgICAgcGFnZTogcGFyYW1zLnBhZ2UsXG4gICAgICAgIGxpbWl0OiBwYXJhbXMubGltaXQsXG4gICAgICAgIHRvdGFsUGFnZXM6IE1hdGguY2VpbCgoY291bnQgfHwgMCkgLyBwYXJhbXMubGltaXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT2J0ZW5lciBpbmZvcm1hY2nDs24gZGUgUENBIHNvbG8gcGFyYSBsYXMgbGxhbWFkYXMgZGUgZXN0YSBww6FnaW5hXG4gICAgY29uc3QgY2FsbElkcyA9IGNhbGxzLm1hcChjYWxsID0+IGNhbGwuY2FsbF9pZClcbiAgICBjb25zdCB7IGRhdGE6IHBjYURhdGEsIGVycm9yOiBwY2FFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnY2FsbF9pZCwgZGlzcG9zaXRpb24nKVxuICAgICAgLmluKCdjYWxsX2lkJywgY2FsbElkcylcblxuICAgIGlmIChwY2FFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgUENBIGRhdGE6JywgcGNhRXJyb3IpXG4gICAgfVxuXG4gICAgLy8gT2J0ZW5lciBjYWxsYmFja3MgYXNvY2lhZG9zIGEgZXN0YXMgY2FsbHNcbiAgICBjb25zdCB7IGRhdGE6IGNhbGxiYWNrRGF0YSwgZXJyb3I6IGNhbGxiYWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbGJhY2tzJylcbiAgICAgIC5zZWxlY3QoJ2NhbGxfaWQsIGNhbGxiYWNrX293bmVyX25hbWUsIHRvX251bWJlcicpXG4gICAgICAuaW4oJ2NhbGxfaWQnLCBjYWxsSWRzKVxuXG4gICAgaWYgKGNhbGxiYWNrRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNhbGxiYWNrIGRhdGE6JywgY2FsbGJhY2tFcnJvcilcbiAgICB9XG5cblxuXG4gICAgY29uc3QgY2FsbHNXaXRoUENBID0gbmV3IFNldChwY2FEYXRhPy5tYXAocGNhID0+IHBjYS5jYWxsX2lkKSB8fCBbXSlcbiAgICBjb25zdCBwY2FEaXNwb3NpdGlvbk1hcCA9IG5ldyBNYXAoXG4gICAgICAocGNhRGF0YSB8fCBbXSkubWFwKHBjYSA9PiBbcGNhLmNhbGxfaWQsIHBjYS5kaXNwb3NpdGlvbl0pXG4gICAgKVxuICAgIFxuICAgIC8vIENyZWFyIG1hcGFzIHNlcGFyYWRvcyBwYXJhIG5vbWJyZSB5IHRlbMOpZm9ub1xuICAgIGNvbnN0IGNhbGxiYWNrT3duZXJOYW1lTWFwID0gbmV3IE1hcChcbiAgICAgIChjYWxsYmFja0RhdGEgfHwgW10pLm1hcChjYWxsYmFjayA9PiBbY2FsbGJhY2suY2FsbF9pZCwgY2FsbGJhY2suY2FsbGJhY2tfb3duZXJfbmFtZV0pXG4gICAgKVxuICAgIGNvbnN0IGNhbGxiYWNrT3duZXJQaG9uZU1hcCA9IG5ldyBNYXAoXG4gICAgICAoY2FsbGJhY2tEYXRhIHx8IFtdKS5tYXAoY2FsbGJhY2sgPT4gW2NhbGxiYWNrLmNhbGxfaWQsIGNhbGxiYWNrLnRvX251bWJlcl0pXG4gICAgKVxuXG4gICAgLy8gQ29tYmluYXIgaW5mb3JtYWNpw7NuXG4gICAgY29uc3QgY2FsbHNXaXRoSW5mbzogQ2FsbFdpdGhQQ0FJbmZvW10gPSBjYWxscy5tYXAoY2FsbCA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja093bmVyTmFtZSA9IGNhbGxiYWNrT3duZXJOYW1lTWFwLmdldChjYWxsLmNhbGxfaWQpXG4gICAgICBjb25zdCBjYWxsYmFja093bmVyUGhvbmUgPSBjYWxsYmFja093bmVyUGhvbmVNYXAuZ2V0KGNhbGwuY2FsbF9pZClcbiAgICAgIGNvbnN0IHBjYURpc3Bvc2l0aW9uID0gcGNhRGlzcG9zaXRpb25NYXAuZ2V0KGNhbGwuY2FsbF9pZClcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY2FsbCxcbiAgICAgICAgLy8gU2kgaGF5IGNhbGxiYWNrX293bmVyX25hbWUsIHVzYXJsbyBlbiBsdWdhciBkZWwgb3duZXJfbmFtZSBvcmlnaW5hbFxuICAgICAgICBvd25lcl9uYW1lOiBjYWxsYmFja093bmVyTmFtZSB8fCBjYWxsLm93bmVyX25hbWUsXG4gICAgICAgIC8vIFNpIGhheSBjYWxsYmFja19vd25lcl9waG9uZSwgdXNhcmxvIGVuIGx1Z2FyIGRlbCBvd25lcl9waG9uZSBvcmlnaW5hbFxuICAgICAgICBvd25lcl9waG9uZTogY2FsbGJhY2tPd25lclBob25lIHx8IGNhbGwub3duZXJfcGhvbmUsXG4gICAgICAgIC8vIFNpIGhheSBkaXNwb3NpdGlvbiBkZWwgUENBLCB1c2FybG8gZW4gbHVnYXIgZGVsIGRpc3Bvc2l0aW9uIG9yaWdpbmFsXG4gICAgICAgIGRpc3Bvc2l0aW9uOiBwY2FEaXNwb3NpdGlvbiB8fCBjYWxsLmRpc3Bvc2l0aW9uLFxuICAgICAgICBoYXNQQ0E6IGNhbGxzV2l0aFBDQS5oYXMoY2FsbC5jYWxsX2lkKSxcbiAgICAgICAgaGFzQ2FsbGJhY2tzOiBjYWxsYmFja093bmVyTmFtZU1hcC5oYXMoY2FsbC5jYWxsX2lkKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBBcGxpY2FyIGZpbHRyb3MgcG9zdC1xdWVyeSBzaSBlcyBuZWNlc2FyaW9cbiAgICBsZXQgZmlsdGVyZWRDYWxscyA9IGNhbGxzV2l0aEluZm9cbiAgICBpZiAocGFyYW1zLmZpbHRlcnM/Lmhhc1BDQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWx0ZXJlZENhbGxzID0gZmlsdGVyZWRDYWxscy5maWx0ZXIoY2FsbCA9PiBjYWxsLmhhc1BDQSA9PT0gcGFyYW1zLmZpbHRlcnMhLmhhc1BDQSlcbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbFBhZ2VzID0gTWF0aC5jZWlsKChjb3VudCB8fCAwKSAvIHBhcmFtcy5saW1pdClcblxuICAgIGNvbnNvbGUubG9nKGDinIUgRGV2b2x2aWVuZG8gJHtmaWx0ZXJlZENhbGxzLmxlbmd0aH0gbGxhbWFkYXMgKHDDoWdpbmEgJHtwYXJhbXMucGFnZX0vJHt0b3RhbFBhZ2VzfSkgZGUgJHtjb3VudH0gdG90YWxgKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBmaWx0ZXJlZENhbGxzLFxuICAgICAgdG90YWw6IGNvdW50IHx8IDAsXG4gICAgICBwYWdlOiBwYXJhbXMucGFnZSxcbiAgICAgIGxpbWl0OiBwYXJhbXMubGltaXQsXG4gICAgICB0b3RhbFBhZ2VzXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENhbGxzV2l0aFBhZ2luYXRpb246JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgY2FsbGJhY2tzIHBvciBjYWxsX2lkXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbGJhY2tzQnlDYWxsSWQoY2FsbElkOiBzdHJpbmcpOiBQcm9taXNlPENhbGxiYWNrW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAgIC5vcmRlcignY2FsbGJhY2tfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYWxsYmFja3M6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2FsbGJhY2tzQnlDYWxsSWQ6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgYW7DoWxpc2lzIFBDQSBwb3IgY2FsbF9pZFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBDQUJ5Q2FsbElkKGNhbGxJZDogc3RyaW5nKTogUHJvbWlzZTxQQ0FbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdjYWxsX2lkJywgY2FsbElkKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFBDQSBkYXRhOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldFBDQUJ5Q2FsbElkOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gTnVldmEgZnVuY2nDs24gcGFyYSBvYnRlbmVyIGluZm9ybWFjacOzbiBjb21wbGV0YSBkZWwgY2xpZW50ZSB5IGFuw6FsaXNpcyAoY2FsbHMgeSBjYWxsYmFja3MpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbERldGFpbHNXaXRoUENBKGNhbGxJZDogc3RyaW5nKTogUHJvbWlzZTx7IGNhbGw6IENhbGwgfCBudWxsLCBwY2E6IFBDQVtdLCBpc0NhbGxiYWNrOiBib29sZWFuLCBjYWxsYmFjaz86IGFueSB9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gZ2V0Q2FsbERldGFpbHNXaXRoUENBIC0gYnVzY2FuZG8gY2FsbElkOicsIGNhbGxJZClcbiAgICBcbiAgICAvLyBPYnRlbmVyIGxhIGxsYW1hZGEgKHNpZW1wcmUgZXhpc3RlKVxuICAgIGNvbnN0IHsgZGF0YTogY2FsbERhdGEsIGVycm9yOiBjYWxsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NhbGxfaWQnLCBjYWxsSWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGNvbnNvbGUubG9nKCfwn5OeIFJlc3VsdGFkbyBiw7pzcXVlZGEgZW4gY2FsbHM6JywgeyBjYWxsRGF0YSwgY2FsbEVycm9yIH0pXG5cbiAgICBpZiAoY2FsbEVycm9yIHx8ICFjYWxsRGF0YSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIE5vIHNlIGVuY29udHLDsyBsYSBjYWxsIGNvbiBJRDonLCBjYWxsSWQpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxsOiBudWxsLFxuICAgICAgICBwY2E6IFtdLFxuICAgICAgICBpc0NhbGxiYWNrOiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcmlmaWNhciBzaSBlc3RhIGNhbGwgdGllbmUgdW4gY2FsbGJhY2sgYXNvY2lhZG9cbiAgICBjb25zdCB7IGRhdGE6IGNhbGxiYWNrRGF0YSwgZXJyb3I6IGNhbGxiYWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbGJhY2tzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdjYWxsX2lkJywgY2FsbElkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBjb25zb2xlLmxvZygn77+9IFZlcmlmaWNhbmRvIHNpIHRpZW5lIGNhbGxiYWNrIGFzb2NpYWRvOicsIHsgY2FsbGJhY2tEYXRhLCBjYWxsYmFja0Vycm9yIH0pXG5cbiAgICAvLyBPYnRlbmVyIFBDQVxuICAgIGNvbnN0IHBjYURhdGEgPSBhd2FpdCBnZXRQQ0FCeUNhbGxJZChjYWxsSWQpXG5cbiAgICBpZiAoY2FsbGJhY2tEYXRhICYmICFjYWxsYmFja0Vycm9yKSB7XG4gICAgICAvLyBFcyB1bmEgY2FsbCBxdWUgVEFNQknDiU4gZXMgdW4gY2FsbGJhY2tcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQ2FsbCBjb24gY2FsbGJhY2sgYXNvY2lhZG8gZW5jb250cmFkbycpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxsOiBjYWxsRGF0YSxcbiAgICAgICAgcGNhOiBwY2FEYXRhLFxuICAgICAgICBpc0NhbGxiYWNrOiB0cnVlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tEYXRhXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVzIHVuYSBjYWxsIG5vcm1hbCAoc2luIGNhbGxiYWNrKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBDYWxsIG5vcm1hbCAoc2luIGNhbGxiYWNrKScpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxsOiBjYWxsRGF0YSxcbiAgICAgICAgcGNhOiBwY2FEYXRhLFxuICAgICAgICBpc0NhbGxiYWNrOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gZ2V0Q2FsbERldGFpbHNXaXRoUENBOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRnVuY2nDs24gZGUgZGVidWcgcGFyYSB2ZXIgdG9kb3MgbG9zIFBDQSBkaXNwb25pYmxlc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFBDQSgpIHtcbiAgY29uc29sZS5sb2coJ0ludGVudGFuZG8gb2J0ZW5lciB0b2RvcyBsb3MgUENBLi4uJylcbiAgXG4gIC8vIFByaW1lcm8gaW50ZW50YW1vcyBzaW4gbMOtbWl0ZXNcbiAgY29uc3QgeyBkYXRhLCBlcnJvciwgc3RhdHVzLCBzdGF0dXNUZXh0IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwY2EnKVxuICAgIC5zZWxlY3QoJ2lkLCBjYWxsX2lkLCBhZ2VudF9uYW1lLCBjcmVhdGVkX2F0JylcbiAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICBjb25zb2xlLmxvZygnUmVzcHVlc3RhIFBDQTonLCB7IFxuICAgIGRhdGEsIFxuICAgIGVycm9yLCBcbiAgICBzdGF0dXMsIFxuICAgIHN0YXR1c1RleHQsXG4gICAgZGF0YUxlbmd0aDogZGF0YT8ubGVuZ3RoIHx8IDBcbiAgfSlcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhbGxhZG8gYWwgb2J0ZW5lciBQQ0E6Jywge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIGRldGFpbHM6IGVycm9yLmRldGFpbHMsXG4gICAgICBoaW50OiBlcnJvci5oaW50LFxuICAgICAgY29kZTogZXJyb3IuY29kZVxuICAgIH0pXG4gICAgXG4gICAgLy8gSW50ZW50YW1vcyBjb24gdW4gcXVlcnkgbcOhcyBzaW1wbGVcbiAgICBjb25zb2xlLmxvZygnSW50ZW50YW5kbyBxdWVyeSBtw6FzIHNpbXBsZS4uLicpXG4gICAgY29uc3QgeyBkYXRhOiBzaW1wbGVEYXRhLCBlcnJvcjogc2ltcGxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmxpbWl0KDEpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ1F1ZXJ5IHNpbXBsZSByZXN1bHRhZG86JywgeyBzaW1wbGVEYXRhLCBzaW1wbGVFcnJvciB9KVxuICAgIFxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICBjb25zb2xlLmxvZygnUENBIG9idGVuaWRvcyBleGl0b3NhbWVudGU6JywgZGF0YSlcbiAgcmV0dXJuIGRhdGFcbn1cblxuLy8gRnVuY2nDs24gZGUgZGVidWcgc2ltcGxlIHBhcmEgdmVyaWZpY2FyIGFjY2VzbyBhIFBDQVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RQQ0FBY2Nlc3MoKSB7XG4gIGNvbnNvbGUubG9nKCdUZXN0ZWFuZG8gYWNjZXNvIGEgdGFibGEgUENBLi4uJylcbiAgXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwY2EnKVxuICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG5cbiAgY29uc29sZS5sb2coJ1Rlc3QgUENBIC0gQ291bnQ6JywgY291bnQsICdFcnJvcjonLCBlcnJvcilcbiAgXG4gIHJldHVybiB7IGNvdW50LCBlcnJvciB9XG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgdmVyaWZpY2FyIHRvZGFzIGxhcyB0YWJsYXMgZGlzcG9uaWJsZXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXN0QWxsVGFibGVzQWNjZXNzKCkge1xuICBjb25zdCB0YWJsZXMgPSBbJ2NhbGxzJywgJ3BjYScsICdjYWxsYmFja3MnXVxuICBjb25zdCByZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCB7IGNvdW50OiBudW1iZXIgfCBudWxsLCBlcnJvcjogc3RyaW5nIHwgbnVsbCB9PiA9IHt9XG4gIFxuICBmb3IgKGNvbnN0IHRhYmxlIG9mIHRhYmxlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgVGVzdGVhbmRvIHRhYmxhOiAke3RhYmxlfWApXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20odGFibGUpXG4gICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICBcbiAgICAgIHJlc3VsdHNbdGFibGVdID0geyBjb3VudCwgZXJyb3I6IGVycm9yPy5tZXNzYWdlIHx8IG51bGwgfVxuICAgICAgY29uc29sZS5sb2coYCR7dGFibGV9OiAke2NvdW50fSByZWdpc3Ryb3MsIGVycm9yOmAsIGVycm9yPy5tZXNzYWdlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbydcbiAgICAgIHJlc3VsdHNbdGFibGVdID0geyBjb3VudDogMCwgZXJyb3I6IGVycm9yTWVzc2FnZSB9XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBlbiB0YWJsYSAke3RhYmxlfTpgLCBlcnIpXG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0c1xufVxuXG4vLyBGdW5jacOzbiBlc3BlY8OtZmljYSBwYXJhIGRpYWdub3N0aWNhciBlbCBwcm9ibGVtYSBkZSBQQ0FcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaWFnbm9zZVBDQUFjY2VzcygpIHtcbiAgY29uc29sZS5sb2coJ/CflI0gRGlhZ25vc3RpY2FuZG8gYWNjZXNvIGEgdGFibGEgUENBLi4uJylcbiAgXG4gIGNvbnN0IHRlc3RzID0gW11cbiAgXG4gIC8vIFRlc3QgMTogQ291bnQgYsOhc2ljb1xuICB0cnkge1xuICAgIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgIFxuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ0NvdW50IGLDoXNpY28nLFxuICAgICAgc3VjY2VzczogIWVycm9yLFxuICAgICAgcmVzdWx0OiBgQ291bnQ6ICR7Y291bnR9YCxcbiAgICAgIGVycm9yOiBlcnJvcj8ubWVzc2FnZVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ0NvdW50IGLDoXNpY28nLFxuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICByZXN1bHQ6ICdFeGNlcGNpw7NuJyxcbiAgICAgIGVycm9yOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJ1xuICAgIH0pXG4gIH1cbiAgXG4gIC8vIFRlc3QgMjogU2VsZWN0IHNpbXBsZSBjb24gbMOtbWl0ZVxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5saW1pdCgxKVxuICAgIFxuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1NlbGVjdCBzaW1wbGUgKGxpbWl0IDEpJyxcbiAgICAgIHN1Y2Nlc3M6ICFlcnJvcixcbiAgICAgIHJlc3VsdDogYFJlZ2lzdHJvczogJHtkYXRhPy5sZW5ndGggfHwgMH1gLFxuICAgICAgZXJyb3I6IGVycm9yPy5tZXNzYWdlXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnU2VsZWN0IHNpbXBsZSAobGltaXQgMSknLFxuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICByZXN1bHQ6ICdFeGNlcGNpw7NuJyxcbiAgICAgIGVycm9yOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJ1xuICAgIH0pXG4gIH1cbiAgXG4gIC8vIFRlc3QgMzogU2VsZWN0IGVzcGVjw61maWNvXG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnaWQsIGNhbGxfaWQnKVxuICAgICAgLmxpbWl0KDMpXG4gICAgXG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnU2VsZWN0IGVzcGVjw61maWNvIChpZCwgY2FsbF9pZCknLFxuICAgICAgc3VjY2VzczogIWVycm9yLFxuICAgICAgcmVzdWx0OiBgUmVnaXN0cm9zOiAke2RhdGE/Lmxlbmd0aCB8fCAwfWAsXG4gICAgICBlcnJvcjogZXJyb3I/Lm1lc3NhZ2UsXG4gICAgICBzYW1wbGVEYXRhOiBkYXRhXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnU2VsZWN0IGVzcGVjw61maWNvIChpZCwgY2FsbF9pZCknLFxuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICByZXN1bHQ6ICdFeGNlcGNpw7NuJyxcbiAgICAgIGVycm9yOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJ1xuICAgIH0pXG4gIH1cbiAgXG4gIC8vIFRlc3QgNDogVmVyaWZpY2FyIHNpIFJMUyBlc3TDoSBjYXVzYW5kbyBlbCBwcm9ibGVtYVxuICB0cnkge1xuICAgIC8vIEludGVudGFtb3MgaGFjZXIgdW4gcXVlcnkgY29uIGJ5cGFzcyBkZSBSTFMgc2kgZXMgcG9zaWJsZVxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAucnBjKCdnZXRfcGNhX2NvdW50JykgIC8vIEVzdGEgZnVuY2nDs24gbm8gZXhpc3RlLCBwZXJvIGVsIGVycm9yIG5vcyBkYXLDoSBpbmZvcm1hY2nDs25cbiAgICBcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdUZXN0IFJQQyAocGFyYSB2ZXJpZmljYXIgUkxTKScsXG4gICAgICBzdWNjZXNzOiAhZXJyb3IsXG4gICAgICByZXN1bHQ6ICdSUEMgY2FsbCcsXG4gICAgICBlcnJvcjogZXJyb3I/Lm1lc3NhZ2VcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdUZXN0IFJQQyAocGFyYSB2ZXJpZmljYXIgUkxTKScsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIHJlc3VsdDogJ1JQQyBubyBkaXNwb25pYmxlJyxcbiAgICAgIGVycm9yOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJ1xuICAgIH0pXG4gIH1cblxuICBjb25zb2xlLmxvZygn8J+TiiBSZXN1bHRhZG9zIGRlbCBkaWFnbsOzc3RpY286JywgdGVzdHMpXG4gIHJldHVybiB0ZXN0c1xufVxuXG4vLyBGdW5jacOzbiBwYXJhIGNyZWFyIHVuYSBwb2zDrXRpY2EgdGVtcG9yYWwgZGUgUkxTXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUENBUG9saWN5KCkge1xuICBjb25zb2xlLmxvZygn8J+UpyBJbnRlbnRhbmRvIGNyZWFyIHBvbMOtdGljYSBkZSBhY2Nlc28gcGFyYSBQQ0EuLi4nKVxuICBcbiAgdHJ5IHtcbiAgICAvLyBJbnRlbnRhbW9zIGVqZWN1dGFyIHVuIGNvbWFuZG8gU1FMIHBhcmEgY3JlYXIgdW5hIHBvbMOtdGljYVxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAucnBjKCdjcmVhdGVfcGNhX3BvbGljeScpXG4gICAgXG4gICAgcmV0dXJuIHsgc3VjY2VzczogIWVycm9yLCBlcnJvcjogZXJyb3I/Lm1lc3NhZ2UgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4geyBcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgIGVycm9yOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJ1xuICAgIH1cbiAgfVxufVxuXG4vLyDwn5OeIEZVTkNJT05FUyBQQVJBIEhJU1RPUklBTCBERSBMTEFNQURBUyBQT1IgVEVMw4lGT05PXG5cbi8vIEludGVyZmF6IHBhcmEgdW4gTGVhZCAobsO6bWVybyBkZSB0ZWzDqWZvbm8gY29uIGluZm9ybWFjacOzbiBkZWwgY2xpZW50ZSlcbmV4cG9ydCBpbnRlcmZhY2UgTGVhZCB7XG4gIHBob25lX251bWJlcjogc3RyaW5nXG4gIGJ1c2luZXNzX25hbWU/OiBzdHJpbmdcbiAgb3duZXJfbmFtZT86IHN0cmluZ1xuICBvd25lcl9lbWFpbD86IHN0cmluZ1xuICBsb2NhdGlvbl90eXBlPzogc3RyaW5nXG4gIGFkZHJlc3Nfc3RyZWV0Pzogc3RyaW5nXG4gIGFkZHJlc3NfY2l0eT86IHN0cmluZ1xuICBhZGRyZXNzX3N0YXRlPzogc3RyaW5nXG4gIGFkZHJlc3NfemlwPzogc3RyaW5nXG4gIHRvdGFsX2NhbGxzOiBudW1iZXJcbiAgbGFzdF9jYWxsX2RhdGU6IHN0cmluZ1xuICBsYXN0X2Rpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIGFncmVlZF9hbW91bnQ/OiBudW1iZXJcbn1cblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIHRvZG9zIGxvcyBsZWFkcyAobsO6bWVyb3Mgw7puaWNvcyBjb24gc3UgaW5mb3JtYWNpw7NuIG3DoXMgcmVjaWVudGUpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGVhZHMoKTogUHJvbWlzZTxMZWFkW10+IHtcbiAgY29uc29sZS5sb2coJ/Cfk54gT2J0ZW5pZW5kbyB0b2RvcyBsb3MgbGVhZHMuLi4nKVxuICBcbiAgLy8gUHJpbWVybyBvYnRlbmVtb3MgdG9kYXMgbGFzIGNhbGxzXG4gIGNvbnN0IHsgZGF0YTogY2FsbHNEYXRhLCBlcnJvcjogY2FsbHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnY2FsbHMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5ub3QoJ3RvX251bWJlcicsICdpcycsIG51bGwpXG4gICAgLm9yZGVyKCdjYWxsX2lkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gIFxuICBpZiAoY2FsbHNFcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBvYnRlbmllbmRvIGNhbGxzOicsIGNhbGxzRXJyb3IpXG4gICAgdGhyb3cgY2FsbHNFcnJvclxuICB9XG4gIFxuICBpZiAoIWNhbGxzRGF0YSkgcmV0dXJuIFtdXG4gIFxuICAvLyBPYnRlbmVyIHRvZGFzIGxhcyBkaXNwb3NpdGlvbnMgZGVsIFBDQSBwYXJhIGxvcyBjYWxsX2lkc1xuICBjb25zdCBjYWxsSWRzID0gY2FsbHNEYXRhLm1hcChjYWxsID0+IGNhbGwuY2FsbF9pZClcbiAgY29uc3QgeyBkYXRhOiBwY2FEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdwY2EnKVxuICAgIC5zZWxlY3QoJ2NhbGxfaWQsIGRpc3Bvc2l0aW9uJylcbiAgICAuaW4oJ2NhbGxfaWQnLCBjYWxsSWRzKVxuICBcbiAgLy8gQ3JlYXIgdW4gbWFwYSBwYXJhIGFjY2VzbyByw6FwaWRvIGEgbGFzIGRpc3Bvc2l0aW9ucyBkZWwgUENBXG4gIGNvbnN0IHBjYU1hcCA9IG5ldyBNYXAoKVxuICBpZiAocGNhRGF0YSkge1xuICAgIHBjYURhdGEuZm9yRWFjaChwY2EgPT4ge1xuICAgICAgcGNhTWFwLnNldChwY2EuY2FsbF9pZCwgcGNhLmRpc3Bvc2l0aW9uKVxuICAgIH0pXG4gIH1cbiAgXG4gIGNvbnN0IGRhdGEgPSBjYWxsc0RhdGFcbiAgXG4gIC8vIEFncnVwYW1vcyBwb3IgdG9fbnVtYmVyIHkgdG9tYW1vcyBsYSBpbmZvcm1hY2nDs24gbcOhcyByZWNpZW50ZVxuICBjb25zdCBsZWFkc01hcCA9IG5ldyBNYXA8c3RyaW5nLCBMZWFkPigpXG4gIFxuICBmb3IgKGNvbnN0IGNhbGwgb2YgZGF0YSkge1xuICAgIGlmICghY2FsbC50b19udW1iZXIpIGNvbnRpbnVlXG4gICAgXG4gICAgY29uc3QgZXhpc3RpbmdMZWFkID0gbGVhZHNNYXAuZ2V0KGNhbGwudG9fbnVtYmVyKVxuICAgIFxuICAgIGlmICghZXhpc3RpbmdMZWFkKSB7XG4gICAgICAvLyBQcmltZXJhIHZleiBxdWUgdmVtb3MgZXN0ZSBuw7ptZXJvXG4gICAgICBsZWFkc01hcC5zZXQoY2FsbC50b19udW1iZXIsIHtcbiAgICAgICAgcGhvbmVfbnVtYmVyOiBjYWxsLnRvX251bWJlcixcbiAgICAgICAgYnVzaW5lc3NfbmFtZTogY2FsbC5idXNpbmVzc19uYW1lLFxuICAgICAgICBvd25lcl9uYW1lOiBjYWxsLm93bmVyX25hbWUsXG4gICAgICAgIG93bmVyX2VtYWlsOiBjYWxsLm93bmVyX2VtYWlsLFxuICAgICAgICBsb2NhdGlvbl90eXBlOiBjYWxsLmxvY2F0aW9uX3R5cGUsXG4gICAgICAgIGFkZHJlc3Nfc3RyZWV0OiBjYWxsLmFkZHJlc3Nfc3RyZWV0LFxuICAgICAgICBhZGRyZXNzX2NpdHk6IGNhbGwuYWRkcmVzc19jaXR5LFxuICAgICAgICBhZGRyZXNzX3N0YXRlOiBjYWxsLmFkZHJlc3Nfc3RhdGUsXG4gICAgICAgIGFkZHJlc3NfemlwOiBjYWxsLmFkZHJlc3NfemlwLFxuICAgICAgICB0b3RhbF9jYWxsczogMSxcbiAgICAgICAgbGFzdF9jYWxsX2RhdGU6IGNhbGwuY2FsbF9pZCwgLy8gVXNhbmRvIGNhbGxfaWQgY29tbyBwcm94eSBkZSBmZWNoYVxuICAgICAgICBsYXN0X2Rpc3Bvc2l0aW9uOiBwY2FNYXAuZ2V0KGNhbGwuY2FsbF9pZCkgfHwgY2FsbC5kaXNwb3NpdGlvbixcbiAgICAgICAgYWdyZWVkX2Ftb3VudDogY2FsbC5hZ3JlZWRfYW1vdW50XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBY3R1YWxpemFtb3MgZWwgY29udGVvXG4gICAgICBleGlzdGluZ0xlYWQudG90YWxfY2FsbHMrK1xuICAgICAgXG4gICAgICAvLyBTaSBlc3RhIGxsYW1hZGEgZXMgbcOhcyByZWNpZW50ZSAoY2FsbF9pZCBtYXlvciksIGFjdHVhbGl6YW1vcyBsYSBpbmZvXG4gICAgICBpZiAoY2FsbC5jYWxsX2lkID4gZXhpc3RpbmdMZWFkLmxhc3RfY2FsbF9kYXRlKSB7XG4gICAgICAgIGV4aXN0aW5nTGVhZC5idXNpbmVzc19uYW1lID0gY2FsbC5idXNpbmVzc19uYW1lIHx8IGV4aXN0aW5nTGVhZC5idXNpbmVzc19uYW1lXG4gICAgICAgIGV4aXN0aW5nTGVhZC5vd25lcl9uYW1lID0gY2FsbC5vd25lcl9uYW1lIHx8IGV4aXN0aW5nTGVhZC5vd25lcl9uYW1lXG4gICAgICAgIGV4aXN0aW5nTGVhZC5vd25lcl9lbWFpbCA9IGNhbGwub3duZXJfZW1haWwgfHwgZXhpc3RpbmdMZWFkLm93bmVyX2VtYWlsXG4gICAgICAgIGV4aXN0aW5nTGVhZC5sb2NhdGlvbl90eXBlID0gY2FsbC5sb2NhdGlvbl90eXBlIHx8IGV4aXN0aW5nTGVhZC5sb2NhdGlvbl90eXBlXG4gICAgICAgIGV4aXN0aW5nTGVhZC5hZGRyZXNzX3N0cmVldCA9IGNhbGwuYWRkcmVzc19zdHJlZXQgfHwgZXhpc3RpbmdMZWFkLmFkZHJlc3Nfc3RyZWV0XG4gICAgICAgIGV4aXN0aW5nTGVhZC5hZGRyZXNzX2NpdHkgPSBjYWxsLmFkZHJlc3NfY2l0eSB8fCBleGlzdGluZ0xlYWQuYWRkcmVzc19jaXR5XG4gICAgICAgIGV4aXN0aW5nTGVhZC5hZGRyZXNzX3N0YXRlID0gY2FsbC5hZGRyZXNzX3N0YXRlIHx8IGV4aXN0aW5nTGVhZC5hZGRyZXNzX3N0YXRlXG4gICAgICAgIGV4aXN0aW5nTGVhZC5hZGRyZXNzX3ppcCA9IGNhbGwuYWRkcmVzc196aXAgfHwgZXhpc3RpbmdMZWFkLmFkZHJlc3NfemlwXG4gICAgICAgIGV4aXN0aW5nTGVhZC5sYXN0X2NhbGxfZGF0ZSA9IGNhbGwuY2FsbF9pZFxuICAgICAgICBleGlzdGluZ0xlYWQubGFzdF9kaXNwb3NpdGlvbiA9IHBjYU1hcC5nZXQoY2FsbC5jYWxsX2lkKSB8fCBjYWxsLmRpc3Bvc2l0aW9uXG4gICAgICAgIGV4aXN0aW5nTGVhZC5hZ3JlZWRfYW1vdW50ID0gY2FsbC5hZ3JlZWRfYW1vdW50IHx8IGV4aXN0aW5nTGVhZC5hZ3JlZWRfYW1vdW50XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBjb25zdCBsZWFkcyA9IEFycmF5LmZyb20obGVhZHNNYXAudmFsdWVzKCkpXG4gIGNvbnNvbGUubG9nKGDinIUgRW5jb250cmFkb3MgJHtsZWFkcy5sZW5ndGh9IGxlYWRzIMO6bmljb3NgKVxuICByZXR1cm4gbGVhZHNcbn1cblxuLy8gSW50ZXJmYXogcGFyYSBpbnRlcmFjY2lvbmVzIGNvbWJpbmFkYXMgKGNhbGxzICsgY2FsbGJhY2tzKVxuZXhwb3J0IGludGVyZmFjZSBDYWxsSW50ZXJhY3Rpb24ge1xuICB0eXBlOiAnY2FsbCcgfCAnY2FsbGJhY2snXG4gIGNhbGxfaWQ/OiBzdHJpbmdcbiAgaWQ/OiBzdHJpbmdcbiAgZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgYnVzaW5lc3NfbmFtZT86IHN0cmluZ1xuICBvd25lcl9uYW1lPzogc3RyaW5nXG4gIGFncmVlZF9hbW91bnQ/OiBudW1iZXJcbiAgYWRkcmVzc19zdHJlZXQ/OiBzdHJpbmdcbiAgYWRkcmVzc19jaXR5Pzogc3RyaW5nXG4gIGFkZHJlc3Nfc3RhdGU/OiBzdHJpbmdcbiAgY2FsbGJhY2tfdGltZT86IHN0cmluZ1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nXG4gIGRhdGU6IHN0cmluZ1xuICBkaXNwbGF5X2RhdGU6IHN0cmluZ1xufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgaGlzdG9yaWFsIGNvbXBsZXRvIChjYWxscyArIGNhbGxiYWNrcykgcG9yIG7Dum1lcm8gZGUgdGVsw6lmb25vXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbEhpc3RvcnlCeVBob25lKHBob25lTnVtYmVyOiBzdHJpbmcpOiBQcm9taXNlPENhbGxJbnRlcmFjdGlvbltdPiB7XG4gIGNvbnNvbGUubG9nKGDwn5OeIE9idGVuaWVuZG8gaGlzdG9yaWFsIGNvbXBsZXRvIHBhcmE6ICR7cGhvbmVOdW1iZXJ9YClcbiAgXG4gIHRyeSB7XG4gICAgLy8gT2J0ZW5lciBsbGFtYWRhcyByZWd1bGFyZXNcbiAgICBjb25zdCB7IGRhdGE6IGNhbGxzLCBlcnJvcjogY2FsbHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYWxscycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndG9fbnVtYmVyJywgcGhvbmVOdW1iZXIpXG4gICAgICAub3JkZXIoJ2NhbGxfaWQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICBcbiAgICBpZiAoY2FsbHNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG9idGVuaWVuZG8gbGxhbWFkYXM6JywgY2FsbHNFcnJvcilcbiAgICAgIHRocm93IGNhbGxzRXJyb3JcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk54gRW5jb250cmFkYXMgJHtjYWxscz8ubGVuZ3RoIHx8IDB9IGxsYW1hZGFzIHBhcmEgJHtwaG9uZU51bWJlcn1gKVxuICAgIFxuICAgIC8vIE9idGVuZXIgY2FsbGJhY2tzIHBhcmEgZXNlIG7Dum1lcm9cbiAgICBjb25zdCB7IGRhdGE6IGNhbGxiYWNrcywgZXJyb3I6IGNhbGxiYWNrc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndG9fbnVtYmVyJywgcGhvbmVOdW1iZXIpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+UhCBFbmNvbnRyYWRvcyAke2NhbGxiYWNrcz8ubGVuZ3RoIHx8IDB9IGNhbGxiYWNrcyBwYXJhICR7cGhvbmVOdW1iZXJ9YClcbiAgICBcbiAgICBpZiAoY2FsbGJhY2tzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBvYnRlbmllbmRvIGNhbGxiYWNrczonLCBjYWxsYmFja3NFcnJvcilcbiAgICAgIC8vIE5vIGxhbnphbW9zIGVycm9yLCBzb2xvIGxvZ3VlYW1vc1xuICAgIH1cbiAgICBcbiAgICAvLyBPYnRlbmVyIGRpc3Bvc2l0aW9ucyBkZWwgUENBIHBhcmEgbGFzIGNhbGxzXG4gICAgbGV0IHBjYU1hcCA9IG5ldyBNYXAoKVxuICAgIGxldCBjYWxsYmFja01hcCA9IG5ldyBNYXAoKVxuICAgIFxuICAgIGlmIChjYWxscyAmJiBjYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjYWxsSWRzID0gY2FsbHMubWFwKGNhbGwgPT4gY2FsbC5jYWxsX2lkKVxuICAgICAgXG4gICAgICAvLyBPYnRlbmVyIGRpc3Bvc2l0aW9ucyBkZWwgUENBXG4gICAgICBjb25zdCB7IGRhdGE6IHBjYURhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgICAuc2VsZWN0KCdjYWxsX2lkLCBkaXNwb3NpdGlvbicpXG4gICAgICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG4gICAgICBcbiAgICAgIGlmIChwY2FEYXRhKSB7XG4gICAgICAgIHBjYURhdGEuZm9yRWFjaChwY2EgPT4ge1xuICAgICAgICAgIHBjYU1hcC5zZXQocGNhLmNhbGxfaWQsIHBjYS5kaXNwb3NpdGlvbilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT2J0ZW5lciBjYWxsYmFja3MgYXNvY2lhZG9zIGEgZXN0YXMgY2FsbHNcbiAgICAgIGNvbnN0IHsgZGF0YTogYXNzb2NpYXRlZENhbGxiYWNrcyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuaW4oJ2NhbGxfaWQnLCBjYWxsSWRzKVxuICAgICAgXG4gICAgICBpZiAoYXNzb2NpYXRlZENhbGxiYWNrcykge1xuICAgICAgICBhc3NvY2lhdGVkQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsX2lkKSB7XG4gICAgICAgICAgICBjYWxsYmFja01hcC5zZXQoY2FsbGJhY2suY2FsbF9pZCwgY2FsbGJhY2spXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gQ2FsbGJhY2sgJHtjYWxsYmFjay5pZH0gbm8gdGllbmUgY2FsbF9pZGApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+UlyBDYWxscyBjb24gY2FsbGJhY2tzIGFzb2NpYWRvczogJHtBcnJheS5mcm9tKGNhbGxiYWNrTWFwLmtleXMoKSkuam9pbignLCAnKX1gKVxuICAgICAgY29uc29sZS5sb2coYPCfk4sgVG9kb3MgbG9zIGNhbGxfaWRzIGRlIGNhbGxzOiAkeyhjYWxscyB8fCBbXSkubWFwKGMgPT4gYy5jYWxsX2lkKS5qb2luKCcsICcpfWApXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBUb2RvcyBsb3MgY2FsbF9pZHMgZGUgY2FsbGJhY2tzOiAkeyhjYWxsYmFja3MgfHwgW10pLm1hcChjID0+IGMuY2FsbF9pZCkuam9pbignLCAnKX1gKVxuICAgIH1cbiAgICBcbiAgICAvLyBDb21iaW5hciB5IG1hcmNhciBlbCB0aXBvIC0gU0lOIERVUExJQ0FSXG4gICAgY29uc3QgYWxsSW50ZXJhY3Rpb25zOiBDYWxsSW50ZXJhY3Rpb25bXSA9IFtcbiAgICAgIC8vIFByb2Nlc2FyIHNvbG8gbGFzIGNhbGxzIHF1ZSBOTyB0aWVuZW4gY2FsbGJhY2sgYXNvY2lhZG8gKG1vc3RyYXJsYXMgY29tbyBjYWxscyBub3JtYWxlcylcbiAgICAgIC4uLihjYWxscyB8fCBbXSkuZmlsdGVyKGNhbGwgPT4ge1xuICAgICAgICBjb25zdCBoYXNDYWxsYmFjayA9IGNhbGxiYWNrTWFwLmhhcyhjYWxsLmNhbGxfaWQpXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OeIENhbGwgJHtjYWxsLmNhbGxfaWR9OiBkaXNwb3NpdGlvbj1cIiR7Y2FsbC5kaXNwb3NpdGlvbn1cIiwgaGFzQ2FsbGJhY2s9JHtoYXNDYWxsYmFja31gKVxuICAgICAgICByZXR1cm4gIWhhc0NhbGxiYWNrXG4gICAgICB9KS5tYXAoY2FsbCA9PiB7XG4gICAgICAgIGNvbnN0IHBjYURpc3Bvc2l0aW9uID0gcGNhTWFwLmdldChjYWxsLmNhbGxfaWQpIHx8IGNhbGwuZGlzcG9zaXRpb25cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAuLi5jYWxsLFxuICAgICAgICAgIHR5cGU6ICdjYWxsJyBhcyBjb25zdCxcbiAgICAgICAgICBkYXRlOiBjYWxsLmNhbGxfaWQsXG4gICAgICAgICAgZGlzcGxheV9kYXRlOiBjYWxsLmNhbGxfaWQsXG4gICAgICAgICAgZGlzcG9zaXRpb246IHBjYURpc3Bvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OeIENhbGwgJHtjYWxsLmNhbGxfaWR9OiBkaXNwb3NpdGlvbj1cIiR7cGNhRGlzcG9zaXRpb259XCJgKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFByb2Nlc2FyIFRPRE9TIGxvcyBjYWxsYmFja3MgKGluY2x1eWUgbG9zIHF1ZSB0aWVuZW4gY2FsbCBhc29jaWFkYSB5IGxvcyBpbmRlcGVuZGllbnRlcylcbiAgICAgIC4uLihjYWxsYmFja3MgfHwgW10pLm1hcChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0ZWRDYWxsID0gY2FsbHM/LmZpbmQoY2FsbCA9PiBjYWxsLmNhbGxfaWQgPT09IGNhbGxiYWNrLmNhbGxfaWQpXG4gICAgICAgIGNvbnN0IHBjYURpc3Bvc2l0aW9uID0gYXNzb2NpYXRlZENhbGwgPyAocGNhTWFwLmdldChjYWxsYmFjay5jYWxsX2lkKSB8fCBhc3NvY2lhdGVkQ2FsbC5kaXNwb3NpdGlvbikgOiBjYWxsYmFjay5kaXNwb3NpdGlvblxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIC4uLmNhbGxiYWNrLFxuICAgICAgICAgIHR5cGU6ICdjYWxsYmFjaycgYXMgY29uc3QsXG4gICAgICAgICAgZGF0ZTogY2FsbGJhY2suY3JlYXRlZF9hdCB8fCBjYWxsYmFjay5pZCxcbiAgICAgICAgICBkaXNwbGF5X2RhdGU6IGNhbGxiYWNrLmNhbGxiYWNrX3RpbWUgfHwgY2FsbGJhY2suY3JlYXRlZF9hdCB8fCBjYWxsYmFjay5pZCxcbiAgICAgICAgICAvLyBTaSB0aWVuZSBjYWxsIGFzb2NpYWRhLCB1c2FyIGFsZ3Vub3MgZGF0b3MgZGUgbGEgY2FsbCAoY29tbyBhZGRyZXNzLCBidXNpbmVzc19uYW1lIG9yaWdpbmFsKVxuICAgICAgICAgIC4uLihhc3NvY2lhdGVkQ2FsbCA/IHtcbiAgICAgICAgICAgIGJ1c2luZXNzX25hbWU6IGFzc29jaWF0ZWRDYWxsLmJ1c2luZXNzX25hbWUsXG4gICAgICAgICAgICBvd25lcl9uYW1lOiBjYWxsYmFjay5jYWxsYmFja19vd25lcl9uYW1lIHx8IGFzc29jaWF0ZWRDYWxsLm93bmVyX25hbWUsXG4gICAgICAgICAgICBhZGRyZXNzX3N0cmVldDogYXNzb2NpYXRlZENhbGwuYWRkcmVzc19zdHJlZXQsXG4gICAgICAgICAgICBhZGRyZXNzX2NpdHk6IGFzc29jaWF0ZWRDYWxsLmFkZHJlc3NfY2l0eSxcbiAgICAgICAgICAgIGFkZHJlc3Nfc3RhdGU6IGFzc29jaWF0ZWRDYWxsLmFkZHJlc3Nfc3RhdGUsXG4gICAgICAgICAgICBvd25lcl9waG9uZTogYXNzb2NpYXRlZENhbGwub3duZXJfcGhvbmUsXG4gICAgICAgICAgICBhZ3JlZWRfYW1vdW50OiBhc3NvY2lhdGVkQ2FsbC5hZ3JlZWRfYW1vdW50LFxuICAgICAgICAgICAgZGlzcG9zaXRpb246IHBjYURpc3Bvc2l0aW9uXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGJ1c2luZXNzX25hbWU6IGNhbGxiYWNrLmJ1c2luZXNzX25hbWUsXG4gICAgICAgICAgICBvd25lcl9uYW1lOiBjYWxsYmFjay5jYWxsYmFja19vd25lcl9uYW1lLFxuICAgICAgICAgICAgYWdyZWVkX2Ftb3VudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGlzcG9zaXRpb246IGNhbGxiYWNrLmRpc3Bvc2l0aW9uXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gSW5mb3JtYWNpw7NuIGVzcGVjw61maWNhIGRlbCBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrX3RpbWU6IGNhbGxiYWNrLmNhbGxiYWNrX3RpbWUsXG4gICAgICAgICAgY2FsbGJhY2tfb3duZXJfbmFtZTogY2FsbGJhY2suY2FsbGJhY2tfb3duZXJfbmFtZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBDYWxsYmFjayAke2NhbGxiYWNrLmlkIHx8IGNhbGxiYWNrLmNhbGxfaWR9OiAke2Fzc29jaWF0ZWRDYWxsID8gJ2NvbiBjYWxsIGFzb2NpYWRhJyA6ICdpbmRlcGVuZGllbnRlJ30sIG93bmVyPVwiJHtjYWxsYmFjay5jYWxsYmFja19vd25lcl9uYW1lfVwiYClcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0pXG4gICAgXVxuICAgIFxuICAgIC8vIE9yZGVuYXIgcG9yIGZlY2hhIChtw6FzIHJlY2llbnRlcyBwcmltZXJvKVxuICAgIGFsbEludGVyYWN0aW9ucy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5kYXRlID4gYi5kYXRlKSByZXR1cm4gLTFcbiAgICAgIGlmIChhLmRhdGUgPCBiLmRhdGUpIHJldHVybiAxXG4gICAgICByZXR1cm4gMFxuICAgIH0pXG4gICAgXG4gICAgY29uc29sZS5sb2coYOKchSBQcm9jZXNhZGFzICR7Y2FsbHM/Lmxlbmd0aCB8fCAwfSBsbGFtYWRhcyAoJHsoY2FsbHMgfHwgW10pLmZpbHRlcihjYWxsID0+ICFjYWxsYmFja01hcC5oYXMoY2FsbC5jYWxsX2lkKSkubGVuZ3RofSBjYWxscyArICR7Y2FsbGJhY2tzPy5sZW5ndGggfHwgMH0gY2FsbGJhY2tzKSBwYXJhICR7cGhvbmVOdW1iZXJ9YClcbiAgICByZXR1cm4gYWxsSW50ZXJhY3Rpb25zXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG9idGVuaWVuZG8gaGlzdG9yaWFsIGNvbXBsZXRvOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRnVuY2nDs24gcGFyYSBjb250YXIgY3XDoW50YXMgbGxhbWFkYXMgdGllbmUgdW4gbsO6bWVyb1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxDb3VudEJ5UGhvbmUocGhvbmVOdW1iZXI6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdjYWxscycpXG4gICAgLnNlbGVjdCgnY2FsbF9pZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAuZXEoJ3RvX251bWJlcicsIHBob25lTnVtYmVyKVxuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNvbnRhbmRvIGxsYW1hZGFzOicsIGVycm9yKVxuICAgIHJldHVybiAwXG4gIH1cbiAgXG4gIHJldHVybiBjb3VudCB8fCAwXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgdmVyaWZpY2FyIHNpIHVuYSBsbGFtYWRhIHRpZW5lIGhpc3RvcmlhbFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc0NhbGxIaXN0b3J5KGNhbGxJZDogc3RyaW5nKTogUHJvbWlzZTx7IGhhc0hpc3Rvcnk6IGJvb2xlYW47IGNvdW50OiBudW1iZXI7IHBob25lTnVtYmVyPzogc3RyaW5nIH0+IHtcbiAgLy8gUHJpbWVybyBvYnRlbmVtb3MgZWwgdG9fbnVtYmVyIGRlIGxhIGxsYW1hZGEgYWN0dWFsXG4gIGNvbnN0IHsgZGF0YTogY2FsbERhdGEsIGVycm9yOiBjYWxsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2NhbGxzJylcbiAgICAuc2VsZWN0KCd0b19udW1iZXInKVxuICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAuc2luZ2xlKClcbiAgXG4gIGlmIChjYWxsRXJyb3IgfHwgIWNhbGxEYXRhPy50b19udW1iZXIpIHtcbiAgICByZXR1cm4geyBoYXNIaXN0b3J5OiBmYWxzZSwgY291bnQ6IDAgfVxuICB9XG4gIFxuICBjb25zdCBwaG9uZU51bWJlciA9IGNhbGxEYXRhLnRvX251bWJlclxuICBjb25zdCBjb3VudCA9IGF3YWl0IGdldENhbGxDb3VudEJ5UGhvbmUocGhvbmVOdW1iZXIpXG4gIFxuICByZXR1cm4geyBcbiAgICBoYXNIaXN0b3J5OiBjb3VudCA+IDEsIFxuICAgIGNvdW50LFxuICAgIHBob25lTnVtYmVyIFxuICB9XG59Il0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2UiLCJnZXRDYWxscyIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsImdldENhbGxzV2l0aFBDQUluZm8iLCJjYWxscyIsImNhbGxzRXJyb3IiLCJjb25zb2xlIiwicGNhRGF0YSIsInBjYUVycm9yIiwiY2FsbHNXaXRoUENBIiwiU2V0IiwibWFwIiwicGNhIiwiY2FsbF9pZCIsImNhbGwiLCJoYXNQQ0EiLCJoYXMiLCJoYXNDYWxsYmFja3MiLCJnZXRDYWxsc1dpdGhQYWdpbmF0aW9uIiwicGFyYW1zIiwibG9nIiwicXVlcnkiLCJjb3VudCIsInNlYXJjaCIsIm9yIiwiZmlsdGVycyIsImRpc3Bvc2l0aW9uIiwiZXEiLCJzb3J0QnkiLCJzb3J0T3JkZXIiLCJvZmZzZXQiLCJwYWdlIiwibGltaXQiLCJyYW5nZSIsImxlbmd0aCIsInRvdGFsIiwidG90YWxQYWdlcyIsIk1hdGgiLCJjZWlsIiwiY2FsbElkcyIsImluIiwiY2FsbGJhY2tEYXRhIiwiY2FsbGJhY2tFcnJvciIsInBjYURpc3Bvc2l0aW9uTWFwIiwiTWFwIiwiY2FsbGJhY2tPd25lck5hbWVNYXAiLCJjYWxsYmFjayIsImNhbGxiYWNrX293bmVyX25hbWUiLCJjYWxsYmFja093bmVyUGhvbmVNYXAiLCJ0b19udW1iZXIiLCJjYWxsc1dpdGhJbmZvIiwiY2FsbGJhY2tPd25lck5hbWUiLCJnZXQiLCJjYWxsYmFja093bmVyUGhvbmUiLCJwY2FEaXNwb3NpdGlvbiIsIm93bmVyX25hbWUiLCJvd25lcl9waG9uZSIsImZpbHRlcmVkQ2FsbHMiLCJ1bmRlZmluZWQiLCJmaWx0ZXIiLCJnZXRDYWxsYmFja3NCeUNhbGxJZCIsImNhbGxJZCIsImdldFBDQUJ5Q2FsbElkIiwiZ2V0Q2FsbERldGFpbHNXaXRoUENBIiwiY2FsbERhdGEiLCJjYWxsRXJyb3IiLCJzaW5nbGUiLCJpc0NhbGxiYWNrIiwiZ2V0QWxsUENBIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImRhdGFMZW5ndGgiLCJtZXNzYWdlIiwiZGV0YWlscyIsImhpbnQiLCJjb2RlIiwic2ltcGxlRGF0YSIsInNpbXBsZUVycm9yIiwidGVzdFBDQUFjY2VzcyIsImhlYWQiLCJ0ZXN0QWxsVGFibGVzQWNjZXNzIiwidGFibGVzIiwicmVzdWx0cyIsInRhYmxlIiwiZXJyIiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJkaWFnbm9zZVBDQUFjY2VzcyIsInRlc3RzIiwicHVzaCIsInRlc3QiLCJzdWNjZXNzIiwicmVzdWx0Iiwic2FtcGxlRGF0YSIsInJwYyIsImNyZWF0ZVBDQVBvbGljeSIsImdldExlYWRzIiwiY2FsbHNEYXRhIiwibm90IiwicGNhTWFwIiwiZm9yRWFjaCIsInNldCIsImxlYWRzTWFwIiwiZXhpc3RpbmdMZWFkIiwicGhvbmVfbnVtYmVyIiwiYnVzaW5lc3NfbmFtZSIsIm93bmVyX2VtYWlsIiwibG9jYXRpb25fdHlwZSIsImFkZHJlc3Nfc3RyZWV0IiwiYWRkcmVzc19jaXR5IiwiYWRkcmVzc19zdGF0ZSIsImFkZHJlc3NfemlwIiwidG90YWxfY2FsbHMiLCJsYXN0X2NhbGxfZGF0ZSIsImxhc3RfZGlzcG9zaXRpb24iLCJhZ3JlZWRfYW1vdW50IiwibGVhZHMiLCJBcnJheSIsInZhbHVlcyIsImdldENhbGxIaXN0b3J5QnlQaG9uZSIsInBob25lTnVtYmVyIiwiY2FsbGJhY2tzIiwiY2FsbGJhY2tzRXJyb3IiLCJjYWxsYmFja01hcCIsImFzc29jaWF0ZWRDYWxsYmFja3MiLCJpZCIsImtleXMiLCJqb2luIiwiYyIsImFsbEludGVyYWN0aW9ucyIsImhhc0NhbGxiYWNrIiwidHlwZSIsImRhdGUiLCJkaXNwbGF5X2RhdGUiLCJhc3NvY2lhdGVkQ2FsbCIsImZpbmQiLCJjcmVhdGVkX2F0IiwiY2FsbGJhY2tfdGltZSIsInNvcnQiLCJhIiwiYiIsImdldENhbGxDb3VudEJ5UGhvbmUiLCJoYXNDYWxsSGlzdG9yeSIsImhhc0hpc3RvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});