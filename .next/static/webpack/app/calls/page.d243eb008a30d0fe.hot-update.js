"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/calls/page",{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPCAPolicy: function() { return /* binding */ createPCAPolicy; },\n/* harmony export */   diagnosePCAAccess: function() { return /* binding */ diagnosePCAAccess; },\n/* harmony export */   getAllPCA: function() { return /* binding */ getAllPCA; },\n/* harmony export */   getCallCountByPhone: function() { return /* binding */ getCallCountByPhone; },\n/* harmony export */   getCallDetailsWithPCA: function() { return /* binding */ getCallDetailsWithPCA; },\n/* harmony export */   getCallHistoryByPhone: function() { return /* binding */ getCallHistoryByPhone; },\n/* harmony export */   getCallbacksByCallId: function() { return /* binding */ getCallbacksByCallId; },\n/* harmony export */   getCalls: function() { return /* binding */ getCalls; },\n/* harmony export */   getCallsWithPCAInfo: function() { return /* binding */ getCallsWithPCAInfo; },\n/* harmony export */   getCallsWithPagination: function() { return /* binding */ getCallsWithPagination; },\n/* harmony export */   getLeads: function() { return /* binding */ getLeads; },\n/* harmony export */   getPCAByCallId: function() { return /* binding */ getPCAByCallId; },\n/* harmony export */   hasCallHistory: function() { return /* binding */ hasCallHistory; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   testAllTablesAccess: function() { return /* binding */ testAllTablesAccess; },\n/* harmony export */   testPCAAccess: function() { return /* binding */ testPCAAccess; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://rchgtacvdpavqkrceybo.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJjaGd0YWN2ZHBhdnFrcmNleWJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2OTUyODksImV4cCI6MjA3NjI3MTI4OX0.KZHdrA5sOrrDOUkMkG7H5b6Eb-yxPmrZQVXVBCuKVgg\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Función para obtener todas las llamadas\nasync function getCalls() {\n    const { data, error } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n        ascending: false\n    });\n    if (error) {\n        throw error;\n    }\n    return data;\n}\n// Función para obtener llamadas con información de si tienen PCA\nasync function getCallsWithPCAInfo() {\n    try {\n        // Primero obtenemos todas las llamadas\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"Error fetching calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls) return [];\n        // Luego obtenemos todos los call_ids que tienen PCA\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id\");\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        // No lanzamos error aquí, solo logueamos y continuamos sin PCA info\n        }\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        // Combinamos la información\n        return calls.map((call)=>({\n                ...call,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: false // Ya no usamos callbacks como concepto\n            }));\n    } catch (error) {\n        console.error(\"Error in getCallsWithPCAInfo:\", error);\n        throw error;\n    }\n}\n// Función NUEVA: Obtener llamadas con paginación en servidor (ESCALABLE)\nasync function getCallsWithPagination(params) {\n    try {\n        var _params_filters, _params_filters1;\n        console.log(\"\\uD83D\\uDD0D Obteniendo llamadas paginadas:\", params);\n        let query = supabase.from(\"calls\").select(\"*\", {\n            count: \"exact\"\n        });\n        // Aplicar filtros de búsqueda\n        if (params.search) {\n            query = query.or(\"business_name.ilike.%\".concat(params.search, \"%,owner_name.ilike.%\").concat(params.search, \"%,owner_phone.ilike.%\").concat(params.search, \"%\"));\n        }\n        // Aplicar filtros adicionales\n        if ((_params_filters = params.filters) === null || _params_filters === void 0 ? void 0 : _params_filters.disposition) {\n            query = query.eq(\"disposition\", params.filters.disposition);\n        }\n        // Aplicar ordenamiento\n        const sortBy = params.sortBy || \"call_id\";\n        const sortOrder = params.sortOrder === \"asc\" ? {\n            ascending: true\n        } : {\n            ascending: false\n        };\n        query = query.order(sortBy, sortOrder);\n        // Aplicar paginación\n        const offset = (params.page - 1) * params.limit;\n        query = query.range(offset, offset + params.limit - 1);\n        const { data: calls, count, error: callsError } = await query;\n        if (callsError) {\n            console.error(\"Error fetching paginated calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls || calls.length === 0) {\n            return {\n                data: [],\n                total: count || 0,\n                page: params.page,\n                limit: params.limit,\n                totalPages: Math.ceil((count || 0) / params.limit)\n            };\n        }\n        // Obtener información de PCA solo para las llamadas de esta página\n        const callIds = calls.map((call)=>call.call_id);\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id\").in(\"call_id\", callIds);\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        }\n        // Obtener callbacks asociados a estas calls\n        const { data: callbackData, error: callbackError } = await supabase.from(\"callbacks\").select(\"call_id, callback_owner_name\").in(\"call_id\", callIds);\n        if (callbackError) {\n            console.error(\"Error fetching callback data:\", callbackError);\n        }\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        const callbackOwnerMap = new Map((callbackData || []).map((callback)=>[\n                callback.call_id,\n                callback.callback_owner_name\n            ]));\n        // Combinar información\n        const callsWithInfo = calls.map((call)=>{\n            const callbackOwner = callbackOwnerMap.get(call.call_id);\n            return {\n                ...call,\n                // Si hay callback_owner_name, usarlo en lugar del owner_name original\n                owner_name: callbackOwner || call.owner_name,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: callbackOwnerMap.has(call.call_id)\n            };\n        });\n        // Aplicar filtros post-query si es necesario\n        let filteredCalls = callsWithInfo;\n        if (((_params_filters1 = params.filters) === null || _params_filters1 === void 0 ? void 0 : _params_filters1.hasPCA) !== undefined) {\n            filteredCalls = filteredCalls.filter((call)=>call.hasPCA === params.filters.hasPCA);\n        }\n        const totalPages = Math.ceil((count || 0) / params.limit);\n        console.log(\"✅ Devolviendo \".concat(filteredCalls.length, \" llamadas (p\\xe1gina \").concat(params.page, \"/\").concat(totalPages, \") de \").concat(count, \" total\"));\n        return {\n            data: filteredCalls,\n            total: count || 0,\n            page: params.page,\n            limit: params.limit,\n            totalPages\n        };\n    } catch (error) {\n        console.error(\"Error in getCallsWithPagination:\", error);\n        throw error;\n    }\n}\n// Función para obtener callbacks por call_id\nasync function getCallbacksByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).order(\"callback_date\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching callbacks:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getCallbacksByCallId:\", error);\n        throw error;\n    }\n}\n// Función para obtener análisis PCA por call_id\nasync function getPCAByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"*\").eq(\"call_id\", callId).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching PCA data:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getPCAByCallId:\", error);\n        throw error;\n    }\n}\n// Nueva función para obtener información completa del cliente y análisis (calls y callbacks)\nasync function getCallDetailsWithPCA(callId) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCallDetailsWithPCA - buscando callId:\", callId);\n        // Obtener la llamada (siempre existe)\n        const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"\\uD83D\\uDCDE Resultado b\\xfasqueda en calls:\", {\n            callData,\n            callError\n        });\n        if (callError || !callData) {\n            console.error(\"❌ No se encontr\\xf3 la call con ID:\", callId);\n            return {\n                call: null,\n                pca: [],\n                isCallback: false\n            };\n        }\n        // Verificar si esta call tiene un callback asociado\n        const { data: callbackData, error: callbackError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"� Verificando si tiene callback asociado:\", {\n            callbackData,\n            callbackError\n        });\n        // Obtener PCA\n        const pcaData = await getPCAByCallId(callId);\n        if (callbackData && !callbackError) {\n            // Es una call que TAMBIÉN es un callback\n            console.log(\"✅ Call con callback asociado encontrado\");\n            return {\n                call: callData,\n                pca: pcaData,\n                isCallback: true,\n                callback: callbackData\n            };\n        } else {\n            // Es una call normal (sin callback)\n            console.log(\"✅ Call normal (sin callback)\");\n            return {\n                call: callData,\n                pca: pcaData,\n                isCallback: false\n            };\n        }\n    } catch (error) {\n        console.error(\"❌ Error in getCallDetailsWithPCA:\", error);\n        throw error;\n    }\n}\n// Función de debug para ver todos los PCA disponibles\nasync function getAllPCA() {\n    console.log(\"Intentando obtener todos los PCA...\");\n    // Primero intentamos sin límites\n    const { data, error, status, statusText } = await supabase.from(\"pca\").select(\"id, call_id, agent_name, created_at\").order(\"created_at\", {\n        ascending: false\n    });\n    console.log(\"Respuesta PCA:\", {\n        data,\n        error,\n        status,\n        statusText,\n        dataLength: (data === null || data === void 0 ? void 0 : data.length) || 0\n    });\n    if (error) {\n        console.error(\"Error detallado al obtener PCA:\", {\n            message: error.message,\n            details: error.details,\n            hint: error.hint,\n            code: error.code\n        });\n        // Intentamos con un query más simple\n        console.log(\"Intentando query m\\xe1s simple...\");\n        const { data: simpleData, error: simpleError } = await supabase.from(\"pca\").select(\"*\").limit(1);\n        console.log(\"Query simple resultado:\", {\n            simpleData,\n            simpleError\n        });\n        throw error;\n    }\n    console.log(\"PCA obtenidos exitosamente:\", data);\n    return data;\n}\n// Función de debug simple para verificar acceso a PCA\nasync function testPCAAccess() {\n    console.log(\"Testeando acceso a tabla PCA...\");\n    const { data, error, count } = await supabase.from(\"pca\").select(\"*\", {\n        count: \"exact\",\n        head: true\n    });\n    console.log(\"Test PCA - Count:\", count, \"Error:\", error);\n    return {\n        count,\n        error\n    };\n}\n// Función para verificar todas las tablas disponibles\nasync function testAllTablesAccess() {\n    const tables = [\n        \"calls\",\n        \"pca\",\n        \"callbacks\"\n    ];\n    const results = {};\n    for (const table of tables){\n        try {\n            console.log(\"Testeando tabla: \".concat(table));\n            const { data, error, count } = await supabase.from(table).select(\"*\", {\n                count: \"exact\",\n                head: true\n            });\n            results[table] = {\n                count,\n                error: (error === null || error === void 0 ? void 0 : error.message) || null\n            };\n            console.log(\"\".concat(table, \": \").concat(count, \" registros, error:\"), error === null || error === void 0 ? void 0 : error.message);\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Error desconocido\";\n            results[table] = {\n                count: 0,\n                error: errorMessage\n            };\n            console.error(\"Error en tabla \".concat(table, \":\"), err);\n        }\n    }\n    return results;\n}\n// Función específica para diagnosticar el problema de PCA\nasync function diagnosePCAAccess() {\n    console.log(\"\\uD83D\\uDD0D Diagnosticando acceso a tabla PCA...\");\n    const tests = [];\n    // Test 1: Count básico\n    try {\n        const { count, error } = await supabase.from(\"pca\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: !error,\n            result: \"Count: \".concat(count),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 2: Select simple con límite\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id\").limit(1);\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 3: Select específico\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id, call_id\").limit(3);\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message,\n            sampleData: data\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 4: Verificar si RLS está causando el problema\n    try {\n        // Intentamos hacer un query con bypass de RLS si es posible\n        const { data, error } = await supabase.rpc(\"get_pca_count\") // Esta función no existe, pero el error nos dará información\n        ;\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: !error,\n            result: \"RPC call\",\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: false,\n            result: \"RPC no disponible\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    console.log(\"\\uD83D\\uDCCA Resultados del diagn\\xf3stico:\", tests);\n    return tests;\n}\n// Función para crear una política temporal de RLS\nasync function createPCAPolicy() {\n    console.log(\"\\uD83D\\uDD27 Intentando crear pol\\xedtica de acceso para PCA...\");\n    try {\n        // Intentamos ejecutar un comando SQL para crear una política\n        const { data, error } = await supabase.rpc(\"create_pca_policy\");\n        return {\n            success: !error,\n            error: error === null || error === void 0 ? void 0 : error.message\n        };\n    } catch (err) {\n        return {\n            success: false,\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        };\n    }\n}\n// Función para obtener todos los leads (números únicos con su información más reciente)\nasync function getLeads() {\n    console.log(\"\\uD83D\\uDCDE Obteniendo todos los leads...\");\n    // Primero obtenemos todas las calls\n    const { data: callsData, error: callsError } = await supabase.from(\"calls\").select(\"*\").not(\"to_number\", \"is\", null).order(\"call_id\", {\n        ascending: false\n    });\n    if (callsError) {\n        console.error(\"❌ Error obteniendo calls:\", callsError);\n        throw callsError;\n    }\n    if (!callsData) return [];\n    // Obtener todas las dispositions del PCA para los call_ids\n    const callIds = callsData.map((call)=>call.call_id);\n    const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n    // Crear un mapa para acceso rápido a las dispositions del PCA\n    const pcaMap = new Map();\n    if (pcaData) {\n        pcaData.forEach((pca)=>{\n            pcaMap.set(pca.call_id, pca.disposition);\n        });\n    }\n    const data = callsData;\n    // Agrupamos por to_number y tomamos la información más reciente\n    const leadsMap = new Map();\n    for (const call of data){\n        if (!call.to_number) continue;\n        const existingLead = leadsMap.get(call.to_number);\n        if (!existingLead) {\n            // Primera vez que vemos este número\n            leadsMap.set(call.to_number, {\n                phone_number: call.to_number,\n                business_name: call.business_name,\n                owner_name: call.owner_name,\n                owner_email: call.owner_email,\n                location_type: call.location_type,\n                address_street: call.address_street,\n                address_city: call.address_city,\n                address_state: call.address_state,\n                address_zip: call.address_zip,\n                total_calls: 1,\n                last_call_date: call.call_id,\n                last_disposition: pcaMap.get(call.call_id) || call.disposition,\n                agreed_amount: call.agreed_amount\n            });\n        } else {\n            // Actualizamos el conteo\n            existingLead.total_calls++;\n            // Si esta llamada es más reciente (call_id mayor), actualizamos la info\n            if (call.call_id > existingLead.last_call_date) {\n                existingLead.business_name = call.business_name || existingLead.business_name;\n                existingLead.owner_name = call.owner_name || existingLead.owner_name;\n                existingLead.owner_email = call.owner_email || existingLead.owner_email;\n                existingLead.location_type = call.location_type || existingLead.location_type;\n                existingLead.address_street = call.address_street || existingLead.address_street;\n                existingLead.address_city = call.address_city || existingLead.address_city;\n                existingLead.address_state = call.address_state || existingLead.address_state;\n                existingLead.address_zip = call.address_zip || existingLead.address_zip;\n                existingLead.last_call_date = call.call_id;\n                existingLead.last_disposition = pcaMap.get(call.call_id) || call.disposition;\n                existingLead.agreed_amount = call.agreed_amount || existingLead.agreed_amount;\n            }\n        }\n    }\n    const leads = Array.from(leadsMap.values());\n    console.log(\"✅ Encontrados \".concat(leads.length, \" leads \\xfanicos\"));\n    return leads;\n}\n// Función para obtener historial completo (calls + callbacks) por número de teléfono\nasync function getCallHistoryByPhone(phoneNumber) {\n    console.log(\"\\uD83D\\uDCDE Obteniendo historial completo para: \".concat(phoneNumber));\n    try {\n        // Obtener llamadas regulares\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"❌ Error obteniendo llamadas:\", callsError);\n            throw callsError;\n        }\n        console.log(\"\\uD83D\\uDCDE Encontradas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas para \").concat(phoneNumber));\n        // Obtener callbacks para ese número\n        const { data: callbacks, error: callbacksError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"\\uD83D\\uDD04 Encontrados \".concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks para \").concat(phoneNumber));\n        if (callbacksError) {\n            console.error(\"❌ Error obteniendo callbacks:\", callbacksError);\n        // No lanzamos error, solo logueamos\n        }\n        // Obtener dispositions del PCA para las calls\n        let pcaMap = new Map();\n        let callbackMap = new Map();\n        if (calls && calls.length > 0) {\n            const callIds = calls.map((call)=>call.call_id);\n            // Obtener dispositions del PCA\n            const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n            if (pcaData) {\n                pcaData.forEach((pca)=>{\n                    pcaMap.set(pca.call_id, pca.disposition);\n                });\n            }\n            // Obtener callbacks asociados a estas calls\n            const { data: associatedCallbacks } = await supabase.from(\"callbacks\").select(\"*\").in(\"call_id\", callIds);\n            if (associatedCallbacks) {\n                associatedCallbacks.forEach((callback)=>{\n                    if (callback.call_id) {\n                        callbackMap.set(callback.call_id, callback);\n                    } else {\n                        console.log(\"⚠️ Callback \".concat(callback.id, \" no tiene call_id\"));\n                    }\n                });\n            }\n            console.log(\"\\uD83D\\uDD17 Calls con callbacks asociados: \".concat(Array.from(callbackMap.keys()).join(\", \")));\n            console.log(\"\\uD83D\\uDCCB Todos los call_ids de calls: \".concat((calls || []).map((c)=>c.call_id).join(\", \")));\n            console.log(\"\\uD83D\\uDCCB Todos los call_ids de callbacks: \".concat((callbacks || []).map((c)=>c.call_id).join(\", \")));\n        }\n        // Combinar y marcar el tipo - SIN DUPLICAR\n        const allInteractions = [\n            // Procesar solo las calls que NO tienen callback asociado (mostrarlas como calls normales)\n            ...(calls || []).filter((call)=>{\n                const hasCallback = callbackMap.has(call.call_id);\n                console.log(\"\\uD83D\\uDCDE Call \".concat(call.call_id, ': disposition=\"').concat(call.disposition, '\", hasCallback=').concat(hasCallback));\n                return !hasCallback;\n            }).map((call)=>{\n                const pcaDisposition = pcaMap.get(call.call_id) || call.disposition;\n                const result = {\n                    ...call,\n                    type: \"call\",\n                    date: call.call_id,\n                    display_date: call.call_id,\n                    disposition: pcaDisposition\n                };\n                console.log(\"\\uD83D\\uDCDE Call \".concat(call.call_id, ': disposition=\"').concat(pcaDisposition, '\"'));\n                return result;\n            }),\n            // Procesar TODOS los callbacks (incluye los que tienen call asociada y los independientes)\n            ...(callbacks || []).map((callback)=>{\n                const associatedCall = calls === null || calls === void 0 ? void 0 : calls.find((call)=>call.call_id === callback.call_id);\n                const pcaDisposition = associatedCall ? pcaMap.get(callback.call_id) || associatedCall.disposition : callback.disposition;\n                const result = {\n                    ...callback,\n                    type: \"callback\",\n                    date: callback.created_at || callback.id,\n                    display_date: callback.callback_time || callback.created_at || callback.id,\n                    // Si tiene call asociada, usar algunos datos de la call (como address, business_name original)\n                    ...associatedCall ? {\n                        business_name: associatedCall.business_name,\n                        owner_name: callback.callback_owner_name || associatedCall.owner_name,\n                        address_street: associatedCall.address_street,\n                        address_city: associatedCall.address_city,\n                        address_state: associatedCall.address_state,\n                        owner_phone: associatedCall.owner_phone,\n                        agreed_amount: associatedCall.agreed_amount,\n                        disposition: pcaDisposition\n                    } : {\n                        business_name: callback.business_name,\n                        owner_name: callback.callback_owner_name,\n                        agreed_amount: undefined,\n                        disposition: callback.disposition\n                    },\n                    // Información específica del callback\n                    callback_time: callback.callback_time,\n                    callback_owner_name: callback.callback_owner_name\n                };\n                console.log(\"\\uD83D\\uDD04 Callback \".concat(callback.id || callback.call_id, \": \").concat(associatedCall ? \"con call asociada\" : \"independiente\", ', owner=\"').concat(callback.callback_owner_name, '\"'));\n                return result;\n            })\n        ];\n        // Ordenar por fecha (más recientes primero)\n        allInteractions.sort((a, b)=>{\n            if (a.date > b.date) return -1;\n            if (a.date < b.date) return 1;\n            return 0;\n        });\n        console.log(\"✅ Procesadas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas (\").concat((calls || []).filter((call)=>!callbackMap.has(call.call_id)).length, \" calls + \").concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks) para \").concat(phoneNumber));\n        return allInteractions;\n    } catch (error) {\n        console.error(\"❌ Error obteniendo historial completo:\", error);\n        throw error;\n    }\n}\n// Función para contar cuántas llamadas tiene un número\nasync function getCallCountByPhone(phoneNumber) {\n    const { count, error } = await supabase.from(\"calls\").select(\"call_id\", {\n        count: \"exact\",\n        head: true\n    }).eq(\"to_number\", phoneNumber);\n    if (error) {\n        console.error(\"❌ Error contando llamadas:\", error);\n        return 0;\n    }\n    return count || 0;\n}\n// Función para verificar si una llamada tiene historial\nasync function hasCallHistory(callId) {\n    // Primero obtenemos el to_number de la llamada actual\n    const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"to_number\").eq(\"call_id\", callId).single();\n    if (callError || !(callData === null || callData === void 0 ? void 0 : callData.to_number)) {\n        return {\n            hasHistory: false,\n            count: 0\n        };\n    }\n    const phoneNumber = callData.to_number;\n    const count = await getCallCountByPhone(phoneNumber);\n    return {\n        hasHistory: count > 1,\n        count,\n        phoneNumber\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDb0Q7QUFFcEQsTUFBTUMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBRTFELE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSSxpQkFBZ0I7QUE0RmxFLDBDQUEwQztBQUNuQyxlQUFlRztJQUNwQixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUgsU0FDM0JJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDLFdBQVc7UUFBRUMsV0FBVztJQUFNO0lBRXZDLElBQUlKLE9BQU87UUFDVCxNQUFNQTtJQUNSO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLGlFQUFpRTtBQUMxRCxlQUFlTTtJQUNwQixJQUFJO1FBQ0YsdUNBQXVDO1FBQ3ZDLE1BQU0sRUFBRU4sTUFBTU8sS0FBSyxFQUFFTixPQUFPTyxVQUFVLEVBQUUsR0FBRyxNQUFNVixTQUM5Q0ksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUMsV0FBVztZQUFFQyxXQUFXO1FBQU07UUFFdkMsSUFBSUcsWUFBWTtZQUNkQyxRQUFRUixLQUFLLENBQUMseUJBQXlCTztZQUN2QyxNQUFNQTtRQUNSO1FBRUEsSUFBSSxDQUFDRCxPQUFPLE9BQU8sRUFBRTtRQUVyQixvREFBb0Q7UUFDcEQsTUFBTSxFQUFFUCxNQUFNVSxPQUFPLEVBQUVULE9BQU9VLFFBQVEsRUFBRSxHQUFHLE1BQU1iLFNBQzlDSSxJQUFJLENBQUMsT0FDTEMsTUFBTSxDQUFDO1FBRVYsSUFBSVEsVUFBVTtZQUNaRixRQUFRUixLQUFLLENBQUMsNEJBQTRCVTtRQUMxQyxvRUFBb0U7UUFDdEU7UUFFQSxNQUFNQyxlQUFlLElBQUlDLElBQUlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksR0FBRyxDQUFD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QUV4QixLQUFLLEVBQUUsR0FBRyxNQUFNSCxTQUM1QkksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxXQUFXO1FBQUVzQixPQUFPO1FBQVNtRCxNQUFNO0lBQUssR0FDL0M5QyxFQUFFLENBQUMsYUFBYXdGO0lBRW5CLElBQUlySCxPQUFPO1FBQ1RRLFFBQVFSLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU87SUFDVDtJQUVBLE9BQU93QixTQUFTO0FBQ2xCO0FBRUEsd0RBQXdEO0FBQ2pELGVBQWVxSCxlQUFlcEYsTUFBYztJQUNqRCxzREFBc0Q7SUFDdEQsTUFBTSxFQUFFMUQsTUFBTTZELFFBQVEsRUFBRTVELE9BQU82RCxTQUFTLEVBQUUsR0FBRyxNQUFNaEUsU0FDaERJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsYUFDUDJCLEVBQUUsQ0FBQyxXQUFXNEIsUUFDZEssTUFBTTtJQUVULElBQUlELGFBQWEsRUFBQ0QscUJBQUFBLCtCQUFBQSxTQUFVdUMsU0FBUyxHQUFFO1FBQ3JDLE9BQU87WUFBRTJDLFlBQVk7WUFBT3RILE9BQU87UUFBRTtJQUN2QztJQUVBLE1BQU02RixjQUFjekQsU0FBU3VDLFNBQVM7SUFDdEMsTUFBTTNFLFFBQVEsTUFBTW9ILG9CQUFvQnZCO0lBRXhDLE9BQU87UUFDTHlCLFlBQVl0SCxRQUFRO1FBQ3BCQTtRQUNBNkY7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3VwYWJhc2UudHM/MDZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSFcblxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpXG5cbi8vIERlZmluaXIgZWwgdGlwbyBkZSBkYXRvcyBwYXJhIGxhIHRhYmxhIGNhbGxzXG5leHBvcnQgaW50ZXJmYWNlIENhbGwge1xuICBjYWxsX2lkOiBzdHJpbmdcbiAgYWdlbnRfaWQ/OiBzdHJpbmdcbiAgYWdlbnRfbmFtZT86IHN0cmluZ1xuICB0cmFuc2NyaXB0Pzogc3RyaW5nXG4gIGRpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIGJ1c2luZXNzX25hbWU/OiBzdHJpbmdcbiAgb3duZXJfbmFtZT86IHN0cmluZ1xuICBvd25lcl9waG9uZT86IHN0cmluZ1xuICBvd25lcl9lbWFpbD86IHN0cmluZ1xuICBsb2NhdGlvbl90eXBlPzogc3RyaW5nXG4gIGFkZHJlc3Nfc3RyZWV0Pzogc3RyaW5nXG4gIGFkZHJlc3NfY2l0eT86IHN0cmluZ1xuICBhZGRyZXNzX3N0YXRlPzogc3RyaW5nXG4gIGFkZHJlc3NfemlwPzogc3RyaW5nXG4gIGFncmVlZF9hbW91bnQ/OiBudW1iZXJcbiAgbW9udGhseV9hbW91bnQ/OiBudW1iZXJcbiAgeWVhcmx5X2Ftb3VudD86IG51bWJlclxuICBjb21wYW55X2tleT86IHN0cmluZ1xuICBhZ2VudF9leHRlcm5hbF9pZD86IHN0cmluZ1xuICBhZGRyZXNzX2xpbmUyPzogc3RyaW5nXG4gIGJ1c2luZXNzX2hvdXJzPzogc3RyaW5nXG4gIG90aGVyX2xvY2F0aW9ucz86IHN0cmluZ1xuICBmcm9tX251bWJlcj86IHN0cmluZ1xuICB0b19udW1iZXI/OiBzdHJpbmdcbn1cblxuLy8gVGlwbyBleHRlbmRpZG8gcGFyYSBsbGFtYWRhcyBjb24gaW5mb3JtYWNpw7NuIGRlIFBDQVxuZXhwb3J0IGludGVyZmFjZSBDYWxsV2l0aFBDQUluZm8gZXh0ZW5kcyBDYWxsIHtcbiAgaGFzUENBOiBib29sZWFuXG4gIGhhc0NhbGxiYWNrcz86IGJvb2xlYW5cbn1cblxuLy8gRGVmaW5pciBlbCB0aXBvIGRlIGRhdG9zIHBhcmEgbGEgdGFibGEgY2FsbGJhY2tzXG5leHBvcnQgaW50ZXJmYWNlIENhbGxiYWNrIHtcbiAgaWQ6IHN0cmluZ1xuICBpZF91dWlkX29sZDogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0OiBzdHJpbmdcbiAgbGVhZF9pZD86IHN0cmluZ1xuICBjYWxsX2lkPzogc3RyaW5nXG4gIGNvbXBhbnlfaWQ/OiBzdHJpbmdcbiAgYWdlbnRfaWQ/OiBzdHJpbmdcbiAgZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgY2FsbGJhY2tfb3duZXJfbmFtZTogc3RyaW5nXG4gIGNhbGxiYWNrX3RpbWU/OiBzdHJpbmdcbiAgY2FsbGJhY2tfd2luZG93X25vdGU/OiBzdHJpbmdcbiAgcGF5bG9hZD86IGFueVxuICBhZ2VudF9leHRlcm5hbF9pZD86IHN0cmluZ1xuICBsZWFkX3N0YXRlPzogc3RyaW5nXG4gIGxlYWRfY2l0eT86IHN0cmluZ1xuICBsZWFkX3ppcD86IHN0cmluZ1xuICBjYWxsX3N0YXJ0ZWRfYXQ/OiBzdHJpbmdcbiAgY2FsbGVyX3R6Pzogc3RyaW5nXG4gIHR6X2FtYmlndW91cz86IGJvb2xlYW5cbiAgY2FsbGJhY2tfdGltZV90ZXh0X3Jhdz86IHN0cmluZ1xuICBldmVudF90eXBlPzogc3RyaW5nXG4gIGZyb21fbnVtYmVyPzogc3RyaW5nXG4gIHRvX251bWJlcj86IHN0cmluZ1xufVxuXG4vLyBEZWZpbmlyIGVsIHRpcG8gZGUgZGF0b3MgcGFyYSBsYSB0YWJsYSBwY2FcbmV4cG9ydCBpbnRlcmZhY2UgUENBIHtcbiAgaWQ6IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgY2FsbF9pZDogc3RyaW5nXG4gIGFnZW50X25hbWU/OiBzdHJpbmdcbiAgZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgY2FsbF9zdWNjZXNzZnVsPzogYm9vbGVhblxuICB1c2VyX3NlbnRpbWVudD86IHN0cmluZ1xuICBkdXJhdGlvbl9tcz86IG51bWJlclxuICBzdGFydF90aW1lc3RhbXA/OiBzdHJpbmdcbiAgZW5kX3RpbWVzdGFtcD86IHN0cmluZ1xuICBkaXNjb25uZWN0aW9uX3JlYXNvbj86IHN0cmluZ1xuICBjYWxsX3N1bW1hcnk/OiBzdHJpbmdcbiAgdHJhbnNjcmlwdD86IHN0cmluZ1xuICByZWNvcmRpbmdfdXJsPzogc3RyaW5nXG4gIHJlY29yZGluZ19tdWx0aV9jaGFubmVsX3VybD86IHN0cmluZ1xuICBwdWJsaWNfbG9nX3VybD86IHN0cmluZ1xuICBjYWxsX2Nvc3Q/OiBudW1iZXJcbiAgYW5hbHlzaXM/OiBhbnlcbiAgY3VzdG9tX2FuYWx5c2lzX2RhdGE/OiBhbnlcbiAgbGxtX3Rva2VuX3VzYWdlPzogYW55XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBhZ2VudF9leHRlcm5hbF9pZD86IHN0cmluZ1xuICBmcm9tX251bWJlcj86IHN0cmluZ1xuICB0b19udW1iZXI/OiBzdHJpbmdcbn1cblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIHRvZGFzIGxhcyBsbGFtYWRhc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxzKCkge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdjYWxscycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLm9yZGVyKCdjYWxsX2lkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIHJldHVybiBkYXRhIGFzIENhbGxbXVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgbGxhbWFkYXMgY29uIGluZm9ybWFjacOzbiBkZSBzaSB0aWVuZW4gUENBXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbHNXaXRoUENBSW5mbygpOiBQcm9taXNlPENhbGxXaXRoUENBSW5mb1tdPiB7XG4gIHRyeSB7XG4gICAgLy8gUHJpbWVybyBvYnRlbmVtb3MgdG9kYXMgbGFzIGxsYW1hZGFzXG4gICAgY29uc3QgeyBkYXRhOiBjYWxscywgZXJyb3I6IGNhbGxzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAub3JkZXIoJ2NhbGxfaWQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYWxsczonLCBjYWxsc0Vycm9yKVxuICAgICAgdGhyb3cgY2FsbHNFcnJvclxuICAgIH1cblxuICAgIGlmICghY2FsbHMpIHJldHVybiBbXVxuXG4gICAgLy8gTHVlZ28gb2J0ZW5lbW9zIHRvZG9zIGxvcyBjYWxsX2lkcyBxdWUgdGllbmVuIFBDQVxuICAgIGNvbnN0IHsgZGF0YTogcGNhRGF0YSwgZXJyb3I6IHBjYUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCdjYWxsX2lkJylcblxuICAgIGlmIChwY2FFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgUENBIGRhdGE6JywgcGNhRXJyb3IpXG4gICAgICAvLyBObyBsYW56YW1vcyBlcnJvciBhcXXDrSwgc29sbyBsb2d1ZWFtb3MgeSBjb250aW51YW1vcyBzaW4gUENBIGluZm9cbiAgICB9XG5cbiAgICBjb25zdCBjYWxsc1dpdGhQQ0EgPSBuZXcgU2V0KHBjYURhdGE/Lm1hcChwY2EgPT4gcGNhLmNhbGxfaWQpIHx8IFtdKVxuXG4gICAgLy8gQ29tYmluYW1vcyBsYSBpbmZvcm1hY2nDs25cbiAgICByZXR1cm4gY2FsbHMubWFwKGNhbGwgPT4gKHtcbiAgICAgIC4uLmNhbGwsXG4gICAgICBoYXNQQ0E6IGNhbGxzV2l0aFBDQS5oYXMoY2FsbC5jYWxsX2lkKSxcbiAgICAgIGhhc0NhbGxiYWNrczogZmFsc2UgLy8gWWEgbm8gdXNhbW9zIGNhbGxiYWNrcyBjb21vIGNvbmNlcHRvXG4gICAgfSkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2FsbHNXaXRoUENBSW5mbzonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIPCfk4ogUEFHSU5BQ0nDk04gRVNDQUxBQkxFIFBBUkEgUFJPRFVDQ0nDk05cblxuLy8gSW50ZXJmYXogcGFyYSBwYXLDoW1ldHJvcyBkZSBwYWdpbmFjacOzblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uUGFyYW1zIHtcbiAgcGFnZTogbnVtYmVyXG4gIGxpbWl0OiBudW1iZXJcbiAgc2VhcmNoPzogc3RyaW5nXG4gIGZpbHRlcnM/OiB7XG4gICAgaGFzUENBPzogYm9vbGVhblxuICAgIGRpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIH1cbiAgc29ydEJ5Pzogc3RyaW5nXG4gIHNvcnRPcmRlcj86ICdhc2MnIHwgJ2Rlc2MnXG59XG5cbi8vIEludGVyZmF6IHBhcmEgcmVzcHVlc3RhIHBhZ2luYWRhXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRlZFJlc3BvbnNlPFQ+IHtcbiAgZGF0YTogVFtdXG4gIHRvdGFsOiBudW1iZXJcbiAgcGFnZTogbnVtYmVyXG4gIGxpbWl0OiBudW1iZXJcbiAgdG90YWxQYWdlczogbnVtYmVyXG59XG5cbi8vIEZ1bmNpw7NuIE5VRVZBOiBPYnRlbmVyIGxsYW1hZGFzIGNvbiBwYWdpbmFjacOzbiBlbiBzZXJ2aWRvciAoRVNDQUxBQkxFKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxzV2l0aFBhZ2luYXRpb24ocGFyYW1zOiBQYWdpbmF0aW9uUGFyYW1zKTogUHJvbWlzZTxQYWdpbmF0ZWRSZXNwb25zZTxDYWxsV2l0aFBDQUluZm8+PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gT2J0ZW5pZW5kbyBsbGFtYWRhcyBwYWdpbmFkYXM6JywgcGFyYW1zKVxuICAgIFxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbHMnKVxuICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcgfSlcblxuICAgIC8vIEFwbGljYXIgZmlsdHJvcyBkZSBiw7pzcXVlZGFcbiAgICBpZiAocGFyYW1zLnNlYXJjaCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5vcihgYnVzaW5lc3NfbmFtZS5pbGlrZS4lJHtwYXJhbXMuc2VhcmNofSUsb3duZXJfbmFtZS5pbGlrZS4lJHtwYXJhbXMuc2VhcmNofSUsb3duZXJfcGhvbmUuaWxpa2UuJSR7cGFyYW1zLnNlYXJjaH0lYClcbiAgICB9XG5cbiAgICAvLyBBcGxpY2FyIGZpbHRyb3MgYWRpY2lvbmFsZXNcbiAgICBpZiAocGFyYW1zLmZpbHRlcnM/LmRpc3Bvc2l0aW9uKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdkaXNwb3NpdGlvbicsIHBhcmFtcy5maWx0ZXJzLmRpc3Bvc2l0aW9uKVxuICAgIH1cblxuICAgIC8vIEFwbGljYXIgb3JkZW5hbWllbnRvXG4gICAgY29uc3Qgc29ydEJ5ID0gcGFyYW1zLnNvcnRCeSB8fCAnY2FsbF9pZCdcbiAgICBjb25zdCBzb3J0T3JkZXIgPSBwYXJhbXMuc29ydE9yZGVyID09PSAnYXNjJyA/IHsgYXNjZW5kaW5nOiB0cnVlIH0gOiB7IGFzY2VuZGluZzogZmFsc2UgfVxuICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIoc29ydEJ5LCBzb3J0T3JkZXIpXG5cbiAgICAvLyBBcGxpY2FyIHBhZ2luYWNpw7NuXG4gICAgY29uc3Qgb2Zmc2V0ID0gKHBhcmFtcy5wYWdlIC0gMSkgKiBwYXJhbXMubGltaXRcbiAgICBxdWVyeSA9IHF1ZXJ5LnJhbmdlKG9mZnNldCwgb2Zmc2V0ICsgcGFyYW1zLmxpbWl0IC0gMSlcblxuICAgIGNvbnN0IHsgZGF0YTogY2FsbHMsIGNvdW50LCBlcnJvcjogY2FsbHNFcnJvciB9ID0gYXdhaXQgcXVlcnlcblxuICAgIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwYWdpbmF0ZWQgY2FsbHM6JywgY2FsbHNFcnJvcilcbiAgICAgIHRocm93IGNhbGxzRXJyb3JcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxzIHx8IGNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHRvdGFsOiBjb3VudCB8fCAwLFxuICAgICAgICBwYWdlOiBwYXJhbXMucGFnZSxcbiAgICAgICAgbGltaXQ6IHBhcmFtcy5saW1pdCxcbiAgICAgICAgdG90YWxQYWdlczogTWF0aC5jZWlsKChjb3VudCB8fCAwKSAvIHBhcmFtcy5saW1pdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBQQ0Egc29sbyBwYXJhIGxhcyBsbGFtYWRhcyBkZSBlc3RhIHDDoWdpbmFcbiAgICBjb25zdCBjYWxsSWRzID0gY2FsbHMubWFwKGNhbGwgPT4gY2FsbC5jYWxsX2lkKVxuICAgIGNvbnN0IHsgZGF0YTogcGNhRGF0YSwgZXJyb3I6IHBjYUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCdjYWxsX2lkJylcbiAgICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG5cbiAgICBpZiAocGNhRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFBDQSBkYXRhOicsIHBjYUVycm9yKVxuICAgIH1cblxuICAgIC8vIE9idGVuZXIgY2FsbGJhY2tzIGFzb2NpYWRvcyBhIGVzdGFzIGNhbGxzXG4gICAgY29uc3QgeyBkYXRhOiBjYWxsYmFja0RhdGEsIGVycm9yOiBjYWxsYmFja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAuc2VsZWN0KCdjYWxsX2lkLCBjYWxsYmFja19vd25lcl9uYW1lJylcbiAgICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG5cbiAgICBpZiAoY2FsbGJhY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FsbGJhY2sgZGF0YTonLCBjYWxsYmFja0Vycm9yKVxuICAgIH1cblxuICAgIGNvbnN0IGNhbGxzV2l0aFBDQSA9IG5ldyBTZXQocGNhRGF0YT8ubWFwKHBjYSA9PiBwY2EuY2FsbF9pZCkgfHwgW10pXG4gICAgY29uc3QgY2FsbGJhY2tPd25lck1hcCA9IG5ldyBNYXAoXG4gICAgICAoY2FsbGJhY2tEYXRhIHx8IFtdKS5tYXAoY2FsbGJhY2sgPT4gW2NhbGxiYWNrLmNhbGxfaWQsIGNhbGxiYWNrLmNhbGxiYWNrX293bmVyX25hbWVdKVxuICAgIClcblxuICAgIC8vIENvbWJpbmFyIGluZm9ybWFjacOzblxuICAgIGNvbnN0IGNhbGxzV2l0aEluZm86IENhbGxXaXRoUENBSW5mb1tdID0gY2FsbHMubWFwKGNhbGwgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tPd25lciA9IGNhbGxiYWNrT3duZXJNYXAuZ2V0KGNhbGwuY2FsbF9pZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNhbGwsXG4gICAgICAgIC8vIFNpIGhheSBjYWxsYmFja19vd25lcl9uYW1lLCB1c2FybG8gZW4gbHVnYXIgZGVsIG93bmVyX25hbWUgb3JpZ2luYWxcbiAgICAgICAgb3duZXJfbmFtZTogY2FsbGJhY2tPd25lciB8fCBjYWxsLm93bmVyX25hbWUsXG4gICAgICAgIGhhc1BDQTogY2FsbHNXaXRoUENBLmhhcyhjYWxsLmNhbGxfaWQpLFxuICAgICAgICBoYXNDYWxsYmFja3M6IGNhbGxiYWNrT3duZXJNYXAuaGFzKGNhbGwuY2FsbF9pZClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gQXBsaWNhciBmaWx0cm9zIHBvc3QtcXVlcnkgc2kgZXMgbmVjZXNhcmlvXG4gICAgbGV0IGZpbHRlcmVkQ2FsbHMgPSBjYWxsc1dpdGhJbmZvXG4gICAgaWYgKHBhcmFtcy5maWx0ZXJzPy5oYXNQQ0EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmlsdGVyZWRDYWxscyA9IGZpbHRlcmVkQ2FsbHMuZmlsdGVyKGNhbGwgPT4gY2FsbC5oYXNQQ0EgPT09IHBhcmFtcy5maWx0ZXJzIS5oYXNQQ0EpXG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGguY2VpbCgoY291bnQgfHwgMCkgLyBwYXJhbXMubGltaXQpXG5cbiAgICBjb25zb2xlLmxvZyhg4pyFIERldm9sdmllbmRvICR7ZmlsdGVyZWRDYWxscy5sZW5ndGh9IGxsYW1hZGFzIChww6FnaW5hICR7cGFyYW1zLnBhZ2V9LyR7dG90YWxQYWdlc30pIGRlICR7Y291bnR9IHRvdGFsYClcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZmlsdGVyZWRDYWxscyxcbiAgICAgIHRvdGFsOiBjb3VudCB8fCAwLFxuICAgICAgcGFnZTogcGFyYW1zLnBhZ2UsXG4gICAgICBsaW1pdDogcGFyYW1zLmxpbWl0LFxuICAgICAgdG90YWxQYWdlc1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDYWxsc1dpdGhQYWdpbmF0aW9uOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIGNhbGxiYWNrcyBwb3IgY2FsbF9pZFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxiYWNrc0J5Q2FsbElkKGNhbGxJZDogc3RyaW5nKTogUHJvbWlzZTxDYWxsYmFja1tdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYWxsYmFja3MnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NhbGxfaWQnLCBjYWxsSWQpXG4gICAgICAub3JkZXIoJ2NhbGxiYWNrX2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FsbGJhY2tzOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENhbGxiYWNrc0J5Q2FsbElkOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIGFuw6FsaXNpcyBQQ0EgcG9yIGNhbGxfaWRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQQ0FCeUNhbGxJZChjYWxsSWQ6IHN0cmluZyk6IFByb21pc2U8UENBW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBQQ0EgZGF0YTonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRQQ0FCeUNhbGxJZDonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIE51ZXZhIGZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBpbmZvcm1hY2nDs24gY29tcGxldGEgZGVsIGNsaWVudGUgeSBhbsOhbGlzaXMgKGNhbGxzIHkgY2FsbGJhY2tzKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxEZXRhaWxzV2l0aFBDQShjYWxsSWQ6IHN0cmluZyk6IFByb21pc2U8eyBjYWxsOiBDYWxsIHwgbnVsbCwgcGNhOiBQQ0FbXSwgaXNDYWxsYmFjazogYm9vbGVhbiwgY2FsbGJhY2s/OiBhbnkgfT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIGdldENhbGxEZXRhaWxzV2l0aFBDQSAtIGJ1c2NhbmRvIGNhbGxJZDonLCBjYWxsSWQpXG4gICAgXG4gICAgLy8gT2J0ZW5lciBsYSBsbGFtYWRhIChzaWVtcHJlIGV4aXN0ZSlcbiAgICBjb25zdCB7IGRhdGE6IGNhbGxEYXRhLCBlcnJvcjogY2FsbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdjYWxsX2lkJywgY2FsbElkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBjb25zb2xlLmxvZygn8J+TniBSZXN1bHRhZG8gYsO6c3F1ZWRhIGVuIGNhbGxzOicsIHsgY2FsbERhdGEsIGNhbGxFcnJvciB9KVxuXG4gICAgaWYgKGNhbGxFcnJvciB8fCAhY2FsbERhdGEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBObyBzZSBlbmNvbnRyw7MgbGEgY2FsbCBjb24gSUQ6JywgY2FsbElkKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbDogbnVsbCxcbiAgICAgICAgcGNhOiBbXSxcbiAgICAgICAgaXNDYWxsYmFjazogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgc2kgZXN0YSBjYWxsIHRpZW5lIHVuIGNhbGxiYWNrIGFzb2NpYWRvXG4gICAgY29uc3QgeyBkYXRhOiBjYWxsYmFja0RhdGEsIGVycm9yOiBjYWxsYmFja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgY29uc29sZS5sb2coJ++/vSBWZXJpZmljYW5kbyBzaSB0aWVuZSBjYWxsYmFjayBhc29jaWFkbzonLCB7IGNhbGxiYWNrRGF0YSwgY2FsbGJhY2tFcnJvciB9KVxuXG4gICAgLy8gT2J0ZW5lciBQQ0FcbiAgICBjb25zdCBwY2FEYXRhID0gYXdhaXQgZ2V0UENBQnlDYWxsSWQoY2FsbElkKVxuXG4gICAgaWYgKGNhbGxiYWNrRGF0YSAmJiAhY2FsbGJhY2tFcnJvcikge1xuICAgICAgLy8gRXMgdW5hIGNhbGwgcXVlIFRBTUJJw4lOIGVzIHVuIGNhbGxiYWNrXG4gICAgICBjb25zb2xlLmxvZygn4pyFIENhbGwgY29uIGNhbGxiYWNrIGFzb2NpYWRvIGVuY29udHJhZG8nKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbDogY2FsbERhdGEsXG4gICAgICAgIHBjYTogcGNhRGF0YSxcbiAgICAgICAgaXNDYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrRGF0YVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFcyB1bmEgY2FsbCBub3JtYWwgKHNpbiBjYWxsYmFjaylcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQ2FsbCBub3JtYWwgKHNpbiBjYWxsYmFjayknKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbDogY2FsbERhdGEsXG4gICAgICAgIHBjYTogcGNhRGF0YSxcbiAgICAgICAgaXNDYWxsYmFjazogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluIGdldENhbGxEZXRhaWxzV2l0aFBDQTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIEZ1bmNpw7NuIGRlIGRlYnVnIHBhcmEgdmVyIHRvZG9zIGxvcyBQQ0EgZGlzcG9uaWJsZXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxQQ0EoKSB7XG4gIGNvbnNvbGUubG9nKCdJbnRlbnRhbmRvIG9idGVuZXIgdG9kb3MgbG9zIFBDQS4uLicpXG4gIFxuICAvLyBQcmltZXJvIGludGVudGFtb3Mgc2luIGzDrW1pdGVzXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IsIHN0YXR1cywgc3RhdHVzVGV4dCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncGNhJylcbiAgICAuc2VsZWN0KCdpZCwgY2FsbF9pZCwgYWdlbnRfbmFtZSwgY3JlYXRlZF9hdCcpXG4gICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgY29uc29sZS5sb2coJ1Jlc3B1ZXN0YSBQQ0E6JywgeyBcbiAgICBkYXRhLCBcbiAgICBlcnJvciwgXG4gICAgc3RhdHVzLCBcbiAgICBzdGF0dXNUZXh0LFxuICAgIGRhdGFMZW5ndGg6IGRhdGE/Lmxlbmd0aCB8fCAwXG4gIH0pXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWxsYWRvIGFsIG9idGVuZXIgUENBOicsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgaGludDogZXJyb3IuaGludCxcbiAgICAgIGNvZGU6IGVycm9yLmNvZGVcbiAgICB9KVxuICAgIFxuICAgIC8vIEludGVudGFtb3MgY29uIHVuIHF1ZXJ5IG3DoXMgc2ltcGxlXG4gICAgY29uc29sZS5sb2coJ0ludGVudGFuZG8gcXVlcnkgbcOhcyBzaW1wbGUuLi4nKVxuICAgIGNvbnN0IHsgZGF0YTogc2ltcGxlRGF0YSwgZXJyb3I6IHNpbXBsZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5saW1pdCgxKVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdRdWVyeSBzaW1wbGUgcmVzdWx0YWRvOicsIHsgc2ltcGxlRGF0YSwgc2ltcGxlRXJyb3IgfSlcbiAgICBcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgY29uc29sZS5sb2coJ1BDQSBvYnRlbmlkb3MgZXhpdG9zYW1lbnRlOicsIGRhdGEpXG4gIHJldHVybiBkYXRhXG59XG5cbi8vIEZ1bmNpw7NuIGRlIGRlYnVnIHNpbXBsZSBwYXJhIHZlcmlmaWNhciBhY2Nlc28gYSBQQ0FcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXN0UENBQWNjZXNzKCkge1xuICBjb25zb2xlLmxvZygnVGVzdGVhbmRvIGFjY2VzbyBhIHRhYmxhIFBDQS4uLicpXG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncGNhJylcbiAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuXG4gIGNvbnNvbGUubG9nKCdUZXN0IFBDQSAtIENvdW50OicsIGNvdW50LCAnRXJyb3I6JywgZXJyb3IpXG4gIFxuICByZXR1cm4geyBjb3VudCwgZXJyb3IgfVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIHZlcmlmaWNhciB0b2RhcyBsYXMgdGFibGFzIGRpc3BvbmlibGVzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdEFsbFRhYmxlc0FjY2VzcygpIHtcbiAgY29uc3QgdGFibGVzID0gWydjYWxscycsICdwY2EnLCAnY2FsbGJhY2tzJ11cbiAgY29uc3QgcmVzdWx0czogUmVjb3JkPHN0cmluZywgeyBjb3VudDogbnVtYmVyIHwgbnVsbCwgZXJyb3I6IHN0cmluZyB8IG51bGwgfT4gPSB7fVxuICBcbiAgZm9yIChjb25zdCB0YWJsZSBvZiB0YWJsZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFRlc3RlYW5kbyB0YWJsYTogJHt0YWJsZX1gKVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKHRhYmxlKVxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgXG4gICAgICByZXN1bHRzW3RhYmxlXSA9IHsgY291bnQsIGVycm9yOiBlcnJvcj8ubWVzc2FnZSB8fCBudWxsIH1cbiAgICAgIGNvbnNvbGUubG9nKGAke3RhYmxlfTogJHtjb3VudH0gcmVnaXN0cm9zLCBlcnJvcjpgLCBlcnJvcj8ubWVzc2FnZSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgICByZXN1bHRzW3RhYmxlXSA9IHsgY291bnQ6IDAsIGVycm9yOiBlcnJvck1lc3NhZ2UgfVxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW4gdGFibGEgJHt0YWJsZX06YCwgZXJyKVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdHNcbn1cblxuLy8gRnVuY2nDs24gZXNwZWPDrWZpY2EgcGFyYSBkaWFnbm9zdGljYXIgZWwgcHJvYmxlbWEgZGUgUENBXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlhZ25vc2VQQ0FBY2Nlc3MoKSB7XG4gIGNvbnNvbGUubG9nKCfwn5SNIERpYWdub3N0aWNhbmRvIGFjY2VzbyBhIHRhYmxhIFBDQS4uLicpXG4gIFxuICBjb25zdCB0ZXN0cyA9IFtdXG4gIFxuICAvLyBUZXN0IDE6IENvdW50IGLDoXNpY29cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICBcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdDb3VudCBiw6FzaWNvJyxcbiAgICAgIHN1Y2Nlc3M6ICFlcnJvcixcbiAgICAgIHJlc3VsdDogYENvdW50OiAke2NvdW50fWAsXG4gICAgICBlcnJvcjogZXJyb3I/Lm1lc3NhZ2VcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdDb3VudCBiw6FzaWNvJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgcmVzdWx0OiAnRXhjZXBjacOzbicsXG4gICAgICBlcnJvcjogZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbydcbiAgICB9KVxuICB9XG4gIFxuICAvLyBUZXN0IDI6IFNlbGVjdCBzaW1wbGUgY29uIGzDrW1pdGVcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAubGltaXQoMSlcbiAgICBcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdTZWxlY3Qgc2ltcGxlIChsaW1pdCAxKScsXG4gICAgICBzdWNjZXNzOiAhZXJyb3IsXG4gICAgICByZXN1bHQ6IGBSZWdpc3Ryb3M6ICR7ZGF0YT8ubGVuZ3RoIHx8IDB9YCxcbiAgICAgIGVycm9yOiBlcnJvcj8ubWVzc2FnZVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1NlbGVjdCBzaW1wbGUgKGxpbWl0IDEpJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgcmVzdWx0OiAnRXhjZXBjacOzbicsXG4gICAgICBlcnJvcjogZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbydcbiAgICB9KVxuICB9XG4gIFxuICAvLyBUZXN0IDM6IFNlbGVjdCBlc3BlY8OtZmljb1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJ2lkLCBjYWxsX2lkJylcbiAgICAgIC5saW1pdCgzKVxuICAgIFxuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1NlbGVjdCBlc3BlY8OtZmljbyAoaWQsIGNhbGxfaWQpJyxcbiAgICAgIHN1Y2Nlc3M6ICFlcnJvcixcbiAgICAgIHJlc3VsdDogYFJlZ2lzdHJvczogJHtkYXRhPy5sZW5ndGggfHwgMH1gLFxuICAgICAgZXJyb3I6IGVycm9yPy5tZXNzYWdlLFxuICAgICAgc2FtcGxlRGF0YTogZGF0YVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1NlbGVjdCBlc3BlY8OtZmljbyAoaWQsIGNhbGxfaWQpJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgcmVzdWx0OiAnRXhjZXBjacOzbicsXG4gICAgICBlcnJvcjogZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbydcbiAgICB9KVxuICB9XG4gIFxuICAvLyBUZXN0IDQ6IFZlcmlmaWNhciBzaSBSTFMgZXN0w6EgY2F1c2FuZG8gZWwgcHJvYmxlbWFcbiAgdHJ5IHtcbiAgICAvLyBJbnRlbnRhbW9zIGhhY2VyIHVuIHF1ZXJ5IGNvbiBieXBhc3MgZGUgUkxTIHNpIGVzIHBvc2libGVcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLnJwYygnZ2V0X3BjYV9jb3VudCcpICAvLyBFc3RhIGZ1bmNpw7NuIG5vIGV4aXN0ZSwgcGVybyBlbCBlcnJvciBub3MgZGFyw6EgaW5mb3JtYWNpw7NuXG4gICAgXG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnVGVzdCBSUEMgKHBhcmEgdmVyaWZpY2FyIFJMUyknLFxuICAgICAgc3VjY2VzczogIWVycm9yLFxuICAgICAgcmVzdWx0OiAnUlBDIGNhbGwnLFxuICAgICAgZXJyb3I6IGVycm9yPy5tZXNzYWdlXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnVGVzdCBSUEMgKHBhcmEgdmVyaWZpY2FyIFJMUyknLFxuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICByZXN1bHQ6ICdSUEMgbm8gZGlzcG9uaWJsZScsXG4gICAgICBlcnJvcjogZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbydcbiAgICB9KVxuICB9XG5cbiAgY29uc29sZS5sb2coJ/Cfk4ogUmVzdWx0YWRvcyBkZWwgZGlhZ27Ds3N0aWNvOicsIHRlc3RzKVxuICByZXR1cm4gdGVzdHNcbn1cblxuLy8gRnVuY2nDs24gcGFyYSBjcmVhciB1bmEgcG9sw610aWNhIHRlbXBvcmFsIGRlIFJMU1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBDQVBvbGljeSgpIHtcbiAgY29uc29sZS5sb2coJ/CflKcgSW50ZW50YW5kbyBjcmVhciBwb2zDrXRpY2EgZGUgYWNjZXNvIHBhcmEgUENBLi4uJylcbiAgXG4gIHRyeSB7XG4gICAgLy8gSW50ZW50YW1vcyBlamVjdXRhciB1biBjb21hbmRvIFNRTCBwYXJhIGNyZWFyIHVuYSBwb2zDrXRpY2FcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLnJwYygnY3JlYXRlX3BjYV9wb2xpY3knKVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6ICFlcnJvciwgZXJyb3I6IGVycm9yPy5tZXNzYWdlIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHsgXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICBlcnJvcjogZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbydcbiAgICB9XG4gIH1cbn1cblxuLy8g8J+TniBGVU5DSU9ORVMgUEFSQSBISVNUT1JJQUwgREUgTExBTUFEQVMgUE9SIFRFTMOJRk9OT1xuXG4vLyBJbnRlcmZheiBwYXJhIHVuIExlYWQgKG7Dum1lcm8gZGUgdGVsw6lmb25vIGNvbiBpbmZvcm1hY2nDs24gZGVsIGNsaWVudGUpXG5leHBvcnQgaW50ZXJmYWNlIExlYWQge1xuICBwaG9uZV9udW1iZXI6IHN0cmluZ1xuICBidXNpbmVzc19uYW1lPzogc3RyaW5nXG4gIG93bmVyX25hbWU/OiBzdHJpbmdcbiAgb3duZXJfZW1haWw/OiBzdHJpbmdcbiAgbG9jYXRpb25fdHlwZT86IHN0cmluZ1xuICBhZGRyZXNzX3N0cmVldD86IHN0cmluZ1xuICBhZGRyZXNzX2NpdHk/OiBzdHJpbmdcbiAgYWRkcmVzc19zdGF0ZT86IHN0cmluZ1xuICBhZGRyZXNzX3ppcD86IHN0cmluZ1xuICB0b3RhbF9jYWxsczogbnVtYmVyXG4gIGxhc3RfY2FsbF9kYXRlOiBzdHJpbmdcbiAgbGFzdF9kaXNwb3NpdGlvbj86IHN0cmluZ1xuICBhZ3JlZWRfYW1vdW50PzogbnVtYmVyXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciB0b2RvcyBsb3MgbGVhZHMgKG7Dum1lcm9zIMO6bmljb3MgY29uIHN1IGluZm9ybWFjacOzbiBtw6FzIHJlY2llbnRlKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExlYWRzKCk6IFByb21pc2U8TGVhZFtdPiB7XG4gIGNvbnNvbGUubG9nKCfwn5OeIE9idGVuaWVuZG8gdG9kb3MgbG9zIGxlYWRzLi4uJylcbiAgXG4gIC8vIFByaW1lcm8gb2J0ZW5lbW9zIHRvZGFzIGxhcyBjYWxsc1xuICBjb25zdCB7IGRhdGE6IGNhbGxzRGF0YSwgZXJyb3I6IGNhbGxzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2NhbGxzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAubm90KCd0b19udW1iZXInLCAnaXMnLCBudWxsKVxuICAgIC5vcmRlcignY2FsbF9pZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICBcbiAgaWYgKGNhbGxzRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igb2J0ZW5pZW5kbyBjYWxsczonLCBjYWxsc0Vycm9yKVxuICAgIHRocm93IGNhbGxzRXJyb3JcbiAgfVxuICBcbiAgaWYgKCFjYWxsc0RhdGEpIHJldHVybiBbXVxuICBcbiAgLy8gT2J0ZW5lciB0b2RhcyBsYXMgZGlzcG9zaXRpb25zIGRlbCBQQ0EgcGFyYSBsb3MgY2FsbF9pZHNcbiAgY29uc3QgY2FsbElkcyA9IGNhbGxzRGF0YS5tYXAoY2FsbCA9PiBjYWxsLmNhbGxfaWQpXG4gIGNvbnN0IHsgZGF0YTogcGNhRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncGNhJylcbiAgICAuc2VsZWN0KCdjYWxsX2lkLCBkaXNwb3NpdGlvbicpXG4gICAgLmluKCdjYWxsX2lkJywgY2FsbElkcylcbiAgXG4gIC8vIENyZWFyIHVuIG1hcGEgcGFyYSBhY2Nlc28gcsOhcGlkbyBhIGxhcyBkaXNwb3NpdGlvbnMgZGVsIFBDQVxuICBjb25zdCBwY2FNYXAgPSBuZXcgTWFwKClcbiAgaWYgKHBjYURhdGEpIHtcbiAgICBwY2FEYXRhLmZvckVhY2gocGNhID0+IHtcbiAgICAgIHBjYU1hcC5zZXQocGNhLmNhbGxfaWQsIHBjYS5kaXNwb3NpdGlvbilcbiAgICB9KVxuICB9XG4gIFxuICBjb25zdCBkYXRhID0gY2FsbHNEYXRhXG4gIFxuICAvLyBBZ3J1cGFtb3MgcG9yIHRvX251bWJlciB5IHRvbWFtb3MgbGEgaW5mb3JtYWNpw7NuIG3DoXMgcmVjaWVudGVcbiAgY29uc3QgbGVhZHNNYXAgPSBuZXcgTWFwPHN0cmluZywgTGVhZD4oKVxuICBcbiAgZm9yIChjb25zdCBjYWxsIG9mIGRhdGEpIHtcbiAgICBpZiAoIWNhbGwudG9fbnVtYmVyKSBjb250aW51ZVxuICAgIFxuICAgIGNvbnN0IGV4aXN0aW5nTGVhZCA9IGxlYWRzTWFwLmdldChjYWxsLnRvX251bWJlcilcbiAgICBcbiAgICBpZiAoIWV4aXN0aW5nTGVhZCkge1xuICAgICAgLy8gUHJpbWVyYSB2ZXogcXVlIHZlbW9zIGVzdGUgbsO6bWVyb1xuICAgICAgbGVhZHNNYXAuc2V0KGNhbGwudG9fbnVtYmVyLCB7XG4gICAgICAgIHBob25lX251bWJlcjogY2FsbC50b19udW1iZXIsXG4gICAgICAgIGJ1c2luZXNzX25hbWU6IGNhbGwuYnVzaW5lc3NfbmFtZSxcbiAgICAgICAgb3duZXJfbmFtZTogY2FsbC5vd25lcl9uYW1lLFxuICAgICAgICBvd25lcl9lbWFpbDogY2FsbC5vd25lcl9lbWFpbCxcbiAgICAgICAgbG9jYXRpb25fdHlwZTogY2FsbC5sb2NhdGlvbl90eXBlLFxuICAgICAgICBhZGRyZXNzX3N0cmVldDogY2FsbC5hZGRyZXNzX3N0cmVldCxcbiAgICAgICAgYWRkcmVzc19jaXR5OiBjYWxsLmFkZHJlc3NfY2l0eSxcbiAgICAgICAgYWRkcmVzc19zdGF0ZTogY2FsbC5hZGRyZXNzX3N0YXRlLFxuICAgICAgICBhZGRyZXNzX3ppcDogY2FsbC5hZGRyZXNzX3ppcCxcbiAgICAgICAgdG90YWxfY2FsbHM6IDEsXG4gICAgICAgIGxhc3RfY2FsbF9kYXRlOiBjYWxsLmNhbGxfaWQsIC8vIFVzYW5kbyBjYWxsX2lkIGNvbW8gcHJveHkgZGUgZmVjaGFcbiAgICAgICAgbGFzdF9kaXNwb3NpdGlvbjogcGNhTWFwLmdldChjYWxsLmNhbGxfaWQpIHx8IGNhbGwuZGlzcG9zaXRpb24sXG4gICAgICAgIGFncmVlZF9hbW91bnQ6IGNhbGwuYWdyZWVkX2Ftb3VudFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWN0dWFsaXphbW9zIGVsIGNvbnRlb1xuICAgICAgZXhpc3RpbmdMZWFkLnRvdGFsX2NhbGxzKytcbiAgICAgIFxuICAgICAgLy8gU2kgZXN0YSBsbGFtYWRhIGVzIG3DoXMgcmVjaWVudGUgKGNhbGxfaWQgbWF5b3IpLCBhY3R1YWxpemFtb3MgbGEgaW5mb1xuICAgICAgaWYgKGNhbGwuY2FsbF9pZCA+IGV4aXN0aW5nTGVhZC5sYXN0X2NhbGxfZGF0ZSkge1xuICAgICAgICBleGlzdGluZ0xlYWQuYnVzaW5lc3NfbmFtZSA9IGNhbGwuYnVzaW5lc3NfbmFtZSB8fCBleGlzdGluZ0xlYWQuYnVzaW5lc3NfbmFtZVxuICAgICAgICBleGlzdGluZ0xlYWQub3duZXJfbmFtZSA9IGNhbGwub3duZXJfbmFtZSB8fCBleGlzdGluZ0xlYWQub3duZXJfbmFtZVxuICAgICAgICBleGlzdGluZ0xlYWQub3duZXJfZW1haWwgPSBjYWxsLm93bmVyX2VtYWlsIHx8IGV4aXN0aW5nTGVhZC5vd25lcl9lbWFpbFxuICAgICAgICBleGlzdGluZ0xlYWQubG9jYXRpb25fdHlwZSA9IGNhbGwubG9jYXRpb25fdHlwZSB8fCBleGlzdGluZ0xlYWQubG9jYXRpb25fdHlwZVxuICAgICAgICBleGlzdGluZ0xlYWQuYWRkcmVzc19zdHJlZXQgPSBjYWxsLmFkZHJlc3Nfc3RyZWV0IHx8IGV4aXN0aW5nTGVhZC5hZGRyZXNzX3N0cmVldFxuICAgICAgICBleGlzdGluZ0xlYWQuYWRkcmVzc19jaXR5ID0gY2FsbC5hZGRyZXNzX2NpdHkgfHwgZXhpc3RpbmdMZWFkLmFkZHJlc3NfY2l0eVxuICAgICAgICBleGlzdGluZ0xlYWQuYWRkcmVzc19zdGF0ZSA9IGNhbGwuYWRkcmVzc19zdGF0ZSB8fCBleGlzdGluZ0xlYWQuYWRkcmVzc19zdGF0ZVxuICAgICAgICBleGlzdGluZ0xlYWQuYWRkcmVzc196aXAgPSBjYWxsLmFkZHJlc3NfemlwIHx8IGV4aXN0aW5nTGVhZC5hZGRyZXNzX3ppcFxuICAgICAgICBleGlzdGluZ0xlYWQubGFzdF9jYWxsX2RhdGUgPSBjYWxsLmNhbGxfaWRcbiAgICAgICAgZXhpc3RpbmdMZWFkLmxhc3RfZGlzcG9zaXRpb24gPSBwY2FNYXAuZ2V0KGNhbGwuY2FsbF9pZCkgfHwgY2FsbC5kaXNwb3NpdGlvblxuICAgICAgICBleGlzdGluZ0xlYWQuYWdyZWVkX2Ftb3VudCA9IGNhbGwuYWdyZWVkX2Ftb3VudCB8fCBleGlzdGluZ0xlYWQuYWdyZWVkX2Ftb3VudFxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbGVhZHMgPSBBcnJheS5mcm9tKGxlYWRzTWFwLnZhbHVlcygpKVxuICBjb25zb2xlLmxvZyhg4pyFIEVuY29udHJhZG9zICR7bGVhZHMubGVuZ3RofSBsZWFkcyDDum5pY29zYClcbiAgcmV0dXJuIGxlYWRzXG59XG5cbi8vIEludGVyZmF6IHBhcmEgaW50ZXJhY2Npb25lcyBjb21iaW5hZGFzIChjYWxscyArIGNhbGxiYWNrcylcbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbEludGVyYWN0aW9uIHtcbiAgdHlwZTogJ2NhbGwnIHwgJ2NhbGxiYWNrJ1xuICBjYWxsX2lkPzogc3RyaW5nXG4gIGlkPzogc3RyaW5nXG4gIGRpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIGJ1c2luZXNzX25hbWU/OiBzdHJpbmdcbiAgb3duZXJfbmFtZT86IHN0cmluZ1xuICBhZ3JlZWRfYW1vdW50PzogbnVtYmVyXG4gIGFkZHJlc3Nfc3RyZWV0Pzogc3RyaW5nXG4gIGFkZHJlc3NfY2l0eT86IHN0cmluZ1xuICBhZGRyZXNzX3N0YXRlPzogc3RyaW5nXG4gIGNhbGxiYWNrX3RpbWU/OiBzdHJpbmdcbiAgY3JlYXRlZF9hdD86IHN0cmluZ1xuICBkYXRlOiBzdHJpbmdcbiAgZGlzcGxheV9kYXRlOiBzdHJpbmdcbn1cblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIGhpc3RvcmlhbCBjb21wbGV0byAoY2FsbHMgKyBjYWxsYmFja3MpIHBvciBuw7ptZXJvIGRlIHRlbMOpZm9ub1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxIaXN0b3J5QnlQaG9uZShwaG9uZU51bWJlcjogc3RyaW5nKTogUHJvbWlzZTxDYWxsSW50ZXJhY3Rpb25bXT4ge1xuICBjb25zb2xlLmxvZyhg8J+TniBPYnRlbmllbmRvIGhpc3RvcmlhbCBjb21wbGV0byBwYXJhOiAke3Bob25lTnVtYmVyfWApXG4gIFxuICB0cnkge1xuICAgIC8vIE9idGVuZXIgbGxhbWFkYXMgcmVndWxhcmVzXG4gICAgY29uc3QgeyBkYXRhOiBjYWxscywgZXJyb3I6IGNhbGxzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3RvX251bWJlcicsIHBob25lTnVtYmVyKVxuICAgICAgLm9yZGVyKCdjYWxsX2lkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgXG4gICAgaWYgKGNhbGxzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBvYnRlbmllbmRvIGxsYW1hZGFzOicsIGNhbGxzRXJyb3IpXG4gICAgICB0aHJvdyBjYWxsc0Vycm9yXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5OeIEVuY29udHJhZGFzICR7Y2FsbHM/Lmxlbmd0aCB8fCAwfSBsbGFtYWRhcyBwYXJhICR7cGhvbmVOdW1iZXJ9YClcbiAgICBcbiAgICAvLyBPYnRlbmVyIGNhbGxiYWNrcyBwYXJhIGVzZSBuw7ptZXJvXG4gICAgY29uc3QgeyBkYXRhOiBjYWxsYmFja3MsIGVycm9yOiBjYWxsYmFja3NFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYWxsYmFja3MnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3RvX251bWJlcicsIHBob25lTnVtYmVyKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgXG4gICAgY29uc29sZS5sb2coYPCflIQgRW5jb250cmFkb3MgJHtjYWxsYmFja3M/Lmxlbmd0aCB8fCAwfSBjYWxsYmFja3MgcGFyYSAke3Bob25lTnVtYmVyfWApXG4gICAgXG4gICAgaWYgKGNhbGxiYWNrc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igb2J0ZW5pZW5kbyBjYWxsYmFja3M6JywgY2FsbGJhY2tzRXJyb3IpXG4gICAgICAvLyBObyBsYW56YW1vcyBlcnJvciwgc29sbyBsb2d1ZWFtb3NcbiAgICB9XG4gICAgXG4gICAgLy8gT2J0ZW5lciBkaXNwb3NpdGlvbnMgZGVsIFBDQSBwYXJhIGxhcyBjYWxsc1xuICAgIGxldCBwY2FNYXAgPSBuZXcgTWFwKClcbiAgICBsZXQgY2FsbGJhY2tNYXAgPSBuZXcgTWFwKClcbiAgICBcbiAgICBpZiAoY2FsbHMgJiYgY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2FsbElkcyA9IGNhbGxzLm1hcChjYWxsID0+IGNhbGwuY2FsbF9pZClcbiAgICAgIFxuICAgICAgLy8gT2J0ZW5lciBkaXNwb3NpdGlvbnMgZGVsIFBDQVxuICAgICAgY29uc3QgeyBkYXRhOiBwY2FEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGNhJylcbiAgICAgICAgLnNlbGVjdCgnY2FsbF9pZCwgZGlzcG9zaXRpb24nKVxuICAgICAgICAuaW4oJ2NhbGxfaWQnLCBjYWxsSWRzKVxuICAgICAgXG4gICAgICBpZiAocGNhRGF0YSkge1xuICAgICAgICBwY2FEYXRhLmZvckVhY2gocGNhID0+IHtcbiAgICAgICAgICBwY2FNYXAuc2V0KHBjYS5jYWxsX2lkLCBwY2EuZGlzcG9zaXRpb24pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE9idGVuZXIgY2FsbGJhY2tzIGFzb2NpYWRvcyBhIGVzdGFzIGNhbGxzXG4gICAgICBjb25zdCB7IGRhdGE6IGFzc29jaWF0ZWRDYWxsYmFja3MgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjYWxsYmFja3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmluKCdjYWxsX2lkJywgY2FsbElkcylcbiAgICAgIFxuICAgICAgaWYgKGFzc29jaWF0ZWRDYWxsYmFja3MpIHtcbiAgICAgICAgYXNzb2NpYXRlZENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbF9pZCkge1xuICAgICAgICAgICAgY2FsbGJhY2tNYXAuc2V0KGNhbGxiYWNrLmNhbGxfaWQsIGNhbGxiYWNrKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIENhbGxiYWNrICR7Y2FsbGJhY2suaWR9IG5vIHRpZW5lIGNhbGxfaWRgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCflJcgQ2FsbHMgY29uIGNhbGxiYWNrcyBhc29jaWFkb3M6ICR7QXJyYXkuZnJvbShjYWxsYmFja01hcC5rZXlzKCkpLmpvaW4oJywgJyl9YClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIFRvZG9zIGxvcyBjYWxsX2lkcyBkZSBjYWxsczogJHsoY2FsbHMgfHwgW10pLm1hcChjID0+IGMuY2FsbF9pZCkuam9pbignLCAnKX1gKVxuICAgICAgY29uc29sZS5sb2coYPCfk4sgVG9kb3MgbG9zIGNhbGxfaWRzIGRlIGNhbGxiYWNrczogJHsoY2FsbGJhY2tzIHx8IFtdKS5tYXAoYyA9PiBjLmNhbGxfaWQpLmpvaW4oJywgJyl9YClcbiAgICB9XG4gICAgXG4gICAgLy8gQ29tYmluYXIgeSBtYXJjYXIgZWwgdGlwbyAtIFNJTiBEVVBMSUNBUlxuICAgIGNvbnN0IGFsbEludGVyYWN0aW9uczogQ2FsbEludGVyYWN0aW9uW10gPSBbXG4gICAgICAvLyBQcm9jZXNhciBzb2xvIGxhcyBjYWxscyBxdWUgTk8gdGllbmVuIGNhbGxiYWNrIGFzb2NpYWRvIChtb3N0cmFybGFzIGNvbW8gY2FsbHMgbm9ybWFsZXMpXG4gICAgICAuLi4oY2FsbHMgfHwgW10pLmZpbHRlcihjYWxsID0+IHtcbiAgICAgICAgY29uc3QgaGFzQ2FsbGJhY2sgPSBjYWxsYmFja01hcC5oYXMoY2FsbC5jYWxsX2lkKVxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TniBDYWxsICR7Y2FsbC5jYWxsX2lkfTogZGlzcG9zaXRpb249XCIke2NhbGwuZGlzcG9zaXRpb259XCIsIGhhc0NhbGxiYWNrPSR7aGFzQ2FsbGJhY2t9YClcbiAgICAgICAgcmV0dXJuICFoYXNDYWxsYmFja1xuICAgICAgfSkubWFwKGNhbGwgPT4ge1xuICAgICAgICBjb25zdCBwY2FEaXNwb3NpdGlvbiA9IHBjYU1hcC5nZXQoY2FsbC5jYWxsX2lkKSB8fCBjYWxsLmRpc3Bvc2l0aW9uXG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgLi4uY2FsbCxcbiAgICAgICAgICB0eXBlOiAnY2FsbCcgYXMgY29uc3QsXG4gICAgICAgICAgZGF0ZTogY2FsbC5jYWxsX2lkLFxuICAgICAgICAgIGRpc3BsYXlfZGF0ZTogY2FsbC5jYWxsX2lkLFxuICAgICAgICAgIGRpc3Bvc2l0aW9uOiBwY2FEaXNwb3NpdGlvblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TniBDYWxsICR7Y2FsbC5jYWxsX2lkfTogZGlzcG9zaXRpb249XCIke3BjYURpc3Bvc2l0aW9ufVwiYClcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0pLFxuICAgICAgXG4gICAgICAvLyBQcm9jZXNhciBUT0RPUyBsb3MgY2FsbGJhY2tzIChpbmNsdXllIGxvcyBxdWUgdGllbmVuIGNhbGwgYXNvY2lhZGEgeSBsb3MgaW5kZXBlbmRpZW50ZXMpXG4gICAgICAuLi4oY2FsbGJhY2tzIHx8IFtdKS5tYXAoY2FsbGJhY2sgPT4ge1xuICAgICAgICBjb25zdCBhc3NvY2lhdGVkQ2FsbCA9IGNhbGxzPy5maW5kKGNhbGwgPT4gY2FsbC5jYWxsX2lkID09PSBjYWxsYmFjay5jYWxsX2lkKVxuICAgICAgICBjb25zdCBwY2FEaXNwb3NpdGlvbiA9IGFzc29jaWF0ZWRDYWxsID8gKHBjYU1hcC5nZXQoY2FsbGJhY2suY2FsbF9pZCkgfHwgYXNzb2NpYXRlZENhbGwuZGlzcG9zaXRpb24pIDogY2FsbGJhY2suZGlzcG9zaXRpb25cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAuLi5jYWxsYmFjayxcbiAgICAgICAgICB0eXBlOiAnY2FsbGJhY2snIGFzIGNvbnN0LFxuICAgICAgICAgIGRhdGU6IGNhbGxiYWNrLmNyZWF0ZWRfYXQgfHwgY2FsbGJhY2suaWQsXG4gICAgICAgICAgZGlzcGxheV9kYXRlOiBjYWxsYmFjay5jYWxsYmFja190aW1lIHx8IGNhbGxiYWNrLmNyZWF0ZWRfYXQgfHwgY2FsbGJhY2suaWQsXG4gICAgICAgICAgLy8gU2kgdGllbmUgY2FsbCBhc29jaWFkYSwgdXNhciBhbGd1bm9zIGRhdG9zIGRlIGxhIGNhbGwgKGNvbW8gYWRkcmVzcywgYnVzaW5lc3NfbmFtZSBvcmlnaW5hbClcbiAgICAgICAgICAuLi4oYXNzb2NpYXRlZENhbGwgPyB7XG4gICAgICAgICAgICBidXNpbmVzc19uYW1lOiBhc3NvY2lhdGVkQ2FsbC5idXNpbmVzc19uYW1lLFxuICAgICAgICAgICAgb3duZXJfbmFtZTogY2FsbGJhY2suY2FsbGJhY2tfb3duZXJfbmFtZSB8fCBhc3NvY2lhdGVkQ2FsbC5vd25lcl9uYW1lLFxuICAgICAgICAgICAgYWRkcmVzc19zdHJlZXQ6IGFzc29jaWF0ZWRDYWxsLmFkZHJlc3Nfc3RyZWV0LFxuICAgICAgICAgICAgYWRkcmVzc19jaXR5OiBhc3NvY2lhdGVkQ2FsbC5hZGRyZXNzX2NpdHksXG4gICAgICAgICAgICBhZGRyZXNzX3N0YXRlOiBhc3NvY2lhdGVkQ2FsbC5hZGRyZXNzX3N0YXRlLFxuICAgICAgICAgICAgb3duZXJfcGhvbmU6IGFzc29jaWF0ZWRDYWxsLm93bmVyX3Bob25lLFxuICAgICAgICAgICAgYWdyZWVkX2Ftb3VudDogYXNzb2NpYXRlZENhbGwuYWdyZWVkX2Ftb3VudCxcbiAgICAgICAgICAgIGRpc3Bvc2l0aW9uOiBwY2FEaXNwb3NpdGlvblxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBidXNpbmVzc19uYW1lOiBjYWxsYmFjay5idXNpbmVzc19uYW1lLFxuICAgICAgICAgICAgb3duZXJfbmFtZTogY2FsbGJhY2suY2FsbGJhY2tfb3duZXJfbmFtZSxcbiAgICAgICAgICAgIGFncmVlZF9hbW91bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRpc3Bvc2l0aW9uOiBjYWxsYmFjay5kaXNwb3NpdGlvblxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8vIEluZm9ybWFjacOzbiBlc3BlY8OtZmljYSBkZWwgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFja190aW1lOiBjYWxsYmFjay5jYWxsYmFja190aW1lLFxuICAgICAgICAgIGNhbGxiYWNrX293bmVyX25hbWU6IGNhbGxiYWNrLmNhbGxiYWNrX293bmVyX25hbWVcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgQ2FsbGJhY2sgJHtjYWxsYmFjay5pZCB8fCBjYWxsYmFjay5jYWxsX2lkfTogJHthc3NvY2lhdGVkQ2FsbCA/ICdjb24gY2FsbCBhc29jaWFkYScgOiAnaW5kZXBlbmRpZW50ZSd9LCBvd25lcj1cIiR7Y2FsbGJhY2suY2FsbGJhY2tfb3duZXJfbmFtZX1cImApXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KVxuICAgIF1cbiAgICBcbiAgICAvLyBPcmRlbmFyIHBvciBmZWNoYSAobcOhcyByZWNpZW50ZXMgcHJpbWVybylcbiAgICBhbGxJbnRlcmFjdGlvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuZGF0ZSA+IGIuZGF0ZSkgcmV0dXJuIC0xXG4gICAgICBpZiAoYS5kYXRlIDwgYi5kYXRlKSByZXR1cm4gMVxuICAgICAgcmV0dXJuIDBcbiAgICB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDinIUgUHJvY2VzYWRhcyAke2NhbGxzPy5sZW5ndGggfHwgMH0gbGxhbWFkYXMgKCR7KGNhbGxzIHx8IFtdKS5maWx0ZXIoY2FsbCA9PiAhY2FsbGJhY2tNYXAuaGFzKGNhbGwuY2FsbF9pZCkpLmxlbmd0aH0gY2FsbHMgKyAke2NhbGxiYWNrcz8ubGVuZ3RoIHx8IDB9IGNhbGxiYWNrcykgcGFyYSAke3Bob25lTnVtYmVyfWApXG4gICAgcmV0dXJuIGFsbEludGVyYWN0aW9uc1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBvYnRlbmllbmRvIGhpc3RvcmlhbCBjb21wbGV0bzonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgY29udGFyIGN1w6FudGFzIGxsYW1hZGFzIHRpZW5lIHVuIG7Dum1lcm9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsQ291bnRCeVBob25lKHBob25lTnVtYmVyOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnY2FsbHMnKVxuICAgIC5zZWxlY3QoJ2NhbGxfaWQnLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgLmVxKCd0b19udW1iZXInLCBwaG9uZU51bWJlcilcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBjb250YW5kbyBsbGFtYWRhczonLCBlcnJvcilcbiAgICByZXR1cm4gMFxuICB9XG4gIFxuICByZXR1cm4gY291bnQgfHwgMFxufVxuXG4vLyBGdW5jacOzbiBwYXJhIHZlcmlmaWNhciBzaSB1bmEgbGxhbWFkYSB0aWVuZSBoaXN0b3JpYWxcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNDYWxsSGlzdG9yeShjYWxsSWQ6IHN0cmluZyk6IFByb21pc2U8eyBoYXNIaXN0b3J5OiBib29sZWFuOyBjb3VudDogbnVtYmVyOyBwaG9uZU51bWJlcj86IHN0cmluZyB9PiB7XG4gIC8vIFByaW1lcm8gb2J0ZW5lbW9zIGVsIHRvX251bWJlciBkZSBsYSBsbGFtYWRhIGFjdHVhbFxuICBjb25zdCB7IGRhdGE6IGNhbGxEYXRhLCBlcnJvcjogY2FsbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdjYWxscycpXG4gICAgLnNlbGVjdCgndG9fbnVtYmVyJylcbiAgICAuZXEoJ2NhbGxfaWQnLCBjYWxsSWQpXG4gICAgLnNpbmdsZSgpXG4gIFxuICBpZiAoY2FsbEVycm9yIHx8ICFjYWxsRGF0YT8udG9fbnVtYmVyKSB7XG4gICAgcmV0dXJuIHsgaGFzSGlzdG9yeTogZmFsc2UsIGNvdW50OiAwIH1cbiAgfVxuICBcbiAgY29uc3QgcGhvbmVOdW1iZXIgPSBjYWxsRGF0YS50b19udW1iZXJcbiAgY29uc3QgY291bnQgPSBhd2FpdCBnZXRDYWxsQ291bnRCeVBob25lKHBob25lTnVtYmVyKVxuICBcbiAgcmV0dXJuIHsgXG4gICAgaGFzSGlzdG9yeTogY291bnQgPiAxLCBcbiAgICBjb3VudCxcbiAgICBwaG9uZU51bWJlciBcbiAgfVxufSJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1cGFiYXNlIiwiZ2V0Q2FsbHMiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJnZXRDYWxsc1dpdGhQQ0FJbmZvIiwiY2FsbHMiLCJjYWxsc0Vycm9yIiwiY29uc29sZSIsInBjYURhdGEiLCJwY2FFcnJvciIsImNhbGxzV2l0aFBDQSIsIlNldCIsIm1hcCIsInBjYSIsImNhbGxfaWQiLCJjYWxsIiwiaGFzUENBIiwiaGFzIiwiaGFzQ2FsbGJhY2tzIiwiZ2V0Q2FsbHNXaXRoUGFnaW5hdGlvbiIsInBhcmFtcyIsImxvZyIsInF1ZXJ5IiwiY291bnQiLCJzZWFyY2giLCJvciIsImZpbHRlcnMiLCJkaXNwb3NpdGlvbiIsImVxIiwic29ydEJ5Iiwic29ydE9yZGVyIiwib2Zmc2V0IiwicGFnZSIsImxpbWl0IiwicmFuZ2UiLCJsZW5ndGgiLCJ0b3RhbCIsInRvdGFsUGFnZXMiLCJNYXRoIiwiY2VpbCIsImNhbGxJZHMiLCJpbiIsImNhbGxiYWNrRGF0YSIsImNhbGxiYWNrRXJyb3IiLCJjYWxsYmFja093bmVyTWFwIiwiTWFwIiwiY2FsbGJhY2siLCJjYWxsYmFja19vd25lcl9uYW1lIiwiY2FsbHNXaXRoSW5mbyIsImNhbGxiYWNrT3duZXIiLCJnZXQiLCJvd25lcl9uYW1lIiwiZmlsdGVyZWRDYWxscyIsInVuZGVmaW5lZCIsImZpbHRlciIsImdldENhbGxiYWNrc0J5Q2FsbElkIiwiY2FsbElkIiwiZ2V0UENBQnlDYWxsSWQiLCJnZXRDYWxsRGV0YWlsc1dpdGhQQ0EiLCJjYWxsRGF0YSIsImNhbGxFcnJvciIsInNpbmdsZSIsImlzQ2FsbGJhY2siLCJnZXRBbGxQQ0EiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YUxlbmd0aCIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiaGludCIsImNvZGUiLCJzaW1wbGVEYXRhIiwic2ltcGxlRXJyb3IiLCJ0ZXN0UENBQWNjZXNzIiwiaGVhZCIsInRlc3RBbGxUYWJsZXNBY2Nlc3MiLCJ0YWJsZXMiLCJyZXN1bHRzIiwidGFibGUiLCJlcnIiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsImRpYWdub3NlUENBQWNjZXNzIiwidGVzdHMiLCJwdXNoIiwidGVzdCIsInN1Y2Nlc3MiLCJyZXN1bHQiLCJzYW1wbGVEYXRhIiwicnBjIiwiY3JlYXRlUENBUG9saWN5IiwiZ2V0TGVhZHMiLCJjYWxsc0RhdGEiLCJub3QiLCJwY2FNYXAiLCJmb3JFYWNoIiwic2V0IiwibGVhZHNNYXAiLCJ0b19udW1iZXIiLCJleGlzdGluZ0xlYWQiLCJwaG9uZV9udW1iZXIiLCJidXNpbmVzc19uYW1lIiwib3duZXJfZW1haWwiLCJsb2NhdGlvbl90eXBlIiwiYWRkcmVzc19zdHJlZXQiLCJhZGRyZXNzX2NpdHkiLCJhZGRyZXNzX3N0YXRlIiwiYWRkcmVzc196aXAiLCJ0b3RhbF9jYWxscyIsImxhc3RfY2FsbF9kYXRlIiwibGFzdF9kaXNwb3NpdGlvbiIsImFncmVlZF9hbW91bnQiLCJsZWFkcyIsIkFycmF5IiwidmFsdWVzIiwiZ2V0Q2FsbEhpc3RvcnlCeVBob25lIiwicGhvbmVOdW1iZXIiLCJjYWxsYmFja3MiLCJjYWxsYmFja3NFcnJvciIsImNhbGxiYWNrTWFwIiwiYXNzb2NpYXRlZENhbGxiYWNrcyIsImlkIiwia2V5cyIsImpvaW4iLCJjIiwiYWxsSW50ZXJhY3Rpb25zIiwiaGFzQ2FsbGJhY2siLCJwY2FEaXNwb3NpdGlvbiIsInR5cGUiLCJkYXRlIiwiZGlzcGxheV9kYXRlIiwiYXNzb2NpYXRlZENhbGwiLCJmaW5kIiwiY3JlYXRlZF9hdCIsImNhbGxiYWNrX3RpbWUiLCJvd25lcl9waG9uZSIsInNvcnQiLCJhIiwiYiIsImdldENhbGxDb3VudEJ5UGhvbmUiLCJoYXNDYWxsSGlzdG9yeSIsImhhc0hpc3RvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});