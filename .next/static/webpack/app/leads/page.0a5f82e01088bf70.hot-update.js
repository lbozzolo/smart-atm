"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/leads/page",{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPCAPolicy: function() { return /* binding */ createPCAPolicy; },\n/* harmony export */   diagnosePCAAccess: function() { return /* binding */ diagnosePCAAccess; },\n/* harmony export */   getAllPCA: function() { return /* binding */ getAllPCA; },\n/* harmony export */   getCallCountByPhone: function() { return /* binding */ getCallCountByPhone; },\n/* harmony export */   getCallDetailsWithPCA: function() { return /* binding */ getCallDetailsWithPCA; },\n/* harmony export */   getCallHistoryByPhone: function() { return /* binding */ getCallHistoryByPhone; },\n/* harmony export */   getCallbacksByCallId: function() { return /* binding */ getCallbacksByCallId; },\n/* harmony export */   getCalls: function() { return /* binding */ getCalls; },\n/* harmony export */   getCallsWithPCAInfo: function() { return /* binding */ getCallsWithPCAInfo; },\n/* harmony export */   getCallsWithPagination: function() { return /* binding */ getCallsWithPagination; },\n/* harmony export */   getLeads: function() { return /* binding */ getLeads; },\n/* harmony export */   getPCAByCallId: function() { return /* binding */ getPCAByCallId; },\n/* harmony export */   hasCallHistory: function() { return /* binding */ hasCallHistory; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   testAllTablesAccess: function() { return /* binding */ testAllTablesAccess; },\n/* harmony export */   testPCAAccess: function() { return /* binding */ testPCAAccess; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://rchgtacvdpavqkrceybo.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJjaGd0YWN2ZHBhdnFrcmNleWJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2OTUyODksImV4cCI6MjA3NjI3MTI4OX0.KZHdrA5sOrrDOUkMkG7H5b6Eb-yxPmrZQVXVBCuKVgg\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Función para obtener todas las llamadas\nasync function getCalls() {\n    const { data, error } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n        ascending: false\n    });\n    if (error) {\n        throw error;\n    }\n    return data;\n}\n// Función para obtener llamadas con información de si tienen PCA\nasync function getCallsWithPCAInfo() {\n    try {\n        // Primero obtenemos todas las llamadas\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"Error fetching calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls) return [];\n        // Luego obtenemos todos los call_ids que tienen PCA\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id\");\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        // No lanzamos error aquí, solo logueamos y continuamos sin PCA info\n        }\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        // Combinamos la información\n        return calls.map((call)=>({\n                ...call,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: false // Ya no usamos callbacks como concepto\n            }));\n    } catch (error) {\n        console.error(\"Error in getCallsWithPCAInfo:\", error);\n        throw error;\n    }\n}\n// Función NUEVA: Obtener llamadas con paginación en servidor (ESCALABLE)\nasync function getCallsWithPagination(params) {\n    try {\n        var _params_filters, _params_filters1;\n        console.log(\"\\uD83D\\uDD0D Obteniendo llamadas paginadas:\", params);\n        let query = supabase.from(\"calls\").select(\"*\", {\n            count: \"exact\"\n        });\n        // Aplicar filtros de búsqueda\n        if (params.search) {\n            query = query.or(\"business_name.ilike.%\".concat(params.search, \"%,owner_name.ilike.%\").concat(params.search, \"%,owner_phone.ilike.%\").concat(params.search, \"%\"));\n        }\n        // Aplicar filtros adicionales\n        if ((_params_filters = params.filters) === null || _params_filters === void 0 ? void 0 : _params_filters.disposition) {\n            query = query.eq(\"disposition\", params.filters.disposition);\n        }\n        // Aplicar ordenamiento\n        const sortBy = params.sortBy || \"call_id\";\n        const sortOrder = params.sortOrder === \"asc\" ? {\n            ascending: true\n        } : {\n            ascending: false\n        };\n        query = query.order(sortBy, sortOrder);\n        // Aplicar paginación\n        const offset = (params.page - 1) * params.limit;\n        query = query.range(offset, offset + params.limit - 1);\n        const { data: calls, count, error: callsError } = await query;\n        if (callsError) {\n            console.error(\"Error fetching paginated calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls || calls.length === 0) {\n            return {\n                data: [],\n                total: count || 0,\n                page: params.page,\n                limit: params.limit,\n                totalPages: Math.ceil((count || 0) / params.limit)\n            };\n        }\n        // Obtener información de PCA solo para las llamadas de esta página\n        const callIds = calls.map((call)=>call.call_id);\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id\").in(\"call_id\", callIds);\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        }\n        // Obtener callbacks asociados a estas calls\n        const { data: callbackData, error: callbackError } = await supabase.from(\"callbacks\").select(\"call_id, callback_owner_name, callback_owner_phone\").in(\"call_id\", callIds);\n        if (callbackError) {\n            console.error(\"Error fetching callback data:\", callbackError);\n        }\n        console.log(\"\\uD83D\\uDD0D Debug - Call IDs buscados:\", callIds);\n        console.log(\"\\uD83D\\uDD0D Debug - Callbacks encontrados:\", callbackData);\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        const callbackOwnerMap = new Map((callbackData || []).map((callback)=>[\n                callback.call_id,\n                {\n                    name: callback.callback_owner_name,\n                    phone: callback.callback_owner_phone\n                }\n            ]));\n        console.log(\"\\uD83D\\uDD0D Debug - Callback owner map:\", Array.from(callbackOwnerMap.entries()));\n        // Combinar información\n        const callsWithInfo = calls.map((call)=>{\n            const callbackInfo = callbackOwnerMap.get(call.call_id);\n            const finalOwnerName = (callbackInfo === null || callbackInfo === void 0 ? void 0 : callbackInfo.name) || call.owner_name;\n            const finalOwnerPhone = (callbackInfo === null || callbackInfo === void 0 ? void 0 : callbackInfo.phone) || call.owner_phone;\n            console.log(\"\\uD83D\\uDD0D Debug - Call \".concat(call.call_id, ': original_name=\"').concat(call.owner_name, '\", callback_name=\"').concat(callbackInfo === null || callbackInfo === void 0 ? void 0 : callbackInfo.name, '\", final_name=\"').concat(finalOwnerName, '\"'));\n            console.log(\"\\uD83D\\uDD0D Debug - Call \".concat(call.call_id, ': original_phone=\"').concat(call.owner_phone, '\", callback_phone=\"').concat(callbackInfo === null || callbackInfo === void 0 ? void 0 : callbackInfo.phone, '\", final_phone=\"').concat(finalOwnerPhone, '\"'));\n            return {\n                ...call,\n                // Si hay callback info, usar los datos del callback en lugar de los originales\n                owner_name: finalOwnerName,\n                owner_phone: finalOwnerPhone,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: callbackOwnerMap.has(call.call_id)\n            };\n        });\n        // Aplicar filtros post-query si es necesario\n        let filteredCalls = callsWithInfo;\n        if (((_params_filters1 = params.filters) === null || _params_filters1 === void 0 ? void 0 : _params_filters1.hasPCA) !== undefined) {\n            filteredCalls = filteredCalls.filter((call)=>call.hasPCA === params.filters.hasPCA);\n        }\n        const totalPages = Math.ceil((count || 0) / params.limit);\n        console.log(\"✅ Devolviendo \".concat(filteredCalls.length, \" llamadas (p\\xe1gina \").concat(params.page, \"/\").concat(totalPages, \") de \").concat(count, \" total\"));\n        return {\n            data: filteredCalls,\n            total: count || 0,\n            page: params.page,\n            limit: params.limit,\n            totalPages\n        };\n    } catch (error) {\n        console.error(\"Error in getCallsWithPagination:\", error);\n        throw error;\n    }\n}\n// Función para obtener callbacks por call_id\nasync function getCallbacksByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).order(\"callback_date\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching callbacks:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getCallbacksByCallId:\", error);\n        throw error;\n    }\n}\n// Función para obtener análisis PCA por call_id\nasync function getPCAByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"*\").eq(\"call_id\", callId).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching PCA data:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getPCAByCallId:\", error);\n        throw error;\n    }\n}\n// Nueva función para obtener información completa del cliente y análisis (calls y callbacks)\nasync function getCallDetailsWithPCA(callId) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCallDetailsWithPCA - buscando callId:\", callId);\n        // Obtener la llamada (siempre existe)\n        const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"\\uD83D\\uDCDE Resultado b\\xfasqueda en calls:\", {\n            callData,\n            callError\n        });\n        if (callError || !callData) {\n            console.error(\"❌ No se encontr\\xf3 la call con ID:\", callId);\n            return {\n                call: null,\n                pca: [],\n                isCallback: false\n            };\n        }\n        // Verificar si esta call tiene un callback asociado\n        const { data: callbackData, error: callbackError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"� Verificando si tiene callback asociado:\", {\n            callbackData,\n            callbackError\n        });\n        // Obtener PCA\n        const pcaData = await getPCAByCallId(callId);\n        if (callbackData && !callbackError) {\n            // Es una call que TAMBIÉN es un callback\n            console.log(\"✅ Call con callback asociado encontrado\");\n            return {\n                call: callData,\n                pca: pcaData,\n                isCallback: true,\n                callback: callbackData\n            };\n        } else {\n            // Es una call normal (sin callback)\n            console.log(\"✅ Call normal (sin callback)\");\n            return {\n                call: callData,\n                pca: pcaData,\n                isCallback: false\n            };\n        }\n    } catch (error) {\n        console.error(\"❌ Error in getCallDetailsWithPCA:\", error);\n        throw error;\n    }\n}\n// Función de debug para ver todos los PCA disponibles\nasync function getAllPCA() {\n    console.log(\"Intentando obtener todos los PCA...\");\n    // Primero intentamos sin límites\n    const { data, error, status, statusText } = await supabase.from(\"pca\").select(\"id, call_id, agent_name, created_at\").order(\"created_at\", {\n        ascending: false\n    });\n    console.log(\"Respuesta PCA:\", {\n        data,\n        error,\n        status,\n        statusText,\n        dataLength: (data === null || data === void 0 ? void 0 : data.length) || 0\n    });\n    if (error) {\n        console.error(\"Error detallado al obtener PCA:\", {\n            message: error.message,\n            details: error.details,\n            hint: error.hint,\n            code: error.code\n        });\n        // Intentamos con un query más simple\n        console.log(\"Intentando query m\\xe1s simple...\");\n        const { data: simpleData, error: simpleError } = await supabase.from(\"pca\").select(\"*\").limit(1);\n        console.log(\"Query simple resultado:\", {\n            simpleData,\n            simpleError\n        });\n        throw error;\n    }\n    console.log(\"PCA obtenidos exitosamente:\", data);\n    return data;\n}\n// Función de debug simple para verificar acceso a PCA\nasync function testPCAAccess() {\n    console.log(\"Testeando acceso a tabla PCA...\");\n    const { data, error, count } = await supabase.from(\"pca\").select(\"*\", {\n        count: \"exact\",\n        head: true\n    });\n    console.log(\"Test PCA - Count:\", count, \"Error:\", error);\n    return {\n        count,\n        error\n    };\n}\n// Función para verificar todas las tablas disponibles\nasync function testAllTablesAccess() {\n    const tables = [\n        \"calls\",\n        \"pca\",\n        \"callbacks\"\n    ];\n    const results = {};\n    for (const table of tables){\n        try {\n            console.log(\"Testeando tabla: \".concat(table));\n            const { data, error, count } = await supabase.from(table).select(\"*\", {\n                count: \"exact\",\n                head: true\n            });\n            results[table] = {\n                count,\n                error: (error === null || error === void 0 ? void 0 : error.message) || null\n            };\n            console.log(\"\".concat(table, \": \").concat(count, \" registros, error:\"), error === null || error === void 0 ? void 0 : error.message);\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Error desconocido\";\n            results[table] = {\n                count: 0,\n                error: errorMessage\n            };\n            console.error(\"Error en tabla \".concat(table, \":\"), err);\n        }\n    }\n    return results;\n}\n// Función específica para diagnosticar el problema de PCA\nasync function diagnosePCAAccess() {\n    console.log(\"\\uD83D\\uDD0D Diagnosticando acceso a tabla PCA...\");\n    const tests = [];\n    // Test 1: Count básico\n    try {\n        const { count, error } = await supabase.from(\"pca\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: !error,\n            result: \"Count: \".concat(count),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 2: Select simple con límite\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id\").limit(1);\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 3: Select específico\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id, call_id\").limit(3);\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message,\n            sampleData: data\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 4: Verificar si RLS está causando el problema\n    try {\n        // Intentamos hacer un query con bypass de RLS si es posible\n        const { data, error } = await supabase.rpc(\"get_pca_count\") // Esta función no existe, pero el error nos dará información\n        ;\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: !error,\n            result: \"RPC call\",\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: false,\n            result: \"RPC no disponible\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    console.log(\"\\uD83D\\uDCCA Resultados del diagn\\xf3stico:\", tests);\n    return tests;\n}\n// Función para crear una política temporal de RLS\nasync function createPCAPolicy() {\n    console.log(\"\\uD83D\\uDD27 Intentando crear pol\\xedtica de acceso para PCA...\");\n    try {\n        // Intentamos ejecutar un comando SQL para crear una política\n        const { data, error } = await supabase.rpc(\"create_pca_policy\");\n        return {\n            success: !error,\n            error: error === null || error === void 0 ? void 0 : error.message\n        };\n    } catch (err) {\n        return {\n            success: false,\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        };\n    }\n}\n// Función para obtener todos los leads (números únicos con su información más reciente)\nasync function getLeads() {\n    console.log(\"\\uD83D\\uDCDE Obteniendo todos los leads...\");\n    // Primero obtenemos todas las calls\n    const { data: callsData, error: callsError } = await supabase.from(\"calls\").select(\"*\").not(\"to_number\", \"is\", null).order(\"call_id\", {\n        ascending: false\n    });\n    if (callsError) {\n        console.error(\"❌ Error obteniendo calls:\", callsError);\n        throw callsError;\n    }\n    if (!callsData) return [];\n    // Obtener todas las dispositions del PCA para los call_ids\n    const callIds = callsData.map((call)=>call.call_id);\n    const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n    // Crear un mapa para acceso rápido a las dispositions del PCA\n    const pcaMap = new Map();\n    if (pcaData) {\n        pcaData.forEach((pca)=>{\n            pcaMap.set(pca.call_id, pca.disposition);\n        });\n    }\n    const data = callsData;\n    // Agrupamos por to_number y tomamos la información más reciente\n    const leadsMap = new Map();\n    for (const call of data){\n        if (!call.to_number) continue;\n        const existingLead = leadsMap.get(call.to_number);\n        if (!existingLead) {\n            // Primera vez que vemos este número\n            leadsMap.set(call.to_number, {\n                phone_number: call.to_number,\n                business_name: call.business_name,\n                owner_name: call.owner_name,\n                owner_email: call.owner_email,\n                location_type: call.location_type,\n                address_street: call.address_street,\n                address_city: call.address_city,\n                address_state: call.address_state,\n                address_zip: call.address_zip,\n                total_calls: 1,\n                last_call_date: call.call_id,\n                last_disposition: pcaMap.get(call.call_id) || call.disposition,\n                agreed_amount: call.agreed_amount\n            });\n        } else {\n            // Actualizamos el conteo\n            existingLead.total_calls++;\n            // Si esta llamada es más reciente (call_id mayor), actualizamos la info\n            if (call.call_id > existingLead.last_call_date) {\n                existingLead.business_name = call.business_name || existingLead.business_name;\n                existingLead.owner_name = call.owner_name || existingLead.owner_name;\n                existingLead.owner_email = call.owner_email || existingLead.owner_email;\n                existingLead.location_type = call.location_type || existingLead.location_type;\n                existingLead.address_street = call.address_street || existingLead.address_street;\n                existingLead.address_city = call.address_city || existingLead.address_city;\n                existingLead.address_state = call.address_state || existingLead.address_state;\n                existingLead.address_zip = call.address_zip || existingLead.address_zip;\n                existingLead.last_call_date = call.call_id;\n                existingLead.last_disposition = pcaMap.get(call.call_id) || call.disposition;\n                existingLead.agreed_amount = call.agreed_amount || existingLead.agreed_amount;\n            }\n        }\n    }\n    const leads = Array.from(leadsMap.values());\n    console.log(\"✅ Encontrados \".concat(leads.length, \" leads \\xfanicos\"));\n    return leads;\n}\n// Función para obtener historial completo (calls + callbacks) por número de teléfono\nasync function getCallHistoryByPhone(phoneNumber) {\n    console.log(\"\\uD83D\\uDCDE Obteniendo historial completo para: \".concat(phoneNumber));\n    try {\n        // Obtener llamadas regulares\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"❌ Error obteniendo llamadas:\", callsError);\n            throw callsError;\n        }\n        console.log(\"\\uD83D\\uDCDE Encontradas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas para \").concat(phoneNumber));\n        // Obtener callbacks para ese número\n        const { data: callbacks, error: callbacksError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"\\uD83D\\uDD04 Encontrados \".concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks para \").concat(phoneNumber));\n        if (callbacksError) {\n            console.error(\"❌ Error obteniendo callbacks:\", callbacksError);\n        // No lanzamos error, solo logueamos\n        }\n        // Obtener dispositions del PCA para las calls\n        let pcaMap = new Map();\n        let callbackMap = new Map();\n        if (calls && calls.length > 0) {\n            const callIds = calls.map((call)=>call.call_id);\n            // Obtener dispositions del PCA\n            const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n            if (pcaData) {\n                pcaData.forEach((pca)=>{\n                    pcaMap.set(pca.call_id, pca.disposition);\n                });\n            }\n            // Obtener callbacks asociados a estas calls\n            const { data: associatedCallbacks } = await supabase.from(\"callbacks\").select(\"*\").in(\"call_id\", callIds);\n            if (associatedCallbacks) {\n                associatedCallbacks.forEach((callback)=>{\n                    if (callback.call_id) {\n                        callbackMap.set(callback.call_id, callback);\n                    } else {\n                        console.log(\"⚠️ Callback \".concat(callback.id, \" no tiene call_id\"));\n                    }\n                });\n            }\n            console.log(\"\\uD83D\\uDD17 Calls con callbacks asociados: \".concat(Array.from(callbackMap.keys()).join(\", \")));\n            console.log(\"\\uD83D\\uDCCB Todos los call_ids de calls: \".concat((calls || []).map((c)=>c.call_id).join(\", \")));\n            console.log(\"\\uD83D\\uDCCB Todos los call_ids de callbacks: \".concat((callbacks || []).map((c)=>c.call_id).join(\", \")));\n        }\n        // Combinar y marcar el tipo - SIN DUPLICAR\n        const allInteractions = [\n            // Procesar solo las calls que NO tienen callback asociado (mostrarlas como calls normales)\n            ...(calls || []).filter((call)=>{\n                const hasCallback = callbackMap.has(call.call_id);\n                console.log(\"\\uD83D\\uDCDE Call \".concat(call.call_id, ': disposition=\"').concat(call.disposition, '\", hasCallback=').concat(hasCallback));\n                return !hasCallback;\n            }).map((call)=>{\n                const pcaDisposition = pcaMap.get(call.call_id) || call.disposition;\n                const result = {\n                    ...call,\n                    type: \"call\",\n                    date: call.call_id,\n                    display_date: call.call_id,\n                    disposition: pcaDisposition\n                };\n                console.log(\"\\uD83D\\uDCDE Call \".concat(call.call_id, ': disposition=\"').concat(pcaDisposition, '\"'));\n                return result;\n            }),\n            // Procesar TODOS los callbacks (incluye los que tienen call asociada y los independientes)\n            ...(callbacks || []).map((callback)=>{\n                const associatedCall = calls === null || calls === void 0 ? void 0 : calls.find((call)=>call.call_id === callback.call_id);\n                const pcaDisposition = associatedCall ? pcaMap.get(callback.call_id) || associatedCall.disposition : callback.disposition;\n                const result = {\n                    ...callback,\n                    type: \"callback\",\n                    date: callback.created_at || callback.id,\n                    display_date: callback.callback_time || callback.created_at || callback.id,\n                    // Si tiene call asociada, usar algunos datos de la call (como address, business_name original)\n                    ...associatedCall ? {\n                        business_name: associatedCall.business_name,\n                        owner_name: callback.callback_owner_name || associatedCall.owner_name,\n                        address_street: associatedCall.address_street,\n                        address_city: associatedCall.address_city,\n                        address_state: associatedCall.address_state,\n                        owner_phone: associatedCall.owner_phone,\n                        agreed_amount: associatedCall.agreed_amount,\n                        disposition: pcaDisposition\n                    } : {\n                        business_name: callback.business_name,\n                        owner_name: callback.callback_owner_name,\n                        agreed_amount: undefined,\n                        disposition: callback.disposition\n                    },\n                    // Información específica del callback\n                    callback_time: callback.callback_time,\n                    callback_owner_name: callback.callback_owner_name\n                };\n                console.log(\"\\uD83D\\uDD04 Callback \".concat(callback.id || callback.call_id, \": \").concat(associatedCall ? \"con call asociada\" : \"independiente\", ', owner=\"').concat(callback.callback_owner_name, '\"'));\n                return result;\n            })\n        ];\n        // Ordenar por fecha (más recientes primero)\n        allInteractions.sort((a, b)=>{\n            if (a.date > b.date) return -1;\n            if (a.date < b.date) return 1;\n            return 0;\n        });\n        console.log(\"✅ Procesadas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas (\").concat((calls || []).filter((call)=>!callbackMap.has(call.call_id)).length, \" calls + \").concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks) para \").concat(phoneNumber));\n        return allInteractions;\n    } catch (error) {\n        console.error(\"❌ Error obteniendo historial completo:\", error);\n        throw error;\n    }\n}\n// Función para contar cuántas llamadas tiene un número\nasync function getCallCountByPhone(phoneNumber) {\n    const { count, error } = await supabase.from(\"calls\").select(\"call_id\", {\n        count: \"exact\",\n        head: true\n    }).eq(\"to_number\", phoneNumber);\n    if (error) {\n        console.error(\"❌ Error contando llamadas:\", error);\n        return 0;\n    }\n    return count || 0;\n}\n// Función para verificar si una llamada tiene historial\nasync function hasCallHistory(callId) {\n    // Primero obtenemos el to_number de la llamada actual\n    const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"to_number\").eq(\"call_id\", callId).single();\n    if (callError || !(callData === null || callData === void 0 ? void 0 : callData.to_number)) {\n        return {\n            hasHistory: false,\n            count: 0\n        };\n    }\n    const phoneNumber = callData.to_number;\n    const count = await getCallCountByPhone(phoneNumber);\n    return {\n        hasHistory: count > 1,\n        count,\n        phoneNumber\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDb0Q7QUFFcEQsTUFBTUMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBRTFELE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSSxpQkFBZ0I7QUE0RmxFLDBDQUEwQztBQUNuQyxlQUFlRztJQUNwQixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUgsU0FDM0JJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDLFdBQVc7UUFBRUMsV0FBVztJQUFNO0lBRXZDLElBQUlKLE9BQU87UUFDVCxNQUFNQTtJQUNSO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLGlFQUFpRTtBQUMxRCxlQUFlTTtJQUNwQixJQUFJO1FBQ0YsdUNBQXVDO1FBQ3ZDLE1BQU0sRUFBRU4sTUFBTU8sS0FBSyxFQUFFTixPQUFPTyxVQUFVLEVBQUUsR0FBRyxNQUFNVixTQUM5Q0ksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUMsV0FBVztZQUFFQyxXQUFXO1FBQU07UUFFdkMsSUFBSUcsWUFBWTtZQUNkQyxRQUFRUixLQUFLLENBQUMseUJBQXlCTztZQUN2QyxNQUFNQTtRQUNSO1FBRUEsSUFBSSxDQUFDRCxPQUFPLE9BQU8sRUFBRTtRQUVyQixvREFBb0Q7UUFDcEQsTUFBTSxFQUFFUCxNQUFNVSxPQUFPLEVBQUVULE9BQU9VLFFBQVEsRUFBRSxHQUFHLE1BQU1iLFNBQzlDSSxJQUFJLENBQUMsT0FDTEMsTUFBTSxDQUFDO1FBRVYsSUFBSVEsVUFBVTtZQUNaRixRQUFRUixLQUFLLENBQUMsNEJBQTRCVTtRQUMxQyxvRUFBb0U7UUFDdEU7UUFFQSxNQUFNQyxlQUFlLElBQUlDLElBQUlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksR0FBRyxDQUFD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LFNBQVMsRUFBRSxHQUFHLE1BQU14RSxTQUNoREksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxhQUNQMkIsRUFBRSxDQUFDLFdBQVdvQyxRQUNkSyxNQUFNO0lBRVQsSUFBSUQsYUFBYSxFQUFDRCxxQkFBQUEsK0JBQUFBLFNBQVV1QyxTQUFTLEdBQUU7UUFDckMsT0FBTztZQUFFeUMsWUFBWTtZQUFPNUgsT0FBTztRQUFFO0lBQ3ZDO0lBRUEsTUFBTW9HLGNBQWN4RCxTQUFTdUMsU0FBUztJQUN0QyxNQUFNbkYsUUFBUSxNQUFNMEgsb0JBQW9CdEI7SUFFeEMsT0FBTztRQUNMd0IsWUFBWTVILFFBQVE7UUFDcEJBO1FBQ0FvRztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zdXBhYmFzZS50cz8wNmUxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuXG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCFcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIVxuXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSlcblxuLy8gRGVmaW5pciBlbCB0aXBvIGRlIGRhdG9zIHBhcmEgbGEgdGFibGEgY2FsbHNcbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbCB7XG4gIGNhbGxfaWQ6IHN0cmluZ1xuICBhZ2VudF9pZD86IHN0cmluZ1xuICBhZ2VudF9uYW1lPzogc3RyaW5nXG4gIHRyYW5zY3JpcHQ/OiBzdHJpbmdcbiAgZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgYnVzaW5lc3NfbmFtZT86IHN0cmluZ1xuICBvd25lcl9uYW1lPzogc3RyaW5nXG4gIG93bmVyX3Bob25lPzogc3RyaW5nXG4gIG93bmVyX2VtYWlsPzogc3RyaW5nXG4gIGxvY2F0aW9uX3R5cGU/OiBzdHJpbmdcbiAgYWRkcmVzc19zdHJlZXQ/OiBzdHJpbmdcbiAgYWRkcmVzc19jaXR5Pzogc3RyaW5nXG4gIGFkZHJlc3Nfc3RhdGU/OiBzdHJpbmdcbiAgYWRkcmVzc196aXA/OiBzdHJpbmdcbiAgYWdyZWVkX2Ftb3VudD86IG51bWJlclxuICBtb250aGx5X2Ftb3VudD86IG51bWJlclxuICB5ZWFybHlfYW1vdW50PzogbnVtYmVyXG4gIGNvbXBhbnlfa2V5Pzogc3RyaW5nXG4gIGFnZW50X2V4dGVybmFsX2lkPzogc3RyaW5nXG4gIGFkZHJlc3NfbGluZTI/OiBzdHJpbmdcbiAgYnVzaW5lc3NfaG91cnM/OiBzdHJpbmdcbiAgb3RoZXJfbG9jYXRpb25zPzogc3RyaW5nXG4gIGZyb21fbnVtYmVyPzogc3RyaW5nXG4gIHRvX251bWJlcj86IHN0cmluZ1xufVxuXG4vLyBUaXBvIGV4dGVuZGlkbyBwYXJhIGxsYW1hZGFzIGNvbiBpbmZvcm1hY2nDs24gZGUgUENBXG5leHBvcnQgaW50ZXJmYWNlIENhbGxXaXRoUENBSW5mbyBleHRlbmRzIENhbGwge1xuICBoYXNQQ0E6IGJvb2xlYW5cbiAgaGFzQ2FsbGJhY2tzPzogYm9vbGVhblxufVxuXG4vLyBEZWZpbmlyIGVsIHRpcG8gZGUgZGF0b3MgcGFyYSBsYSB0YWJsYSBjYWxsYmFja3NcbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbGJhY2sge1xuICBpZDogc3RyaW5nXG4gIGlkX3V1aWRfb2xkOiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBsZWFkX2lkPzogc3RyaW5nXG4gIGNhbGxfaWQ/OiBzdHJpbmdcbiAgY29tcGFueV9pZD86IHN0cmluZ1xuICBhZ2VudF9pZD86IHN0cmluZ1xuICBkaXNwb3NpdGlvbj86IHN0cmluZ1xuICBjYWxsYmFja19vd25lcl9uYW1lOiBzdHJpbmdcbiAgY2FsbGJhY2tfdGltZT86IHN0cmluZ1xuICBjYWxsYmFja193aW5kb3dfbm90ZT86IHN0cmluZ1xuICBwYXlsb2FkPzogYW55XG4gIGFnZW50X2V4dGVybmFsX2lkPzogc3RyaW5nXG4gIGxlYWRfc3RhdGU/OiBzdHJpbmdcbiAgbGVhZF9jaXR5Pzogc3RyaW5nXG4gIGxlYWRfemlwPzogc3RyaW5nXG4gIGNhbGxfc3RhcnRlZF9hdD86IHN0cmluZ1xuICBjYWxsZXJfdHo/OiBzdHJpbmdcbiAgdHpfYW1iaWd1b3VzPzogYm9vbGVhblxuICBjYWxsYmFja190aW1lX3RleHRfcmF3Pzogc3RyaW5nXG4gIGV2ZW50X3R5cGU/OiBzdHJpbmdcbiAgZnJvbV9udW1iZXI/OiBzdHJpbmdcbiAgdG9fbnVtYmVyPzogc3RyaW5nXG59XG5cbi8vIERlZmluaXIgZWwgdGlwbyBkZSBkYXRvcyBwYXJhIGxhIHRhYmxhIHBjYVxuZXhwb3J0IGludGVyZmFjZSBQQ0Ege1xuICBpZDogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICBjYWxsX2lkOiBzdHJpbmdcbiAgYWdlbnRfbmFtZT86IHN0cmluZ1xuICBkaXNwb3NpdGlvbj86IHN0cmluZ1xuICBjYWxsX3N1Y2Nlc3NmdWw/OiBib29sZWFuXG4gIHVzZXJfc2VudGltZW50Pzogc3RyaW5nXG4gIGR1cmF0aW9uX21zPzogbnVtYmVyXG4gIHN0YXJ0X3RpbWVzdGFtcD86IHN0cmluZ1xuICBlbmRfdGltZXN0YW1wPzogc3RyaW5nXG4gIGRpc2Nvbm5lY3Rpb25fcmVhc29uPzogc3RyaW5nXG4gIGNhbGxfc3VtbWFyeT86IHN0cmluZ1xuICB0cmFuc2NyaXB0Pzogc3RyaW5nXG4gIHJlY29yZGluZ191cmw/OiBzdHJpbmdcbiAgcmVjb3JkaW5nX211bHRpX2NoYW5uZWxfdXJsPzogc3RyaW5nXG4gIHB1YmxpY19sb2dfdXJsPzogc3RyaW5nXG4gIGNhbGxfY29zdD86IG51bWJlclxuICBhbmFseXNpcz86IGFueVxuICBjdXN0b21fYW5hbHlzaXNfZGF0YT86IGFueVxuICBsbG1fdG9rZW5fdXNhZ2U/OiBhbnlcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIGFnZW50X2V4dGVybmFsX2lkPzogc3RyaW5nXG4gIGZyb21fbnVtYmVyPzogc3RyaW5nXG4gIHRvX251bWJlcj86IHN0cmluZ1xufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgdG9kYXMgbGFzIGxsYW1hZGFzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbHMoKSB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2NhbGxzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAub3JkZXIoJ2NhbGxfaWQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgcmV0dXJuIGRhdGEgYXMgQ2FsbFtdXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBsbGFtYWRhcyBjb24gaW5mb3JtYWNpw7NuIGRlIHNpIHRpZW5lbiBQQ0FcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsc1dpdGhQQ0FJbmZvKCk6IFByb21pc2U8Q2FsbFdpdGhQQ0FJbmZvW10+IHtcbiAgdHJ5IHtcbiAgICAvLyBQcmltZXJvIG9idGVuZW1vcyB0b2RhcyBsYXMgbGxhbWFkYXNcbiAgICBjb25zdCB7IGRhdGE6IGNhbGxzLCBlcnJvcjogY2FsbHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYWxscycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5vcmRlcignY2FsbF9pZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgaWYgKGNhbGxzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNhbGxzOicsIGNhbGxzRXJyb3IpXG4gICAgICB0aHJvdyBjYWxsc0Vycm9yXG4gICAgfVxuXG4gICAgaWYgKCFjYWxscykgcmV0dXJuIFtdXG5cbiAgICAvLyBMdWVnbyBvYnRlbmVtb3MgdG9kb3MgbG9zIGNhbGxfaWRzIHF1ZSB0aWVuZW4gUENBXG4gICAgY29uc3QgeyBkYXRhOiBwY2FEYXRhLCBlcnJvcjogcGNhRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJ2NhbGxfaWQnKVxuXG4gICAgaWYgKHBjYUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBQQ0EgZGF0YTonLCBwY2FFcnJvcilcbiAgICAgIC8vIE5vIGxhbnphbW9zIGVycm9yIGFxdcOtLCBzb2xvIGxvZ3VlYW1vcyB5IGNvbnRpbnVhbW9zIHNpbiBQQ0EgaW5mb1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxzV2l0aFBDQSA9IG5ldyBTZXQocGNhRGF0YT8ubWFwKHBjYSA9PiBwY2EuY2FsbF9pZCkgfHwgW10pXG5cbiAgICAvLyBDb21iaW5hbW9zIGxhIGluZm9ybWFjacOzblxuICAgIHJldHVybiBjYWxscy5tYXAoY2FsbCA9PiAoe1xuICAgICAgLi4uY2FsbCxcbiAgICAgIGhhc1BDQTogY2FsbHNXaXRoUENBLmhhcyhjYWxsLmNhbGxfaWQpLFxuICAgICAgaGFzQ2FsbGJhY2tzOiBmYWxzZSAvLyBZYSBubyB1c2Ftb3MgY2FsbGJhY2tzIGNvbW8gY29uY2VwdG9cbiAgICB9KSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDYWxsc1dpdGhQQ0FJbmZvOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8g8J+TiiBQQUdJTkFDScOTTiBFU0NBTEFCTEUgUEFSQSBQUk9EVUNDScOTTlxuXG4vLyBJbnRlcmZheiBwYXJhIHBhcsOhbWV0cm9zIGRlIHBhZ2luYWNpw7NuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRpb25QYXJhbXMge1xuICBwYWdlOiBudW1iZXJcbiAgbGltaXQ6IG51bWJlclxuICBzZWFyY2g/OiBzdHJpbmdcbiAgZmlsdGVycz86IHtcbiAgICBoYXNQQ0E/OiBib29sZWFuXG4gICAgZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgfVxuICBzb3J0Qnk/OiBzdHJpbmdcbiAgc29ydE9yZGVyPzogJ2FzYycgfCAnZGVzYydcbn1cblxuLy8gSW50ZXJmYXogcGFyYSByZXNwdWVzdGEgcGFnaW5hZGFcbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGVkUmVzcG9uc2U8VD4ge1xuICBkYXRhOiBUW11cbiAgdG90YWw6IG51bWJlclxuICBwYWdlOiBudW1iZXJcbiAgbGltaXQ6IG51bWJlclxuICB0b3RhbFBhZ2VzOiBudW1iZXJcbn1cblxuLy8gRnVuY2nDs24gTlVFVkE6IE9idGVuZXIgbGxhbWFkYXMgY29uIHBhZ2luYWNpw7NuIGVuIHNlcnZpZG9yIChFU0NBTEFCTEUpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbHNXaXRoUGFnaW5hdGlvbihwYXJhbXM6IFBhZ2luYXRpb25QYXJhbXMpOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPENhbGxXaXRoUENBSW5mbz4+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBPYnRlbmllbmRvIGxsYW1hZGFzIHBhZ2luYWRhczonLCBwYXJhbXMpXG4gICAgXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYWxscycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KVxuXG4gICAgLy8gQXBsaWNhciBmaWx0cm9zIGRlIGLDunNxdWVkYVxuICAgIGlmIChwYXJhbXMuc2VhcmNoKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5Lm9yKGBidXNpbmVzc19uYW1lLmlsaWtlLiUke3BhcmFtcy5zZWFyY2h9JSxvd25lcl9uYW1lLmlsaWtlLiUke3BhcmFtcy5zZWFyY2h9JSxvd25lcl9waG9uZS5pbGlrZS4lJHtwYXJhbXMuc2VhcmNofSVgKVxuICAgIH1cblxuICAgIC8vIEFwbGljYXIgZmlsdHJvcyBhZGljaW9uYWxlc1xuICAgIGlmIChwYXJhbXMuZmlsdGVycz8uZGlzcG9zaXRpb24pIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2Rpc3Bvc2l0aW9uJywgcGFyYW1zLmZpbHRlcnMuZGlzcG9zaXRpb24pXG4gICAgfVxuXG4gICAgLy8gQXBsaWNhciBvcmRlbmFtaWVudG9cbiAgICBjb25zdCBzb3J0QnkgPSBwYXJhbXMuc29ydEJ5IHx8ICdjYWxsX2lkJ1xuICAgIGNvbnN0IHNvcnRPcmRlciA9IHBhcmFtcy5zb3J0T3JkZXIgPT09ICdhc2MnID8geyBhc2NlbmRpbmc6IHRydWUgfSA6IHsgYXNjZW5kaW5nOiBmYWxzZSB9XG4gICAgcXVlcnkgPSBxdWVyeS5vcmRlcihzb3J0QnksIHNvcnRPcmRlcilcblxuICAgIC8vIEFwbGljYXIgcGFnaW5hY2nDs25cbiAgICBjb25zdCBvZmZzZXQgPSAocGFyYW1zLnBhZ2UgLSAxKSAqIHBhcmFtcy5saW1pdFxuICAgIHF1ZXJ5ID0gcXVlcnkucmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyBwYXJhbXMubGltaXQgLSAxKVxuXG4gICAgY29uc3QgeyBkYXRhOiBjYWxscywgY291bnQsIGVycm9yOiBjYWxsc0Vycm9yIH0gPSBhd2FpdCBxdWVyeVxuXG4gICAgaWYgKGNhbGxzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBhZ2luYXRlZCBjYWxsczonLCBjYWxsc0Vycm9yKVxuICAgICAgdGhyb3cgY2FsbHNFcnJvclxuICAgIH1cblxuICAgIGlmICghY2FsbHMgfHwgY2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgdG90YWw6IGNvdW50IHx8IDAsXG4gICAgICAgIHBhZ2U6IHBhcmFtcy5wYWdlLFxuICAgICAgICBsaW1pdDogcGFyYW1zLmxpbWl0LFxuICAgICAgICB0b3RhbFBhZ2VzOiBNYXRoLmNlaWwoKGNvdW50IHx8IDApIC8gcGFyYW1zLmxpbWl0KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9idGVuZXIgaW5mb3JtYWNpw7NuIGRlIFBDQSBzb2xvIHBhcmEgbGFzIGxsYW1hZGFzIGRlIGVzdGEgcMOhZ2luYVxuICAgIGNvbnN0IGNhbGxJZHMgPSBjYWxscy5tYXAoY2FsbCA9PiBjYWxsLmNhbGxfaWQpXG4gICAgY29uc3QgeyBkYXRhOiBwY2FEYXRhLCBlcnJvcjogcGNhRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJ2NhbGxfaWQnKVxuICAgICAgLmluKCdjYWxsX2lkJywgY2FsbElkcylcblxuICAgIGlmIChwY2FFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgUENBIGRhdGE6JywgcGNhRXJyb3IpXG4gICAgfVxuXG4gICAgLy8gT2J0ZW5lciBjYWxsYmFja3MgYXNvY2lhZG9zIGEgZXN0YXMgY2FsbHNcbiAgICBjb25zdCB7IGRhdGE6IGNhbGxiYWNrRGF0YSwgZXJyb3I6IGNhbGxiYWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbGJhY2tzJylcbiAgICAgIC5zZWxlY3QoJ2NhbGxfaWQsIGNhbGxiYWNrX293bmVyX25hbWUsIGNhbGxiYWNrX293bmVyX3Bob25lJylcbiAgICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG5cbiAgICBpZiAoY2FsbGJhY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FsbGJhY2sgZGF0YTonLCBjYWxsYmFja0Vycm9yKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5SNIERlYnVnIC0gQ2FsbCBJRHMgYnVzY2Fkb3M6JywgY2FsbElkcylcbiAgICBjb25zb2xlLmxvZygn8J+UjSBEZWJ1ZyAtIENhbGxiYWNrcyBlbmNvbnRyYWRvczonLCBjYWxsYmFja0RhdGEpXG5cbiAgICBjb25zdCBjYWxsc1dpdGhQQ0EgPSBuZXcgU2V0KHBjYURhdGE/Lm1hcChwY2EgPT4gcGNhLmNhbGxfaWQpIHx8IFtdKVxuICAgIGNvbnN0IGNhbGxiYWNrT3duZXJNYXAgPSBuZXcgTWFwKFxuICAgICAgKGNhbGxiYWNrRGF0YSB8fCBbXSkubWFwKGNhbGxiYWNrID0+IFtjYWxsYmFjay5jYWxsX2lkLCB7IFxuICAgICAgICBuYW1lOiBjYWxsYmFjay5jYWxsYmFja19vd25lcl9uYW1lLCBcbiAgICAgICAgcGhvbmU6IGNhbGxiYWNrLmNhbGxiYWNrX293bmVyX3Bob25lIFxuICAgICAgfV0pXG4gICAgKVxuXG4gICAgY29uc29sZS5sb2coJ/CflI0gRGVidWcgLSBDYWxsYmFjayBvd25lciBtYXA6JywgQXJyYXkuZnJvbShjYWxsYmFja093bmVyTWFwLmVudHJpZXMoKSkpXG5cbiAgICAvLyBDb21iaW5hciBpbmZvcm1hY2nDs25cbiAgICBjb25zdCBjYWxsc1dpdGhJbmZvOiBDYWxsV2l0aFBDQUluZm9bXSA9IGNhbGxzLm1hcChjYWxsID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrSW5mbyA9IGNhbGxiYWNrT3duZXJNYXAuZ2V0KGNhbGwuY2FsbF9pZClcbiAgICAgIGNvbnN0IGZpbmFsT3duZXJOYW1lID0gY2FsbGJhY2tJbmZvPy5uYW1lIHx8IGNhbGwub3duZXJfbmFtZVxuICAgICAgY29uc3QgZmluYWxPd25lclBob25lID0gY2FsbGJhY2tJbmZvPy5waG9uZSB8fCBjYWxsLm93bmVyX3Bob25lXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIERlYnVnIC0gQ2FsbCAke2NhbGwuY2FsbF9pZH06IG9yaWdpbmFsX25hbWU9XCIke2NhbGwub3duZXJfbmFtZX1cIiwgY2FsbGJhY2tfbmFtZT1cIiR7Y2FsbGJhY2tJbmZvPy5uYW1lfVwiLCBmaW5hbF9uYW1lPVwiJHtmaW5hbE93bmVyTmFtZX1cImApXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBEZWJ1ZyAtIENhbGwgJHtjYWxsLmNhbGxfaWR9OiBvcmlnaW5hbF9waG9uZT1cIiR7Y2FsbC5vd25lcl9waG9uZX1cIiwgY2FsbGJhY2tfcGhvbmU9XCIke2NhbGxiYWNrSW5mbz8ucGhvbmV9XCIsIGZpbmFsX3Bob25lPVwiJHtmaW5hbE93bmVyUGhvbmV9XCJgKVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jYWxsLFxuICAgICAgICAvLyBTaSBoYXkgY2FsbGJhY2sgaW5mbywgdXNhciBsb3MgZGF0b3MgZGVsIGNhbGxiYWNrIGVuIGx1Z2FyIGRlIGxvcyBvcmlnaW5hbGVzXG4gICAgICAgIG93bmVyX25hbWU6IGZpbmFsT3duZXJOYW1lLFxuICAgICAgICBvd25lcl9waG9uZTogZmluYWxPd25lclBob25lLFxuICAgICAgICBoYXNQQ0E6IGNhbGxzV2l0aFBDQS5oYXMoY2FsbC5jYWxsX2lkKSxcbiAgICAgICAgaGFzQ2FsbGJhY2tzOiBjYWxsYmFja093bmVyTWFwLmhhcyhjYWxsLmNhbGxfaWQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEFwbGljYXIgZmlsdHJvcyBwb3N0LXF1ZXJ5IHNpIGVzIG5lY2VzYXJpb1xuICAgIGxldCBmaWx0ZXJlZENhbGxzID0gY2FsbHNXaXRoSW5mb1xuICAgIGlmIChwYXJhbXMuZmlsdGVycz8uaGFzUENBICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbHRlcmVkQ2FsbHMgPSBmaWx0ZXJlZENhbGxzLmZpbHRlcihjYWxsID0+IGNhbGwuaGFzUENBID09PSBwYXJhbXMuZmlsdGVycyEuaGFzUENBKVxuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwoKGNvdW50IHx8IDApIC8gcGFyYW1zLmxpbWl0KVxuXG4gICAgY29uc29sZS5sb2coYOKchSBEZXZvbHZpZW5kbyAke2ZpbHRlcmVkQ2FsbHMubGVuZ3RofSBsbGFtYWRhcyAocMOhZ2luYSAke3BhcmFtcy5wYWdlfS8ke3RvdGFsUGFnZXN9KSBkZSAke2NvdW50fSB0b3RhbGApXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGZpbHRlcmVkQ2FsbHMsXG4gICAgICB0b3RhbDogY291bnQgfHwgMCxcbiAgICAgIHBhZ2U6IHBhcmFtcy5wYWdlLFxuICAgICAgbGltaXQ6IHBhcmFtcy5saW1pdCxcbiAgICAgIHRvdGFsUGFnZXNcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2FsbHNXaXRoUGFnaW5hdGlvbjonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBjYWxsYmFja3MgcG9yIGNhbGxfaWRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsYmFja3NCeUNhbGxJZChjYWxsSWQ6IHN0cmluZyk6IFByb21pc2U8Q2FsbGJhY2tbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbGJhY2tzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdjYWxsX2lkJywgY2FsbElkKVxuICAgICAgLm9yZGVyKCdjYWxsYmFja19kYXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNhbGxiYWNrczonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDYWxsYmFja3NCeUNhbGxJZDonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBhbsOhbGlzaXMgUENBIHBvciBjYWxsX2lkXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UENBQnlDYWxsSWQoY2FsbElkOiBzdHJpbmcpOiBQcm9taXNlPFBDQVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NhbGxfaWQnLCBjYWxsSWQpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgUENBIGRhdGE6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0UENBQnlDYWxsSWQ6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBOdWV2YSBmdW5jacOzbiBwYXJhIG9idGVuZXIgaW5mb3JtYWNpw7NuIGNvbXBsZXRhIGRlbCBjbGllbnRlIHkgYW7DoWxpc2lzIChjYWxscyB5IGNhbGxiYWNrcylcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsRGV0YWlsc1dpdGhQQ0EoY2FsbElkOiBzdHJpbmcpOiBQcm9taXNlPHsgY2FsbDogQ2FsbCB8IG51bGwsIHBjYTogUENBW10sIGlzQ2FsbGJhY2s6IGJvb2xlYW4sIGNhbGxiYWNrPzogYW55IH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBnZXRDYWxsRGV0YWlsc1dpdGhQQ0EgLSBidXNjYW5kbyBjYWxsSWQ6JywgY2FsbElkKVxuICAgIFxuICAgIC8vIE9idGVuZXIgbGEgbGxhbWFkYSAoc2llbXByZSBleGlzdGUpXG4gICAgY29uc3QgeyBkYXRhOiBjYWxsRGF0YSwgZXJyb3I6IGNhbGxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYWxscycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgY29uc29sZS5sb2coJ/Cfk54gUmVzdWx0YWRvIGLDunNxdWVkYSBlbiBjYWxsczonLCB7IGNhbGxEYXRhLCBjYWxsRXJyb3IgfSlcblxuICAgIGlmIChjYWxsRXJyb3IgfHwgIWNhbGxEYXRhKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgTm8gc2UgZW5jb250csOzIGxhIGNhbGwgY29uIElEOicsIGNhbGxJZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IG51bGwsXG4gICAgICAgIHBjYTogW10sXG4gICAgICAgIGlzQ2FsbGJhY2s6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2FyIHNpIGVzdGEgY2FsbCB0aWVuZSB1biBjYWxsYmFjayBhc29jaWFkb1xuICAgIGNvbnN0IHsgZGF0YTogY2FsbGJhY2tEYXRhLCBlcnJvcjogY2FsbGJhY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYWxsYmFja3MnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NhbGxfaWQnLCBjYWxsSWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGNvbnNvbGUubG9nKCfvv70gVmVyaWZpY2FuZG8gc2kgdGllbmUgY2FsbGJhY2sgYXNvY2lhZG86JywgeyBjYWxsYmFja0RhdGEsIGNhbGxiYWNrRXJyb3IgfSlcblxuICAgIC8vIE9idGVuZXIgUENBXG4gICAgY29uc3QgcGNhRGF0YSA9IGF3YWl0IGdldFBDQUJ5Q2FsbElkKGNhbGxJZClcblxuICAgIGlmIChjYWxsYmFja0RhdGEgJiYgIWNhbGxiYWNrRXJyb3IpIHtcbiAgICAgIC8vIEVzIHVuYSBjYWxsIHF1ZSBUQU1CScOJTiBlcyB1biBjYWxsYmFja1xuICAgICAgY29uc29sZS5sb2coJ+KchSBDYWxsIGNvbiBjYWxsYmFjayBhc29jaWFkbyBlbmNvbnRyYWRvJylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IGNhbGxEYXRhLFxuICAgICAgICBwY2E6IHBjYURhdGEsXG4gICAgICAgIGlzQ2FsbGJhY2s6IHRydWUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja0RhdGFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXMgdW5hIGNhbGwgbm9ybWFsIChzaW4gY2FsbGJhY2spXG4gICAgICBjb25zb2xlLmxvZygn4pyFIENhbGwgbm9ybWFsIChzaW4gY2FsbGJhY2spJylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IGNhbGxEYXRhLFxuICAgICAgICBwY2E6IHBjYURhdGEsXG4gICAgICAgIGlzQ2FsbGJhY2s6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRDYWxsRGV0YWlsc1dpdGhQQ0E6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBkZSBkZWJ1ZyBwYXJhIHZlciB0b2RvcyBsb3MgUENBIGRpc3BvbmlibGVzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsUENBKCkge1xuICBjb25zb2xlLmxvZygnSW50ZW50YW5kbyBvYnRlbmVyIHRvZG9zIGxvcyBQQ0EuLi4nKVxuICBcbiAgLy8gUHJpbWVybyBpbnRlbnRhbW9zIHNpbiBsw61taXRlc1xuICBjb25zdCB7IGRhdGEsIGVycm9yLCBzdGF0dXMsIHN0YXR1c1RleHQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BjYScpXG4gICAgLnNlbGVjdCgnaWQsIGNhbGxfaWQsIGFnZW50X25hbWUsIGNyZWF0ZWRfYXQnKVxuICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gIGNvbnNvbGUubG9nKCdSZXNwdWVzdGEgUENBOicsIHsgXG4gICAgZGF0YSwgXG4gICAgZXJyb3IsIFxuICAgIHN0YXR1cywgXG4gICAgc3RhdHVzVGV4dCxcbiAgICBkYXRhTGVuZ3RoOiBkYXRhPy5sZW5ndGggfHwgMFxuICB9KVxuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFsbGFkbyBhbCBvYnRlbmVyIFBDQTonLCB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgZGV0YWlsczogZXJyb3IuZGV0YWlscyxcbiAgICAgIGhpbnQ6IGVycm9yLmhpbnQsXG4gICAgICBjb2RlOiBlcnJvci5jb2RlXG4gICAgfSlcbiAgICBcbiAgICAvLyBJbnRlbnRhbW9zIGNvbiB1biBxdWVyeSBtw6FzIHNpbXBsZVxuICAgIGNvbnNvbGUubG9nKCdJbnRlbnRhbmRvIHF1ZXJ5IG3DoXMgc2ltcGxlLi4uJylcbiAgICBjb25zdCB7IGRhdGE6IHNpbXBsZURhdGEsIGVycm9yOiBzaW1wbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAubGltaXQoMSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygnUXVlcnkgc2ltcGxlIHJlc3VsdGFkbzonLCB7IHNpbXBsZURhdGEsIHNpbXBsZUVycm9yIH0pXG4gICAgXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdQQ0Egb2J0ZW5pZG9zIGV4aXRvc2FtZW50ZTonLCBkYXRhKVxuICByZXR1cm4gZGF0YVxufVxuXG4vLyBGdW5jacOzbiBkZSBkZWJ1ZyBzaW1wbGUgcGFyYSB2ZXJpZmljYXIgYWNjZXNvIGEgUENBXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdFBDQUFjY2VzcygpIHtcbiAgY29uc29sZS5sb2coJ1Rlc3RlYW5kbyBhY2Nlc28gYSB0YWJsYSBQQ0EuLi4nKVxuICBcbiAgY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BjYScpXG4gICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcblxuICBjb25zb2xlLmxvZygnVGVzdCBQQ0EgLSBDb3VudDonLCBjb3VudCwgJ0Vycm9yOicsIGVycm9yKVxuICBcbiAgcmV0dXJuIHsgY291bnQsIGVycm9yIH1cbn1cblxuLy8gRnVuY2nDs24gcGFyYSB2ZXJpZmljYXIgdG9kYXMgbGFzIHRhYmxhcyBkaXNwb25pYmxlc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RBbGxUYWJsZXNBY2Nlc3MoKSB7XG4gIGNvbnN0IHRhYmxlcyA9IFsnY2FsbHMnLCAncGNhJywgJ2NhbGxiYWNrcyddXG4gIGNvbnN0IHJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIHsgY291bnQ6IG51bWJlciB8IG51bGwsIGVycm9yOiBzdHJpbmcgfCBudWxsIH0+ID0ge31cbiAgXG4gIGZvciAoY29uc3QgdGFibGUgb2YgdGFibGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBUZXN0ZWFuZG8gdGFibGE6ICR7dGFibGV9YClcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSh0YWJsZSlcbiAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgIFxuICAgICAgcmVzdWx0c1t0YWJsZV0gPSB7IGNvdW50LCBlcnJvcjogZXJyb3I/Lm1lc3NhZ2UgfHwgbnVsbCB9XG4gICAgICBjb25zb2xlLmxvZyhgJHt0YWJsZX06ICR7Y291bnR9IHJlZ2lzdHJvcywgZXJyb3I6YCwgZXJyb3I/Lm1lc3NhZ2UpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJ1xuICAgICAgcmVzdWx0c1t0YWJsZV0gPSB7IGNvdW50OiAwLCBlcnJvcjogZXJyb3JNZXNzYWdlIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVuIHRhYmxhICR7dGFibGV9OmAsIGVycilcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRzXG59XG5cbi8vIEZ1bmNpw7NuIGVzcGVjw61maWNhIHBhcmEgZGlhZ25vc3RpY2FyIGVsIHByb2JsZW1hIGRlIFBDQVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpYWdub3NlUENBQWNjZXNzKCkge1xuICBjb25zb2xlLmxvZygn8J+UjSBEaWFnbm9zdGljYW5kbyBhY2Nlc28gYSB0YWJsYSBQQ0EuLi4nKVxuICBcbiAgY29uc3QgdGVzdHMgPSBbXVxuICBcbiAgLy8gVGVzdCAxOiBDb3VudCBiw6FzaWNvXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgXG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnQ291bnQgYsOhc2ljbycsXG4gICAgICBzdWNjZXNzOiAhZXJyb3IsXG4gICAgICByZXN1bHQ6IGBDb3VudDogJHtjb3VudH1gLFxuICAgICAgZXJyb3I6IGVycm9yPy5tZXNzYWdlXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnQ291bnQgYsOhc2ljbycsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIHJlc3VsdDogJ0V4Y2VwY2nDs24nLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gVGVzdCAyOiBTZWxlY3Qgc2ltcGxlIGNvbiBsw61taXRlXG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmxpbWl0KDEpXG4gICAgXG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnU2VsZWN0IHNpbXBsZSAobGltaXQgMSknLFxuICAgICAgc3VjY2VzczogIWVycm9yLFxuICAgICAgcmVzdWx0OiBgUmVnaXN0cm9zOiAke2RhdGE/Lmxlbmd0aCB8fCAwfWAsXG4gICAgICBlcnJvcjogZXJyb3I/Lm1lc3NhZ2VcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdTZWxlY3Qgc2ltcGxlIChsaW1pdCAxKScsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIHJlc3VsdDogJ0V4Y2VwY2nDs24nLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gVGVzdCAzOiBTZWxlY3QgZXNwZWPDrWZpY29cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCdpZCwgY2FsbF9pZCcpXG4gICAgICAubGltaXQoMylcbiAgICBcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdTZWxlY3QgZXNwZWPDrWZpY28gKGlkLCBjYWxsX2lkKScsXG4gICAgICBzdWNjZXNzOiAhZXJyb3IsXG4gICAgICByZXN1bHQ6IGBSZWdpc3Ryb3M6ICR7ZGF0YT8ubGVuZ3RoIHx8IDB9YCxcbiAgICAgIGVycm9yOiBlcnJvcj8ubWVzc2FnZSxcbiAgICAgIHNhbXBsZURhdGE6IGRhdGFcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdTZWxlY3QgZXNwZWPDrWZpY28gKGlkLCBjYWxsX2lkKScsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIHJlc3VsdDogJ0V4Y2VwY2nDs24nLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gVGVzdCA0OiBWZXJpZmljYXIgc2kgUkxTIGVzdMOhIGNhdXNhbmRvIGVsIHByb2JsZW1hXG4gIHRyeSB7XG4gICAgLy8gSW50ZW50YW1vcyBoYWNlciB1biBxdWVyeSBjb24gYnlwYXNzIGRlIFJMUyBzaSBlcyBwb3NpYmxlXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5ycGMoJ2dldF9wY2FfY291bnQnKSAgLy8gRXN0YSBmdW5jacOzbiBubyBleGlzdGUsIHBlcm8gZWwgZXJyb3Igbm9zIGRhcsOhIGluZm9ybWFjacOzblxuICAgIFxuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1Rlc3QgUlBDIChwYXJhIHZlcmlmaWNhciBSTFMpJyxcbiAgICAgIHN1Y2Nlc3M6ICFlcnJvcixcbiAgICAgIHJlc3VsdDogJ1JQQyBjYWxsJyxcbiAgICAgIGVycm9yOiBlcnJvcj8ubWVzc2FnZVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1Rlc3QgUlBDIChwYXJhIHZlcmlmaWNhciBSTFMpJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgcmVzdWx0OiAnUlBDIG5vIGRpc3BvbmlibGUnLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCfwn5OKIFJlc3VsdGFkb3MgZGVsIGRpYWduw7NzdGljbzonLCB0ZXN0cylcbiAgcmV0dXJuIHRlc3RzXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgY3JlYXIgdW5hIHBvbMOtdGljYSB0ZW1wb3JhbCBkZSBSTFNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQQ0FQb2xpY3koKSB7XG4gIGNvbnNvbGUubG9nKCfwn5SnIEludGVudGFuZG8gY3JlYXIgcG9sw610aWNhIGRlIGFjY2VzbyBwYXJhIFBDQS4uLicpXG4gIFxuICB0cnkge1xuICAgIC8vIEludGVudGFtb3MgZWplY3V0YXIgdW4gY29tYW5kbyBTUUwgcGFyYSBjcmVhciB1bmEgcG9sw610aWNhXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5ycGMoJ2NyZWF0ZV9wY2FfcG9saWN5JylcbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiAhZXJyb3IsIGVycm9yOiBlcnJvcj8ubWVzc2FnZSB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7IFxuICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfVxuICB9XG59XG5cbi8vIPCfk54gRlVOQ0lPTkVTIFBBUkEgSElTVE9SSUFMIERFIExMQU1BREFTIFBPUiBURUzDiUZPTk9cblxuLy8gSW50ZXJmYXogcGFyYSB1biBMZWFkIChuw7ptZXJvIGRlIHRlbMOpZm9ubyBjb24gaW5mb3JtYWNpw7NuIGRlbCBjbGllbnRlKVxuZXhwb3J0IGludGVyZmFjZSBMZWFkIHtcbiAgcGhvbmVfbnVtYmVyOiBzdHJpbmdcbiAgYnVzaW5lc3NfbmFtZT86IHN0cmluZ1xuICBvd25lcl9uYW1lPzogc3RyaW5nXG4gIG93bmVyX2VtYWlsPzogc3RyaW5nXG4gIGxvY2F0aW9uX3R5cGU/OiBzdHJpbmdcbiAgYWRkcmVzc19zdHJlZXQ/OiBzdHJpbmdcbiAgYWRkcmVzc19jaXR5Pzogc3RyaW5nXG4gIGFkZHJlc3Nfc3RhdGU/OiBzdHJpbmdcbiAgYWRkcmVzc196aXA/OiBzdHJpbmdcbiAgdG90YWxfY2FsbHM6IG51bWJlclxuICBsYXN0X2NhbGxfZGF0ZTogc3RyaW5nXG4gIGxhc3RfZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgYWdyZWVkX2Ftb3VudD86IG51bWJlclxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgdG9kb3MgbG9zIGxlYWRzIChuw7ptZXJvcyDDum5pY29zIGNvbiBzdSBpbmZvcm1hY2nDs24gbcOhcyByZWNpZW50ZSlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMZWFkcygpOiBQcm9taXNlPExlYWRbXT4ge1xuICBjb25zb2xlLmxvZygn8J+TniBPYnRlbmllbmRvIHRvZG9zIGxvcyBsZWFkcy4uLicpXG4gIFxuICAvLyBQcmltZXJvIG9idGVuZW1vcyB0b2RhcyBsYXMgY2FsbHNcbiAgY29uc3QgeyBkYXRhOiBjYWxsc0RhdGEsIGVycm9yOiBjYWxsc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdjYWxscycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLm5vdCgndG9fbnVtYmVyJywgJ2lzJywgbnVsbClcbiAgICAub3JkZXIoJ2NhbGxfaWQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgXG4gIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG9idGVuaWVuZG8gY2FsbHM6JywgY2FsbHNFcnJvcilcbiAgICB0aHJvdyBjYWxsc0Vycm9yXG4gIH1cbiAgXG4gIGlmICghY2FsbHNEYXRhKSByZXR1cm4gW11cbiAgXG4gIC8vIE9idGVuZXIgdG9kYXMgbGFzIGRpc3Bvc2l0aW9ucyBkZWwgUENBIHBhcmEgbG9zIGNhbGxfaWRzXG4gIGNvbnN0IGNhbGxJZHMgPSBjYWxsc0RhdGEubWFwKGNhbGwgPT4gY2FsbC5jYWxsX2lkKVxuICBjb25zdCB7IGRhdGE6IHBjYURhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BjYScpXG4gICAgLnNlbGVjdCgnY2FsbF9pZCwgZGlzcG9zaXRpb24nKVxuICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG4gIFxuICAvLyBDcmVhciB1biBtYXBhIHBhcmEgYWNjZXNvIHLDoXBpZG8gYSBsYXMgZGlzcG9zaXRpb25zIGRlbCBQQ0FcbiAgY29uc3QgcGNhTWFwID0gbmV3IE1hcCgpXG4gIGlmIChwY2FEYXRhKSB7XG4gICAgcGNhRGF0YS5mb3JFYWNoKHBjYSA9PiB7XG4gICAgICBwY2FNYXAuc2V0KHBjYS5jYWxsX2lkLCBwY2EuZGlzcG9zaXRpb24pXG4gICAgfSlcbiAgfVxuICBcbiAgY29uc3QgZGF0YSA9IGNhbGxzRGF0YVxuICBcbiAgLy8gQWdydXBhbW9zIHBvciB0b19udW1iZXIgeSB0b21hbW9zIGxhIGluZm9ybWFjacOzbiBtw6FzIHJlY2llbnRlXG4gIGNvbnN0IGxlYWRzTWFwID0gbmV3IE1hcDxzdHJpbmcsIExlYWQ+KClcbiAgXG4gIGZvciAoY29uc3QgY2FsbCBvZiBkYXRhKSB7XG4gICAgaWYgKCFjYWxsLnRvX251bWJlcikgY29udGludWVcbiAgICBcbiAgICBjb25zdCBleGlzdGluZ0xlYWQgPSBsZWFkc01hcC5nZXQoY2FsbC50b19udW1iZXIpXG4gICAgXG4gICAgaWYgKCFleGlzdGluZ0xlYWQpIHtcbiAgICAgIC8vIFByaW1lcmEgdmV6IHF1ZSB2ZW1vcyBlc3RlIG7Dum1lcm9cbiAgICAgIGxlYWRzTWFwLnNldChjYWxsLnRvX251bWJlciwge1xuICAgICAgICBwaG9uZV9udW1iZXI6IGNhbGwudG9fbnVtYmVyLFxuICAgICAgICBidXNpbmVzc19uYW1lOiBjYWxsLmJ1c2luZXNzX25hbWUsXG4gICAgICAgIG93bmVyX25hbWU6IGNhbGwub3duZXJfbmFtZSxcbiAgICAgICAgb3duZXJfZW1haWw6IGNhbGwub3duZXJfZW1haWwsXG4gICAgICAgIGxvY2F0aW9uX3R5cGU6IGNhbGwubG9jYXRpb25fdHlwZSxcbiAgICAgICAgYWRkcmVzc19zdHJlZXQ6IGNhbGwuYWRkcmVzc19zdHJlZXQsXG4gICAgICAgIGFkZHJlc3NfY2l0eTogY2FsbC5hZGRyZXNzX2NpdHksXG4gICAgICAgIGFkZHJlc3Nfc3RhdGU6IGNhbGwuYWRkcmVzc19zdGF0ZSxcbiAgICAgICAgYWRkcmVzc196aXA6IGNhbGwuYWRkcmVzc196aXAsXG4gICAgICAgIHRvdGFsX2NhbGxzOiAxLFxuICAgICAgICBsYXN0X2NhbGxfZGF0ZTogY2FsbC5jYWxsX2lkLCAvLyBVc2FuZG8gY2FsbF9pZCBjb21vIHByb3h5IGRlIGZlY2hhXG4gICAgICAgIGxhc3RfZGlzcG9zaXRpb246IHBjYU1hcC5nZXQoY2FsbC5jYWxsX2lkKSB8fCBjYWxsLmRpc3Bvc2l0aW9uLFxuICAgICAgICBhZ3JlZWRfYW1vdW50OiBjYWxsLmFncmVlZF9hbW91bnRcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFjdHVhbGl6YW1vcyBlbCBjb250ZW9cbiAgICAgIGV4aXN0aW5nTGVhZC50b3RhbF9jYWxscysrXG4gICAgICBcbiAgICAgIC8vIFNpIGVzdGEgbGxhbWFkYSBlcyBtw6FzIHJlY2llbnRlIChjYWxsX2lkIG1heW9yKSwgYWN0dWFsaXphbW9zIGxhIGluZm9cbiAgICAgIGlmIChjYWxsLmNhbGxfaWQgPiBleGlzdGluZ0xlYWQubGFzdF9jYWxsX2RhdGUpIHtcbiAgICAgICAgZXhpc3RpbmdMZWFkLmJ1c2luZXNzX25hbWUgPSBjYWxsLmJ1c2luZXNzX25hbWUgfHwgZXhpc3RpbmdMZWFkLmJ1c2luZXNzX25hbWVcbiAgICAgICAgZXhpc3RpbmdMZWFkLm93bmVyX25hbWUgPSBjYWxsLm93bmVyX25hbWUgfHwgZXhpc3RpbmdMZWFkLm93bmVyX25hbWVcbiAgICAgICAgZXhpc3RpbmdMZWFkLm93bmVyX2VtYWlsID0gY2FsbC5vd25lcl9lbWFpbCB8fCBleGlzdGluZ0xlYWQub3duZXJfZW1haWxcbiAgICAgICAgZXhpc3RpbmdMZWFkLmxvY2F0aW9uX3R5cGUgPSBjYWxsLmxvY2F0aW9uX3R5cGUgfHwgZXhpc3RpbmdMZWFkLmxvY2F0aW9uX3R5cGVcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3Nfc3RyZWV0ID0gY2FsbC5hZGRyZXNzX3N0cmVldCB8fCBleGlzdGluZ0xlYWQuYWRkcmVzc19zdHJlZXRcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3NfY2l0eSA9IGNhbGwuYWRkcmVzc19jaXR5IHx8IGV4aXN0aW5nTGVhZC5hZGRyZXNzX2NpdHlcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3Nfc3RhdGUgPSBjYWxsLmFkZHJlc3Nfc3RhdGUgfHwgZXhpc3RpbmdMZWFkLmFkZHJlc3Nfc3RhdGVcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3NfemlwID0gY2FsbC5hZGRyZXNzX3ppcCB8fCBleGlzdGluZ0xlYWQuYWRkcmVzc196aXBcbiAgICAgICAgZXhpc3RpbmdMZWFkLmxhc3RfY2FsbF9kYXRlID0gY2FsbC5jYWxsX2lkXG4gICAgICAgIGV4aXN0aW5nTGVhZC5sYXN0X2Rpc3Bvc2l0aW9uID0gcGNhTWFwLmdldChjYWxsLmNhbGxfaWQpIHx8IGNhbGwuZGlzcG9zaXRpb25cbiAgICAgICAgZXhpc3RpbmdMZWFkLmFncmVlZF9hbW91bnQgPSBjYWxsLmFncmVlZF9hbW91bnQgfHwgZXhpc3RpbmdMZWFkLmFncmVlZF9hbW91bnRcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IGxlYWRzID0gQXJyYXkuZnJvbShsZWFkc01hcC52YWx1ZXMoKSlcbiAgY29uc29sZS5sb2coYOKchSBFbmNvbnRyYWRvcyAke2xlYWRzLmxlbmd0aH0gbGVhZHMgw7puaWNvc2ApXG4gIHJldHVybiBsZWFkc1xufVxuXG4vLyBJbnRlcmZheiBwYXJhIGludGVyYWNjaW9uZXMgY29tYmluYWRhcyAoY2FsbHMgKyBjYWxsYmFja3MpXG5leHBvcnQgaW50ZXJmYWNlIENhbGxJbnRlcmFjdGlvbiB7XG4gIHR5cGU6ICdjYWxsJyB8ICdjYWxsYmFjaydcbiAgY2FsbF9pZD86IHN0cmluZ1xuICBpZD86IHN0cmluZ1xuICBkaXNwb3NpdGlvbj86IHN0cmluZ1xuICBidXNpbmVzc19uYW1lPzogc3RyaW5nXG4gIG93bmVyX25hbWU/OiBzdHJpbmdcbiAgYWdyZWVkX2Ftb3VudD86IG51bWJlclxuICBhZGRyZXNzX3N0cmVldD86IHN0cmluZ1xuICBhZGRyZXNzX2NpdHk/OiBzdHJpbmdcbiAgYWRkcmVzc19zdGF0ZT86IHN0cmluZ1xuICBjYWxsYmFja190aW1lPzogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ/OiBzdHJpbmdcbiAgZGF0ZTogc3RyaW5nXG4gIGRpc3BsYXlfZGF0ZTogc3RyaW5nXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBoaXN0b3JpYWwgY29tcGxldG8gKGNhbGxzICsgY2FsbGJhY2tzKSBwb3IgbsO6bWVybyBkZSB0ZWzDqWZvbm9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsSGlzdG9yeUJ5UGhvbmUocGhvbmVOdW1iZXI6IHN0cmluZyk6IFByb21pc2U8Q2FsbEludGVyYWN0aW9uW10+IHtcbiAgY29uc29sZS5sb2coYPCfk54gT2J0ZW5pZW5kbyBoaXN0b3JpYWwgY29tcGxldG8gcGFyYTogJHtwaG9uZU51bWJlcn1gKVxuICBcbiAgdHJ5IHtcbiAgICAvLyBPYnRlbmVyIGxsYW1hZGFzIHJlZ3VsYXJlc1xuICAgIGNvbnN0IHsgZGF0YTogY2FsbHMsIGVycm9yOiBjYWxsc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0b19udW1iZXInLCBwaG9uZU51bWJlcilcbiAgICAgIC5vcmRlcignY2FsbF9pZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgIFxuICAgIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igb2J0ZW5pZW5kbyBsbGFtYWRhczonLCBjYWxsc0Vycm9yKVxuICAgICAgdGhyb3cgY2FsbHNFcnJvclxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+TniBFbmNvbnRyYWRhcyAke2NhbGxzPy5sZW5ndGggfHwgMH0gbGxhbWFkYXMgcGFyYSAke3Bob25lTnVtYmVyfWApXG4gICAgXG4gICAgLy8gT2J0ZW5lciBjYWxsYmFja3MgcGFyYSBlc2UgbsO6bWVyb1xuICAgIGNvbnN0IHsgZGF0YTogY2FsbGJhY2tzLCBlcnJvcjogY2FsbGJhY2tzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbGJhY2tzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0b19udW1iZXInLCBwaG9uZU51bWJlcilcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5SEIEVuY29udHJhZG9zICR7Y2FsbGJhY2tzPy5sZW5ndGggfHwgMH0gY2FsbGJhY2tzIHBhcmEgJHtwaG9uZU51bWJlcn1gKVxuICAgIFxuICAgIGlmIChjYWxsYmFja3NFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG9idGVuaWVuZG8gY2FsbGJhY2tzOicsIGNhbGxiYWNrc0Vycm9yKVxuICAgICAgLy8gTm8gbGFuemFtb3MgZXJyb3IsIHNvbG8gbG9ndWVhbW9zXG4gICAgfVxuICAgIFxuICAgIC8vIE9idGVuZXIgZGlzcG9zaXRpb25zIGRlbCBQQ0EgcGFyYSBsYXMgY2FsbHNcbiAgICBsZXQgcGNhTWFwID0gbmV3IE1hcCgpXG4gICAgbGV0IGNhbGxiYWNrTWFwID0gbmV3IE1hcCgpXG4gICAgXG4gICAgaWYgKGNhbGxzICYmIGNhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNhbGxJZHMgPSBjYWxscy5tYXAoY2FsbCA9PiBjYWxsLmNhbGxfaWQpXG4gICAgICBcbiAgICAgIC8vIE9idGVuZXIgZGlzcG9zaXRpb25zIGRlbCBQQ0FcbiAgICAgIGNvbnN0IHsgZGF0YTogcGNhRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAgIC5zZWxlY3QoJ2NhbGxfaWQsIGRpc3Bvc2l0aW9uJylcbiAgICAgICAgLmluKCdjYWxsX2lkJywgY2FsbElkcylcbiAgICAgIFxuICAgICAgaWYgKHBjYURhdGEpIHtcbiAgICAgICAgcGNhRGF0YS5mb3JFYWNoKHBjYSA9PiB7XG4gICAgICAgICAgcGNhTWFwLnNldChwY2EuY2FsbF9pZCwgcGNhLmRpc3Bvc2l0aW9uKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPYnRlbmVyIGNhbGxiYWNrcyBhc29jaWFkb3MgYSBlc3RhcyBjYWxsc1xuICAgICAgY29uc3QgeyBkYXRhOiBhc3NvY2lhdGVkQ2FsbGJhY2tzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY2FsbGJhY2tzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG4gICAgICBcbiAgICAgIGlmIChhc3NvY2lhdGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgIGFzc29jaWF0ZWRDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGxfaWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrTWFwLnNldChjYWxsYmFjay5jYWxsX2lkLCBjYWxsYmFjaylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBDYWxsYmFjayAke2NhbGxiYWNrLmlkfSBubyB0aWVuZSBjYWxsX2lkYClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SXIENhbGxzIGNvbiBjYWxsYmFja3MgYXNvY2lhZG9zOiAke0FycmF5LmZyb20oY2FsbGJhY2tNYXAua2V5cygpKS5qb2luKCcsICcpfWApXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBUb2RvcyBsb3MgY2FsbF9pZHMgZGUgY2FsbHM6ICR7KGNhbGxzIHx8IFtdKS5tYXAoYyA9PiBjLmNhbGxfaWQpLmpvaW4oJywgJyl9YClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIFRvZG9zIGxvcyBjYWxsX2lkcyBkZSBjYWxsYmFja3M6ICR7KGNhbGxiYWNrcyB8fCBbXSkubWFwKGMgPT4gYy5jYWxsX2lkKS5qb2luKCcsICcpfWApXG4gICAgfVxuICAgIFxuICAgIC8vIENvbWJpbmFyIHkgbWFyY2FyIGVsIHRpcG8gLSBTSU4gRFVQTElDQVJcbiAgICBjb25zdCBhbGxJbnRlcmFjdGlvbnM6IENhbGxJbnRlcmFjdGlvbltdID0gW1xuICAgICAgLy8gUHJvY2VzYXIgc29sbyBsYXMgY2FsbHMgcXVlIE5PIHRpZW5lbiBjYWxsYmFjayBhc29jaWFkbyAobW9zdHJhcmxhcyBjb21vIGNhbGxzIG5vcm1hbGVzKVxuICAgICAgLi4uKGNhbGxzIHx8IFtdKS5maWx0ZXIoY2FsbCA9PiB7XG4gICAgICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gY2FsbGJhY2tNYXAuaGFzKGNhbGwuY2FsbF9pZClcbiAgICAgICAgY29uc29sZS5sb2coYPCfk54gQ2FsbCAke2NhbGwuY2FsbF9pZH06IGRpc3Bvc2l0aW9uPVwiJHtjYWxsLmRpc3Bvc2l0aW9ufVwiLCBoYXNDYWxsYmFjaz0ke2hhc0NhbGxiYWNrfWApXG4gICAgICAgIHJldHVybiAhaGFzQ2FsbGJhY2tcbiAgICAgIH0pLm1hcChjYWxsID0+IHtcbiAgICAgICAgY29uc3QgcGNhRGlzcG9zaXRpb24gPSBwY2FNYXAuZ2V0KGNhbGwuY2FsbF9pZCkgfHwgY2FsbC5kaXNwb3NpdGlvblxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIC4uLmNhbGwsXG4gICAgICAgICAgdHlwZTogJ2NhbGwnIGFzIGNvbnN0LFxuICAgICAgICAgIGRhdGU6IGNhbGwuY2FsbF9pZCxcbiAgICAgICAgICBkaXNwbGF5X2RhdGU6IGNhbGwuY2FsbF9pZCxcbiAgICAgICAgICBkaXNwb3NpdGlvbjogcGNhRGlzcG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCfk54gQ2FsbCAke2NhbGwuY2FsbF9pZH06IGRpc3Bvc2l0aW9uPVwiJHtwY2FEaXNwb3NpdGlvbn1cImApXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzYXIgVE9ET1MgbG9zIGNhbGxiYWNrcyAoaW5jbHV5ZSBsb3MgcXVlIHRpZW5lbiBjYWxsIGFzb2NpYWRhIHkgbG9zIGluZGVwZW5kaWVudGVzKVxuICAgICAgLi4uKGNhbGxiYWNrcyB8fCBbXSkubWFwKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRlZENhbGwgPSBjYWxscz8uZmluZChjYWxsID0+IGNhbGwuY2FsbF9pZCA9PT0gY2FsbGJhY2suY2FsbF9pZClcbiAgICAgICAgY29uc3QgcGNhRGlzcG9zaXRpb24gPSBhc3NvY2lhdGVkQ2FsbCA/IChwY2FNYXAuZ2V0KGNhbGxiYWNrLmNhbGxfaWQpIHx8IGFzc29jaWF0ZWRDYWxsLmRpc3Bvc2l0aW9uKSA6IGNhbGxiYWNrLmRpc3Bvc2l0aW9uXG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgLi4uY2FsbGJhY2ssXG4gICAgICAgICAgdHlwZTogJ2NhbGxiYWNrJyBhcyBjb25zdCxcbiAgICAgICAgICBkYXRlOiBjYWxsYmFjay5jcmVhdGVkX2F0IHx8IGNhbGxiYWNrLmlkLFxuICAgICAgICAgIGRpc3BsYXlfZGF0ZTogY2FsbGJhY2suY2FsbGJhY2tfdGltZSB8fCBjYWxsYmFjay5jcmVhdGVkX2F0IHx8IGNhbGxiYWNrLmlkLFxuICAgICAgICAgIC8vIFNpIHRpZW5lIGNhbGwgYXNvY2lhZGEsIHVzYXIgYWxndW5vcyBkYXRvcyBkZSBsYSBjYWxsIChjb21vIGFkZHJlc3MsIGJ1c2luZXNzX25hbWUgb3JpZ2luYWwpXG4gICAgICAgICAgLi4uKGFzc29jaWF0ZWRDYWxsID8ge1xuICAgICAgICAgICAgYnVzaW5lc3NfbmFtZTogYXNzb2NpYXRlZENhbGwuYnVzaW5lc3NfbmFtZSxcbiAgICAgICAgICAgIG93bmVyX25hbWU6IGNhbGxiYWNrLmNhbGxiYWNrX293bmVyX25hbWUgfHwgYXNzb2NpYXRlZENhbGwub3duZXJfbmFtZSxcbiAgICAgICAgICAgIGFkZHJlc3Nfc3RyZWV0OiBhc3NvY2lhdGVkQ2FsbC5hZGRyZXNzX3N0cmVldCxcbiAgICAgICAgICAgIGFkZHJlc3NfY2l0eTogYXNzb2NpYXRlZENhbGwuYWRkcmVzc19jaXR5LFxuICAgICAgICAgICAgYWRkcmVzc19zdGF0ZTogYXNzb2NpYXRlZENhbGwuYWRkcmVzc19zdGF0ZSxcbiAgICAgICAgICAgIG93bmVyX3Bob25lOiBhc3NvY2lhdGVkQ2FsbC5vd25lcl9waG9uZSxcbiAgICAgICAgICAgIGFncmVlZF9hbW91bnQ6IGFzc29jaWF0ZWRDYWxsLmFncmVlZF9hbW91bnQsXG4gICAgICAgICAgICBkaXNwb3NpdGlvbjogcGNhRGlzcG9zaXRpb25cbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgYnVzaW5lc3NfbmFtZTogY2FsbGJhY2suYnVzaW5lc3NfbmFtZSxcbiAgICAgICAgICAgIG93bmVyX25hbWU6IGNhbGxiYWNrLmNhbGxiYWNrX293bmVyX25hbWUsXG4gICAgICAgICAgICBhZ3JlZWRfYW1vdW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkaXNwb3NpdGlvbjogY2FsbGJhY2suZGlzcG9zaXRpb25cbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvLyBJbmZvcm1hY2nDs24gZXNwZWPDrWZpY2EgZGVsIGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2tfdGltZTogY2FsbGJhY2suY2FsbGJhY2tfdGltZSxcbiAgICAgICAgICBjYWxsYmFja19vd25lcl9uYW1lOiBjYWxsYmFjay5jYWxsYmFja19vd25lcl9uYW1lXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIENhbGxiYWNrICR7Y2FsbGJhY2suaWQgfHwgY2FsbGJhY2suY2FsbF9pZH06ICR7YXNzb2NpYXRlZENhbGwgPyAnY29uIGNhbGwgYXNvY2lhZGEnIDogJ2luZGVwZW5kaWVudGUnfSwgb3duZXI9XCIke2NhbGxiYWNrLmNhbGxiYWNrX293bmVyX25hbWV9XCJgKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgICBdXG4gICAgXG4gICAgLy8gT3JkZW5hciBwb3IgZmVjaGEgKG3DoXMgcmVjaWVudGVzIHByaW1lcm8pXG4gICAgYWxsSW50ZXJhY3Rpb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhLmRhdGUgPiBiLmRhdGUpIHJldHVybiAtMVxuICAgICAgaWYgKGEuZGF0ZSA8IGIuZGF0ZSkgcmV0dXJuIDFcbiAgICAgIHJldHVybiAwXG4gICAgfSlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg4pyFIFByb2Nlc2FkYXMgJHtjYWxscz8ubGVuZ3RoIHx8IDB9IGxsYW1hZGFzICgkeyhjYWxscyB8fCBbXSkuZmlsdGVyKGNhbGwgPT4gIWNhbGxiYWNrTWFwLmhhcyhjYWxsLmNhbGxfaWQpKS5sZW5ndGh9IGNhbGxzICsgJHtjYWxsYmFja3M/Lmxlbmd0aCB8fCAwfSBjYWxsYmFja3MpIHBhcmEgJHtwaG9uZU51bWJlcn1gKVxuICAgIHJldHVybiBhbGxJbnRlcmFjdGlvbnNcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igb2J0ZW5pZW5kbyBoaXN0b3JpYWwgY29tcGxldG86JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIGNvbnRhciBjdcOhbnRhcyBsbGFtYWRhcyB0aWVuZSB1biBuw7ptZXJvXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbENvdW50QnlQaG9uZShwaG9uZU51bWJlcjogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3QgeyBjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2NhbGxzJylcbiAgICAuc2VsZWN0KCdjYWxsX2lkJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgIC5lcSgndG9fbnVtYmVyJywgcGhvbmVOdW1iZXIpXG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgY29udGFuZG8gbGxhbWFkYXM6JywgZXJyb3IpXG4gICAgcmV0dXJuIDBcbiAgfVxuICBcbiAgcmV0dXJuIGNvdW50IHx8IDBcbn1cblxuLy8gRnVuY2nDs24gcGFyYSB2ZXJpZmljYXIgc2kgdW5hIGxsYW1hZGEgdGllbmUgaGlzdG9yaWFsXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFzQ2FsbEhpc3RvcnkoY2FsbElkOiBzdHJpbmcpOiBQcm9taXNlPHsgaGFzSGlzdG9yeTogYm9vbGVhbjsgY291bnQ6IG51bWJlcjsgcGhvbmVOdW1iZXI/OiBzdHJpbmcgfT4ge1xuICAvLyBQcmltZXJvIG9idGVuZW1vcyBlbCB0b19udW1iZXIgZGUgbGEgbGxhbWFkYSBhY3R1YWxcbiAgY29uc3QgeyBkYXRhOiBjYWxsRGF0YSwgZXJyb3I6IGNhbGxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnY2FsbHMnKVxuICAgIC5zZWxlY3QoJ3RvX251bWJlcicpXG4gICAgLmVxKCdjYWxsX2lkJywgY2FsbElkKVxuICAgIC5zaW5nbGUoKVxuICBcbiAgaWYgKGNhbGxFcnJvciB8fCAhY2FsbERhdGE/LnRvX251bWJlcikge1xuICAgIHJldHVybiB7IGhhc0hpc3Rvcnk6IGZhbHNlLCBjb3VudDogMCB9XG4gIH1cbiAgXG4gIGNvbnN0IHBob25lTnVtYmVyID0gY2FsbERhdGEudG9fbnVtYmVyXG4gIGNvbnN0IGNvdW50ID0gYXdhaXQgZ2V0Q2FsbENvdW50QnlQaG9uZShwaG9uZU51bWJlcilcbiAgXG4gIHJldHVybiB7IFxuICAgIGhhc0hpc3Rvcnk6IGNvdW50ID4gMSwgXG4gICAgY291bnQsXG4gICAgcGhvbmVOdW1iZXIgXG4gIH1cbn0iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsImdldENhbGxzIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiZ2V0Q2FsbHNXaXRoUENBSW5mbyIsImNhbGxzIiwiY2FsbHNFcnJvciIsImNvbnNvbGUiLCJwY2FEYXRhIiwicGNhRXJyb3IiLCJjYWxsc1dpdGhQQ0EiLCJTZXQiLCJtYXAiLCJwY2EiLCJjYWxsX2lkIiwiY2FsbCIsImhhc1BDQSIsImhhcyIsImhhc0NhbGxiYWNrcyIsImdldENhbGxzV2l0aFBhZ2luYXRpb24iLCJwYXJhbXMiLCJsb2ciLCJxdWVyeSIsImNvdW50Iiwic2VhcmNoIiwib3IiLCJmaWx0ZXJzIiwiZGlzcG9zaXRpb24iLCJlcSIsInNvcnRCeSIsInNvcnRPcmRlciIsIm9mZnNldCIsInBhZ2UiLCJsaW1pdCIsInJhbmdlIiwibGVuZ3RoIiwidG90YWwiLCJ0b3RhbFBhZ2VzIiwiTWF0aCIsImNlaWwiLCJjYWxsSWRzIiwiaW4iLCJjYWxsYmFja0RhdGEiLCJjYWxsYmFja0Vycm9yIiwiY2FsbGJhY2tPd25lck1hcCIsIk1hcCIsImNhbGxiYWNrIiwibmFtZSIsImNhbGxiYWNrX293bmVyX25hbWUiLCJwaG9uZSIsImNhbGxiYWNrX293bmVyX3Bob25lIiwiQXJyYXkiLCJlbnRyaWVzIiwiY2FsbHNXaXRoSW5mbyIsImNhbGxiYWNrSW5mbyIsImdldCIsImZpbmFsT3duZXJOYW1lIiwib3duZXJfbmFtZSIsImZpbmFsT3duZXJQaG9uZSIsIm93bmVyX3Bob25lIiwiZmlsdGVyZWRDYWxscyIsInVuZGVmaW5lZCIsImZpbHRlciIsImdldENhbGxiYWNrc0J5Q2FsbElkIiwiY2FsbElkIiwiZ2V0UENBQnlDYWxsSWQiLCJnZXRDYWxsRGV0YWlsc1dpdGhQQ0EiLCJjYWxsRGF0YSIsImNhbGxFcnJvciIsInNpbmdsZSIsImlzQ2FsbGJhY2siLCJnZXRBbGxQQ0EiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YUxlbmd0aCIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiaGludCIsImNvZGUiLCJzaW1wbGVEYXRhIiwic2ltcGxlRXJyb3IiLCJ0ZXN0UENBQWNjZXNzIiwiaGVhZCIsInRlc3RBbGxUYWJsZXNBY2Nlc3MiLCJ0YWJsZXMiLCJyZXN1bHRzIiwidGFibGUiLCJlcnIiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsImRpYWdub3NlUENBQWNjZXNzIiwidGVzdHMiLCJwdXNoIiwidGVzdCIsInN1Y2Nlc3MiLCJyZXN1bHQiLCJzYW1wbGVEYXRhIiwicnBjIiwiY3JlYXRlUENBUG9saWN5IiwiZ2V0TGVhZHMiLCJjYWxsc0RhdGEiLCJub3QiLCJwY2FNYXAiLCJmb3JFYWNoIiwic2V0IiwibGVhZHNNYXAiLCJ0b19udW1iZXIiLCJleGlzdGluZ0xlYWQiLCJwaG9uZV9udW1iZXIiLCJidXNpbmVzc19uYW1lIiwib3duZXJfZW1haWwiLCJsb2NhdGlvbl90eXBlIiwiYWRkcmVzc19zdHJlZXQiLCJhZGRyZXNzX2NpdHkiLCJhZGRyZXNzX3N0YXRlIiwiYWRkcmVzc196aXAiLCJ0b3RhbF9jYWxscyIsImxhc3RfY2FsbF9kYXRlIiwibGFzdF9kaXNwb3NpdGlvbiIsImFncmVlZF9hbW91bnQiLCJsZWFkcyIsInZhbHVlcyIsImdldENhbGxIaXN0b3J5QnlQaG9uZSIsInBob25lTnVtYmVyIiwiY2FsbGJhY2tzIiwiY2FsbGJhY2tzRXJyb3IiLCJjYWxsYmFja01hcCIsImFzc29jaWF0ZWRDYWxsYmFja3MiLCJpZCIsImtleXMiLCJqb2luIiwiYyIsImFsbEludGVyYWN0aW9ucyIsImhhc0NhbGxiYWNrIiwicGNhRGlzcG9zaXRpb24iLCJ0eXBlIiwiZGF0ZSIsImRpc3BsYXlfZGF0ZSIsImFzc29jaWF0ZWRDYWxsIiwiZmluZCIsImNyZWF0ZWRfYXQiLCJjYWxsYmFja190aW1lIiwic29ydCIsImEiLCJiIiwiZ2V0Q2FsbENvdW50QnlQaG9uZSIsImhhc0NhbGxIaXN0b3J5IiwiaGFzSGlzdG9yeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});