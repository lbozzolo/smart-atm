"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/leads/page",{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPCAPolicy: function() { return /* binding */ createPCAPolicy; },\n/* harmony export */   diagnosePCAAccess: function() { return /* binding */ diagnosePCAAccess; },\n/* harmony export */   getAllPCA: function() { return /* binding */ getAllPCA; },\n/* harmony export */   getCallCountByPhone: function() { return /* binding */ getCallCountByPhone; },\n/* harmony export */   getCallDetailsWithPCA: function() { return /* binding */ getCallDetailsWithPCA; },\n/* harmony export */   getCallHistoryByPhone: function() { return /* binding */ getCallHistoryByPhone; },\n/* harmony export */   getCallbacksByCallId: function() { return /* binding */ getCallbacksByCallId; },\n/* harmony export */   getCalls: function() { return /* binding */ getCalls; },\n/* harmony export */   getCallsWithPCAInfo: function() { return /* binding */ getCallsWithPCAInfo; },\n/* harmony export */   getCallsWithPagination: function() { return /* binding */ getCallsWithPagination; },\n/* harmony export */   getLeads: function() { return /* binding */ getLeads; },\n/* harmony export */   getPCAByCallId: function() { return /* binding */ getPCAByCallId; },\n/* harmony export */   hasCallHistory: function() { return /* binding */ hasCallHistory; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   testAllTablesAccess: function() { return /* binding */ testAllTablesAccess; },\n/* harmony export */   testPCAAccess: function() { return /* binding */ testPCAAccess; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://rchgtacvdpavqkrceybo.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJjaGd0YWN2ZHBhdnFrcmNleWJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2OTUyODksImV4cCI6MjA3NjI3MTI4OX0.KZHdrA5sOrrDOUkMkG7H5b6Eb-yxPmrZQVXVBCuKVgg\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Función para obtener todas las llamadas\nasync function getCalls() {\n    const { data, error } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n        ascending: false\n    });\n    if (error) {\n        throw error;\n    }\n    return data;\n}\n// Función para obtener llamadas con información de si tienen PCA\nasync function getCallsWithPCAInfo() {\n    try {\n        // Primero obtenemos todas las llamadas\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"Error fetching calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls) return [];\n        // Luego obtenemos todos los call_ids que tienen PCA\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id\");\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        // No lanzamos error aquí, solo logueamos y continuamos sin PCA info\n        }\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        // Combinamos la información\n        return calls.map((call)=>({\n                ...call,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: false // Ya no usamos callbacks como concepto\n            }));\n    } catch (error) {\n        console.error(\"Error in getCallsWithPCAInfo:\", error);\n        throw error;\n    }\n}\n// Función NUEVA: Obtener llamadas con paginación en servidor (ESCALABLE)\nasync function getCallsWithPagination(params) {\n    try {\n        var _params_filters, _params_filters1;\n        console.log(\"\\uD83D\\uDD0D Obteniendo llamadas paginadas:\", params);\n        let query = supabase.from(\"calls\").select(\"*\", {\n            count: \"exact\"\n        });\n        // Aplicar filtros de búsqueda\n        if (params.search) {\n            query = query.or(\"business_name.ilike.%\".concat(params.search, \"%,owner_name.ilike.%\").concat(params.search, \"%,owner_phone.ilike.%\").concat(params.search, \"%\"));\n        }\n        // Aplicar filtros adicionales\n        if ((_params_filters = params.filters) === null || _params_filters === void 0 ? void 0 : _params_filters.disposition) {\n            query = query.eq(\"disposition\", params.filters.disposition);\n        }\n        // Aplicar ordenamiento\n        const sortBy = params.sortBy || \"call_id\";\n        const sortOrder = params.sortOrder === \"asc\" ? {\n            ascending: true\n        } : {\n            ascending: false\n        };\n        query = query.order(sortBy, sortOrder);\n        // Aplicar paginación\n        const offset = (params.page - 1) * params.limit;\n        query = query.range(offset, offset + params.limit - 1);\n        const { data: calls, count, error: callsError } = await query;\n        if (callsError) {\n            console.error(\"Error fetching paginated calls:\", callsError);\n            throw callsError;\n        }\n        if (!calls || calls.length === 0) {\n            return {\n                data: [],\n                total: count || 0,\n                page: params.page,\n                limit: params.limit,\n                totalPages: Math.ceil((count || 0) / params.limit)\n            };\n        }\n        // Obtener información de PCA solo para las llamadas de esta página\n        const callIds = calls.map((call)=>call.call_id);\n        const { data: pcaData, error: pcaError } = await supabase.from(\"pca\").select(\"call_id\").in(\"call_id\", callIds);\n        if (pcaError) {\n            console.error(\"Error fetching PCA data:\", pcaError);\n        }\n        const callsWithPCA = new Set((pcaData === null || pcaData === void 0 ? void 0 : pcaData.map((pca)=>pca.call_id)) || []);\n        // Combinar información\n        const callsWithInfo = calls.map((call)=>({\n                ...call,\n                hasPCA: callsWithPCA.has(call.call_id),\n                hasCallbacks: false\n            }));\n        // Aplicar filtros post-query si es necesario\n        let filteredCalls = callsWithInfo;\n        if (((_params_filters1 = params.filters) === null || _params_filters1 === void 0 ? void 0 : _params_filters1.hasPCA) !== undefined) {\n            filteredCalls = filteredCalls.filter((call)=>call.hasPCA === params.filters.hasPCA);\n        }\n        const totalPages = Math.ceil((count || 0) / params.limit);\n        console.log(\"✅ Devolviendo \".concat(filteredCalls.length, \" llamadas (p\\xe1gina \").concat(params.page, \"/\").concat(totalPages, \") de \").concat(count, \" total\"));\n        return {\n            data: filteredCalls,\n            total: count || 0,\n            page: params.page,\n            limit: params.limit,\n            totalPages\n        };\n    } catch (error) {\n        console.error(\"Error in getCallsWithPagination:\", error);\n        throw error;\n    }\n}\n// Función para obtener callbacks por call_id\nasync function getCallbacksByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).order(\"callback_date\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching callbacks:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getCallbacksByCallId:\", error);\n        throw error;\n    }\n}\n// Función para obtener análisis PCA por call_id\nasync function getPCAByCallId(callId) {\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"*\").eq(\"call_id\", callId).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching PCA data:\", error);\n            throw error;\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getPCAByCallId:\", error);\n        throw error;\n    }\n}\n// Nueva función para obtener información completa del cliente y análisis (calls y callbacks)\nasync function getCallDetailsWithPCA(callId) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCallDetailsWithPCA - buscando callId:\", callId);\n        // Primero intentar obtener como call normal\n        const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"\\uD83D\\uDCDE Resultado b\\xfasqueda en calls:\", {\n            callData,\n            callError\n        });\n        if (callData && !callError) {\n            // Es una call normal\n            const pcaData = await getPCAByCallId(callId);\n            console.log(\"✅ Encontrado como call normal\");\n            return {\n                call: callData,\n                pca: pcaData,\n                isCallback: false\n            };\n        }\n        // Si no se encontró en calls, buscar en callbacks usando el id\n        console.log(\"\\uD83D\\uDD04 No encontrado en calls, buscando en callbacks por id...\");\n        const { data: callbackData, error: callbackError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"id\", callId).single();\n        console.log(\"\\uD83D\\uDCCB Resultado b\\xfasqueda en callbacks por id:\", {\n            callbackData,\n            callbackError\n        });\n        if (callbackData && !callbackError) {\n            // Es un callback - convertir a formato Call para compatibilidad\n            const callFormatted = {\n                call_id: callbackData.id,\n                business_name: callbackData.callback_owner_name,\n                owner_name: callbackData.callback_owner_name,\n                owner_phone: callbackData.to_number,\n                address_street: callbackData.lead_address || \"\",\n                address_city: callbackData.lead_city,\n                address_state: callbackData.lead_state,\n                address_zip: callbackData.lead_zip,\n                disposition: callbackData.disposition || \"callback\"\n            };\n            console.log(\"✅ Encontrado como callback por id, datos formateados:\", callFormatted);\n            return {\n                call: callFormatted,\n                pca: [],\n                isCallback: true,\n                callback: callbackData\n            };\n        }\n        // Si tampoco se encontró por id, buscar en callbacks usando call_id\n        console.log(\"\\uD83D\\uDD04 No encontrado por id, buscando en callbacks por call_id...\");\n        const { data: callbackByCallId, error: callbackByCallIdError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"\\uD83D\\uDCCB Resultado b\\xfasqueda en callbacks por call_id:\", {\n            callbackByCallId,\n            callbackByCallIdError\n        });\n        if (callbackByCallId && !callbackByCallIdError) {\n            // Es un callback encontrado por call_id\n            const callFormatted = {\n                call_id: callbackByCallId.id,\n                business_name: callbackByCallId.callback_owner_name,\n                owner_name: callbackByCallId.callback_owner_name,\n                owner_phone: callbackByCallId.to_number,\n                address_street: callbackByCallId.lead_address || \"\",\n                address_city: callbackByCallId.lead_city,\n                address_state: callbackByCallId.lead_state,\n                address_zip: callbackByCallId.lead_zip,\n                disposition: callbackByCallId.disposition || \"callback\"\n            };\n            console.log(\"✅ Encontrado como callback por call_id, datos formateados:\", callFormatted);\n            return {\n                call: callFormatted,\n                pca: [],\n                isCallback: true,\n                callback: callbackByCallId\n            };\n        }\n        // Finalmente, buscar en callbacks_review\n        console.log(\"\\uD83D\\uDD04 No encontrado en callbacks, buscando en callbacks_review por call_id...\");\n        const { data: callbackReview, error: callbackReviewError } = await supabase.from(\"callbacks_review\").select(\"*\").eq(\"call_id\", callId).single();\n        console.log(\"\\uD83D\\uDCCB Resultado b\\xfasqueda en callbacks_review:\", {\n            callbackReview,\n            callbackReviewError\n        });\n        if (callbackReview && !callbackReviewError) {\n            // Es un callback de review\n            const callFormatted = {\n                call_id: callbackReview.id || callbackReview.call_id,\n                business_name: callbackReview.callback_owner_name,\n                owner_name: callbackReview.callback_owner_name,\n                owner_phone: callbackReview.to_number,\n                address_street: callbackReview.lead_address || \"\",\n                address_city: callbackReview.lead_city,\n                address_state: callbackReview.lead_state,\n                address_zip: callbackReview.lead_zip,\n                disposition: callbackReview.disposition || \"callback\"\n            };\n            console.log(\"✅ Encontrado como callback_review, datos formateados:\", callFormatted);\n            return {\n                call: callFormatted,\n                pca: [],\n                isCallback: true,\n                callback: callbackReview\n            };\n        }\n        // No encontrado en ninguna tabla\n        console.error(\"❌ No se encontr\\xf3 call ni callback con ID:\", callId);\n        return {\n            call: null,\n            pca: [],\n            isCallback: false\n        };\n    } catch (error) {\n        console.error(\"❌ Error in getCallDetailsWithPCA:\", error);\n        throw error;\n    }\n}\n// Función de debug para ver todos los PCA disponibles\nasync function getAllPCA() {\n    console.log(\"Intentando obtener todos los PCA...\");\n    // Primero intentamos sin límites\n    const { data, error, status, statusText } = await supabase.from(\"pca\").select(\"id, call_id, agent_name, created_at\").order(\"created_at\", {\n        ascending: false\n    });\n    console.log(\"Respuesta PCA:\", {\n        data,\n        error,\n        status,\n        statusText,\n        dataLength: (data === null || data === void 0 ? void 0 : data.length) || 0\n    });\n    if (error) {\n        console.error(\"Error detallado al obtener PCA:\", {\n            message: error.message,\n            details: error.details,\n            hint: error.hint,\n            code: error.code\n        });\n        // Intentamos con un query más simple\n        console.log(\"Intentando query m\\xe1s simple...\");\n        const { data: simpleData, error: simpleError } = await supabase.from(\"pca\").select(\"*\").limit(1);\n        console.log(\"Query simple resultado:\", {\n            simpleData,\n            simpleError\n        });\n        throw error;\n    }\n    console.log(\"PCA obtenidos exitosamente:\", data);\n    return data;\n}\n// Función de debug simple para verificar acceso a PCA\nasync function testPCAAccess() {\n    console.log(\"Testeando acceso a tabla PCA...\");\n    const { data, error, count } = await supabase.from(\"pca\").select(\"*\", {\n        count: \"exact\",\n        head: true\n    });\n    console.log(\"Test PCA - Count:\", count, \"Error:\", error);\n    return {\n        count,\n        error\n    };\n}\n// Función para verificar todas las tablas disponibles\nasync function testAllTablesAccess() {\n    const tables = [\n        \"calls\",\n        \"pca\",\n        \"callbacks\"\n    ];\n    const results = {};\n    for (const table of tables){\n        try {\n            console.log(\"Testeando tabla: \".concat(table));\n            const { data, error, count } = await supabase.from(table).select(\"*\", {\n                count: \"exact\",\n                head: true\n            });\n            results[table] = {\n                count,\n                error: (error === null || error === void 0 ? void 0 : error.message) || null\n            };\n            console.log(\"\".concat(table, \": \").concat(count, \" registros, error:\"), error === null || error === void 0 ? void 0 : error.message);\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Error desconocido\";\n            results[table] = {\n                count: 0,\n                error: errorMessage\n            };\n            console.error(\"Error en tabla \".concat(table, \":\"), err);\n        }\n    }\n    return results;\n}\n// Función específica para diagnosticar el problema de PCA\nasync function diagnosePCAAccess() {\n    console.log(\"\\uD83D\\uDD0D Diagnosticando acceso a tabla PCA...\");\n    const tests = [];\n    // Test 1: Count básico\n    try {\n        const { count, error } = await supabase.from(\"pca\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: !error,\n            result: \"Count: \".concat(count),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Count b\\xe1sico\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 2: Select simple con límite\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id\").limit(1);\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select simple (limit 1)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 3: Select específico\n    try {\n        const { data, error } = await supabase.from(\"pca\").select(\"id, call_id\").limit(3);\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: !error,\n            result: \"Registros: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0),\n            error: error === null || error === void 0 ? void 0 : error.message,\n            sampleData: data\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Select espec\\xedfico (id, call_id)\",\n            success: false,\n            result: \"Excepci\\xf3n\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    // Test 4: Verificar si RLS está causando el problema\n    try {\n        // Intentamos hacer un query con bypass de RLS si es posible\n        const { data, error } = await supabase.rpc(\"get_pca_count\") // Esta función no existe, pero el error nos dará información\n        ;\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: !error,\n            result: \"RPC call\",\n            error: error === null || error === void 0 ? void 0 : error.message\n        });\n    } catch (err) {\n        tests.push({\n            test: \"Test RPC (para verificar RLS)\",\n            success: false,\n            result: \"RPC no disponible\",\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        });\n    }\n    console.log(\"\\uD83D\\uDCCA Resultados del diagn\\xf3stico:\", tests);\n    return tests;\n}\n// Función para crear una política temporal de RLS\nasync function createPCAPolicy() {\n    console.log(\"\\uD83D\\uDD27 Intentando crear pol\\xedtica de acceso para PCA...\");\n    try {\n        // Intentamos ejecutar un comando SQL para crear una política\n        const { data, error } = await supabase.rpc(\"create_pca_policy\");\n        return {\n            success: !error,\n            error: error === null || error === void 0 ? void 0 : error.message\n        };\n    } catch (err) {\n        return {\n            success: false,\n            error: err instanceof Error ? err.message : \"Error desconocido\"\n        };\n    }\n}\n// Función para obtener todos los leads (números únicos con su información más reciente)\nasync function getLeads() {\n    console.log(\"\\uD83D\\uDCDE Obteniendo todos los leads...\");\n    // Primero obtenemos todas las calls\n    const { data: callsData, error: callsError } = await supabase.from(\"calls\").select(\"*\").not(\"to_number\", \"is\", null).order(\"call_id\", {\n        ascending: false\n    });\n    if (callsError) {\n        console.error(\"❌ Error obteniendo calls:\", callsError);\n        throw callsError;\n    }\n    if (!callsData) return [];\n    // Obtener todas las dispositions del PCA para los call_ids\n    const callIds = callsData.map((call)=>call.call_id);\n    const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n    // Crear un mapa para acceso rápido a las dispositions del PCA\n    const pcaMap = new Map();\n    if (pcaData) {\n        pcaData.forEach((pca)=>{\n            pcaMap.set(pca.call_id, pca.disposition);\n        });\n    }\n    const data = callsData;\n    // Agrupamos por to_number y tomamos la información más reciente\n    const leadsMap = new Map();\n    for (const call of data){\n        if (!call.to_number) continue;\n        const existingLead = leadsMap.get(call.to_number);\n        if (!existingLead) {\n            // Primera vez que vemos este número\n            leadsMap.set(call.to_number, {\n                phone_number: call.to_number,\n                business_name: call.business_name,\n                owner_name: call.owner_name,\n                owner_email: call.owner_email,\n                location_type: call.location_type,\n                address_street: call.address_street,\n                address_city: call.address_city,\n                address_state: call.address_state,\n                address_zip: call.address_zip,\n                total_calls: 1,\n                last_call_date: call.call_id,\n                last_disposition: pcaMap.get(call.call_id) || call.disposition,\n                agreed_amount: call.agreed_amount\n            });\n        } else {\n            // Actualizamos el conteo\n            existingLead.total_calls++;\n            // Si esta llamada es más reciente (call_id mayor), actualizamos la info\n            if (call.call_id > existingLead.last_call_date) {\n                existingLead.business_name = call.business_name || existingLead.business_name;\n                existingLead.owner_name = call.owner_name || existingLead.owner_name;\n                existingLead.owner_email = call.owner_email || existingLead.owner_email;\n                existingLead.location_type = call.location_type || existingLead.location_type;\n                existingLead.address_street = call.address_street || existingLead.address_street;\n                existingLead.address_city = call.address_city || existingLead.address_city;\n                existingLead.address_state = call.address_state || existingLead.address_state;\n                existingLead.address_zip = call.address_zip || existingLead.address_zip;\n                existingLead.last_call_date = call.call_id;\n                existingLead.last_disposition = pcaMap.get(call.call_id) || call.disposition;\n                existingLead.agreed_amount = call.agreed_amount || existingLead.agreed_amount;\n            }\n        }\n    }\n    const leads = Array.from(leadsMap.values());\n    console.log(\"✅ Encontrados \".concat(leads.length, \" leads \\xfanicos\"));\n    return leads;\n}\n// Función para obtener historial completo (calls + callbacks) por número de teléfono\nasync function getCallHistoryByPhone(phoneNumber) {\n    console.log(\"\\uD83D\\uDCDE Obteniendo historial completo para: \".concat(phoneNumber));\n    try {\n        // Obtener llamadas regulares\n        const { data: calls, error: callsError } = await supabase.from(\"calls\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"call_id\", {\n            ascending: false\n        });\n        if (callsError) {\n            console.error(\"❌ Error obteniendo llamadas:\", callsError);\n            throw callsError;\n        }\n        console.log(\"\\uD83D\\uDCDE Encontradas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas para \").concat(phoneNumber));\n        // Obtener callbacks para ese número\n        const { data: callbacks, error: callbacksError } = await supabase.from(\"callbacks\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"\\uD83D\\uDD04 Encontrados \".concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks para \").concat(phoneNumber));\n        if (callbacksError) {\n            console.error(\"❌ Error obteniendo callbacks:\", callbacksError);\n        // No lanzamos error, solo logueamos\n        }\n        // Verificar si también hay callbacks_review\n        const { data: callbacksReview, error: callbacksReviewError } = await supabase.from(\"callbacks_review\").select(\"*\").eq(\"to_number\", phoneNumber).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"\\uD83D\\uDCCB Encontrados \".concat((callbacksReview === null || callbacksReview === void 0 ? void 0 : callbacksReview.length) || 0, \" callbacks_review para \").concat(phoneNumber));\n        if (callbacksReviewError) {\n            console.log(\"ℹ️ No existe tabla callbacks_review o error:\", callbacksReviewError.message);\n        }\n        // Obtener dispositions del PCA para las calls\n        let pcaMap = new Map();\n        if (calls && calls.length > 0) {\n            const callIds = calls.map((call)=>call.call_id);\n            // Obtener dispositions del PCA\n            const { data: pcaData } = await supabase.from(\"pca\").select(\"call_id, disposition\").in(\"call_id\", callIds);\n            if (pcaData) {\n                pcaData.forEach((pca)=>{\n                    pcaMap.set(pca.call_id, pca.disposition);\n                });\n            }\n        }\n        // Combinar y marcar el tipo\n        const allInteractions = [\n            // Todas las entries de la tabla 'calls' son llamadas normales\n            ...(calls || []).map((call)=>{\n                const pcaDisposition = pcaMap.get(call.call_id) || call.disposition;\n                const result = {\n                    ...call,\n                    type: \"call\",\n                    date: call.call_id,\n                    display_date: call.call_id,\n                    disposition: pcaDisposition\n                };\n                console.log(\"\\uD83D\\uDCDE Call \".concat(call.call_id, ': disposition=\"').concat(pcaDisposition, '\", type=\"call\", business_name=\"').concat(call.business_name, '\", owner_name=\"').concat(call.owner_name, '\"'));\n                return result;\n            }),\n            // Todas las entries de la tabla 'callbacks' son callbacks\n            ...(callbacks || []).map((callback)=>{\n                console.log(\"\\uD83D\\uDD04 Callback \".concat(callback.id, ': type=\"callback\", owner_name=\"').concat(callback.callback_owner_name, '\", to_number=\"').concat(callback.to_number, '\"'));\n                return {\n                    ...callback,\n                    type: \"callback\",\n                    date: callback.created_at || callback.id,\n                    display_date: callback.callback_time || callback.created_at || callback.id,\n                    // Mapear campos para consistencia\n                    business_name: callback.callback_owner_name,\n                    agreed_amount: undefined // Los callbacks no tienen monto\n                };\n            })\n        ];\n        // Ordenar por fecha (más recientes primero)\n        allInteractions.sort((a, b)=>{\n            if (a.date > b.date) return -1;\n            if (a.date < b.date) return 1;\n            return 0;\n        });\n        console.log(\"✅ Encontradas \".concat((calls === null || calls === void 0 ? void 0 : calls.length) || 0, \" llamadas y \").concat((callbacks === null || callbacks === void 0 ? void 0 : callbacks.length) || 0, \" callbacks para \").concat(phoneNumber));\n        return allInteractions;\n    } catch (error) {\n        console.error(\"❌ Error obteniendo historial completo:\", error);\n        throw error;\n    }\n}\n// Función para contar cuántas llamadas tiene un número\nasync function getCallCountByPhone(phoneNumber) {\n    const { count, error } = await supabase.from(\"calls\").select(\"call_id\", {\n        count: \"exact\",\n        head: true\n    }).eq(\"to_number\", phoneNumber);\n    if (error) {\n        console.error(\"❌ Error contando llamadas:\", error);\n        return 0;\n    }\n    return count || 0;\n}\n// Función para verificar si una llamada tiene historial\nasync function hasCallHistory(callId) {\n    // Primero obtenemos el to_number de la llamada actual\n    const { data: callData, error: callError } = await supabase.from(\"calls\").select(\"to_number\").eq(\"call_id\", callId).single();\n    if (callError || !(callData === null || callData === void 0 ? void 0 : callData.to_number)) {\n        return {\n            hasHistory: false,\n            count: 0\n        };\n    }\n    const phoneNumber = callData.to_number;\n    const count = await getCallCountByPhone(phoneNumber);\n    return {\n        hasHistory: count > 1,\n        count,\n        phoneNumber\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDb0Q7QUFFcEQsTUFBTUMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBRTFELE1BQU1LLFdBQVdQLG1FQUFZQSxDQUFDQyxhQUFhSSxpQkFBZ0I7QUE0RmxFLDBDQUEwQztBQUNuQyxlQUFlRztJQUNwQixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUgsU0FDM0JJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDLFdBQVc7UUFBRUMsV0FBVztJQUFNO0lBRXZDLElBQUlKLE9BQU87UUFDVCxNQUFNQTtJQUNSO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLGlFQUFpRTtBQUMxRCxlQUFlTTtJQUNwQixJQUFJO1FBQ0YsdUNBQXVDO1FBQ3ZDLE1BQU0sRUFBRU4sTUFBTU8sS0FBSyxFQUFFTixPQUFPTyxVQUFVLEVBQUUsR0FBRyxNQUFNVixTQUM5Q0ksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUMsV0FBVztZQUFFQyxXQUFXO1FBQU07UUFFdkMsSUFBSUcsWUFBWTtZQUNkQyxRQUFRUixLQUFLLENBQUMseUJBQXlCTztZQUN2QyxNQUFNQTtRQUNSO1FBRUEsSUFBSSxDQUFDRCxPQUFPLE9BQU8sRUFBRTtRQUVyQixvREFBb0Q7UUFDcEQsTUFBTSxFQUFFUCxNQUFNVSxPQUFPLEVBQUVULE9BQU9VLFFBQVEsRUFBRSxHQUFHLE1BQU1iLFNBQzlDSSxJQUFJLENBQUMsT0FDTEMsTUFBTSxDQUFDO1FBRVYsSUFBSVEsVUFBVTtZQUNaRixRQUFRUixLQUFLLENBQUMsNEJBQTRCVTtRQUMxQyxvRUFBb0U7UUFDdEU7UUFFQSxNQUFNQyxlQUFlLElBQUlDLElBQUlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksR0FBRyxDQUFD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QixLQUFLLEVBQUUsR0FBRyxNQUFNSCxTQUM1QkksSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQyxXQUFXO1FBQUVzQixPQUFPO1FBQVNnRSxNQUFNO0lBQUssR0FDL0MzRCxFQUFFLENBQUMsYUFBYWlHO0lBRW5CLElBQUk5SCxPQUFPO1FBQ1RRLFFBQVFSLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU87SUFDVDtJQUVBLE9BQU93QixTQUFTO0FBQ2xCO0FBRUEsd0RBQXdEO0FBQ2pELGVBQWVzSCxlQUFlOUYsTUFBYztJQUNqRCxzREFBc0Q7SUFDdEQsTUFBTSxFQUFFakQsTUFBTW9ELFFBQVEsRUFBRW5ELE9BQU9vRCxTQUFTLEVBQUUsR0FBRyxNQUFNdkQsU0FDaERJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsYUFDUDJCLEVBQUUsQ0FBQyxXQUFXbUIsUUFDZEssTUFBTTtJQUVULElBQUlELGFBQWEsRUFBQ0QscUJBQUFBLCtCQUFBQSxTQUFVWSxTQUFTLEdBQUU7UUFDckMsT0FBTztZQUFFZ0YsWUFBWTtZQUFPdkgsT0FBTztRQUFFO0lBQ3ZDO0lBRUEsTUFBTXNHLGNBQWMzRSxTQUFTWSxTQUFTO0lBQ3RDLE1BQU12QyxRQUFRLE1BQU1xSCxvQkFBb0JmO0lBRXhDLE9BQU87UUFDTGlCLFlBQVl2SCxRQUFRO1FBQ3BCQTtRQUNBc0c7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3VwYWJhc2UudHM/MDZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSFcblxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpXG5cbi8vIERlZmluaXIgZWwgdGlwbyBkZSBkYXRvcyBwYXJhIGxhIHRhYmxhIGNhbGxzXG5leHBvcnQgaW50ZXJmYWNlIENhbGwge1xuICBjYWxsX2lkOiBzdHJpbmdcbiAgYWdlbnRfaWQ/OiBzdHJpbmdcbiAgYWdlbnRfbmFtZT86IHN0cmluZ1xuICB0cmFuc2NyaXB0Pzogc3RyaW5nXG4gIGRpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIGJ1c2luZXNzX25hbWU/OiBzdHJpbmdcbiAgb3duZXJfbmFtZT86IHN0cmluZ1xuICBvd25lcl9waG9uZT86IHN0cmluZ1xuICBvd25lcl9lbWFpbD86IHN0cmluZ1xuICBsb2NhdGlvbl90eXBlPzogc3RyaW5nXG4gIGFkZHJlc3Nfc3RyZWV0Pzogc3RyaW5nXG4gIGFkZHJlc3NfY2l0eT86IHN0cmluZ1xuICBhZGRyZXNzX3N0YXRlPzogc3RyaW5nXG4gIGFkZHJlc3NfemlwPzogc3RyaW5nXG4gIGFncmVlZF9hbW91bnQ/OiBudW1iZXJcbiAgbW9udGhseV9hbW91bnQ/OiBudW1iZXJcbiAgeWVhcmx5X2Ftb3VudD86IG51bWJlclxuICBjb21wYW55X2tleT86IHN0cmluZ1xuICBhZ2VudF9leHRlcm5hbF9pZD86IHN0cmluZ1xuICBhZGRyZXNzX2xpbmUyPzogc3RyaW5nXG4gIGJ1c2luZXNzX2hvdXJzPzogc3RyaW5nXG4gIG90aGVyX2xvY2F0aW9ucz86IHN0cmluZ1xuICBmcm9tX251bWJlcj86IHN0cmluZ1xuICB0b19udW1iZXI/OiBzdHJpbmdcbn1cblxuLy8gVGlwbyBleHRlbmRpZG8gcGFyYSBsbGFtYWRhcyBjb24gaW5mb3JtYWNpw7NuIGRlIFBDQVxuZXhwb3J0IGludGVyZmFjZSBDYWxsV2l0aFBDQUluZm8gZXh0ZW5kcyBDYWxsIHtcbiAgaGFzUENBOiBib29sZWFuXG4gIGhhc0NhbGxiYWNrcz86IGJvb2xlYW5cbn1cblxuLy8gRGVmaW5pciBlbCB0aXBvIGRlIGRhdG9zIHBhcmEgbGEgdGFibGEgY2FsbGJhY2tzXG5leHBvcnQgaW50ZXJmYWNlIENhbGxiYWNrIHtcbiAgaWQ6IHN0cmluZ1xuICBpZF91dWlkX29sZDogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0OiBzdHJpbmdcbiAgbGVhZF9pZD86IHN0cmluZ1xuICBjYWxsX2lkPzogc3RyaW5nXG4gIGNvbXBhbnlfaWQ/OiBzdHJpbmdcbiAgYWdlbnRfaWQ/OiBzdHJpbmdcbiAgZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgY2FsbGJhY2tfb3duZXJfbmFtZTogc3RyaW5nXG4gIGNhbGxiYWNrX3RpbWU/OiBzdHJpbmdcbiAgY2FsbGJhY2tfd2luZG93X25vdGU/OiBzdHJpbmdcbiAgcGF5bG9hZD86IGFueVxuICBhZ2VudF9leHRlcm5hbF9pZD86IHN0cmluZ1xuICBsZWFkX3N0YXRlPzogc3RyaW5nXG4gIGxlYWRfY2l0eT86IHN0cmluZ1xuICBsZWFkX3ppcD86IHN0cmluZ1xuICBjYWxsX3N0YXJ0ZWRfYXQ/OiBzdHJpbmdcbiAgY2FsbGVyX3R6Pzogc3RyaW5nXG4gIHR6X2FtYmlndW91cz86IGJvb2xlYW5cbiAgY2FsbGJhY2tfdGltZV90ZXh0X3Jhdz86IHN0cmluZ1xuICBldmVudF90eXBlPzogc3RyaW5nXG4gIGZyb21fbnVtYmVyPzogc3RyaW5nXG4gIHRvX251bWJlcj86IHN0cmluZ1xufVxuXG4vLyBEZWZpbmlyIGVsIHRpcG8gZGUgZGF0b3MgcGFyYSBsYSB0YWJsYSBwY2FcbmV4cG9ydCBpbnRlcmZhY2UgUENBIHtcbiAgaWQ6IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgY2FsbF9pZDogc3RyaW5nXG4gIGFnZW50X25hbWU/OiBzdHJpbmdcbiAgZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgY2FsbF9zdWNjZXNzZnVsPzogYm9vbGVhblxuICB1c2VyX3NlbnRpbWVudD86IHN0cmluZ1xuICBkdXJhdGlvbl9tcz86IG51bWJlclxuICBzdGFydF90aW1lc3RhbXA/OiBzdHJpbmdcbiAgZW5kX3RpbWVzdGFtcD86IHN0cmluZ1xuICBkaXNjb25uZWN0aW9uX3JlYXNvbj86IHN0cmluZ1xuICBjYWxsX3N1bW1hcnk/OiBzdHJpbmdcbiAgdHJhbnNjcmlwdD86IHN0cmluZ1xuICByZWNvcmRpbmdfdXJsPzogc3RyaW5nXG4gIHJlY29yZGluZ19tdWx0aV9jaGFubmVsX3VybD86IHN0cmluZ1xuICBwdWJsaWNfbG9nX3VybD86IHN0cmluZ1xuICBjYWxsX2Nvc3Q/OiBudW1iZXJcbiAgYW5hbHlzaXM/OiBhbnlcbiAgY3VzdG9tX2FuYWx5c2lzX2RhdGE/OiBhbnlcbiAgbGxtX3Rva2VuX3VzYWdlPzogYW55XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBhZ2VudF9leHRlcm5hbF9pZD86IHN0cmluZ1xuICBmcm9tX251bWJlcj86IHN0cmluZ1xuICB0b19udW1iZXI/OiBzdHJpbmdcbn1cblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIHRvZGFzIGxhcyBsbGFtYWRhc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxzKCkge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdjYWxscycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLm9yZGVyKCdjYWxsX2lkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIHJldHVybiBkYXRhIGFzIENhbGxbXVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgbGxhbWFkYXMgY29uIGluZm9ybWFjacOzbiBkZSBzaSB0aWVuZW4gUENBXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbHNXaXRoUENBSW5mbygpOiBQcm9taXNlPENhbGxXaXRoUENBSW5mb1tdPiB7XG4gIHRyeSB7XG4gICAgLy8gUHJpbWVybyBvYnRlbmVtb3MgdG9kYXMgbGFzIGxsYW1hZGFzXG4gICAgY29uc3QgeyBkYXRhOiBjYWxscywgZXJyb3I6IGNhbGxzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAub3JkZXIoJ2NhbGxfaWQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYWxsczonLCBjYWxsc0Vycm9yKVxuICAgICAgdGhyb3cgY2FsbHNFcnJvclxuICAgIH1cblxuICAgIGlmICghY2FsbHMpIHJldHVybiBbXVxuXG4gICAgLy8gTHVlZ28gb2J0ZW5lbW9zIHRvZG9zIGxvcyBjYWxsX2lkcyBxdWUgdGllbmVuIFBDQVxuICAgIGNvbnN0IHsgZGF0YTogcGNhRGF0YSwgZXJyb3I6IHBjYUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCdjYWxsX2lkJylcblxuICAgIGlmIChwY2FFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgUENBIGRhdGE6JywgcGNhRXJyb3IpXG4gICAgICAvLyBObyBsYW56YW1vcyBlcnJvciBhcXXDrSwgc29sbyBsb2d1ZWFtb3MgeSBjb250aW51YW1vcyBzaW4gUENBIGluZm9cbiAgICB9XG5cbiAgICBjb25zdCBjYWxsc1dpdGhQQ0EgPSBuZXcgU2V0KHBjYURhdGE/Lm1hcChwY2EgPT4gcGNhLmNhbGxfaWQpIHx8IFtdKVxuXG4gICAgLy8gQ29tYmluYW1vcyBsYSBpbmZvcm1hY2nDs25cbiAgICByZXR1cm4gY2FsbHMubWFwKGNhbGwgPT4gKHtcbiAgICAgIC4uLmNhbGwsXG4gICAgICBoYXNQQ0E6IGNhbGxzV2l0aFBDQS5oYXMoY2FsbC5jYWxsX2lkKSxcbiAgICAgIGhhc0NhbGxiYWNrczogZmFsc2UgLy8gWWEgbm8gdXNhbW9zIGNhbGxiYWNrcyBjb21vIGNvbmNlcHRvXG4gICAgfSkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2FsbHNXaXRoUENBSW5mbzonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIPCfk4ogUEFHSU5BQ0nDk04gRVNDQUxBQkxFIFBBUkEgUFJPRFVDQ0nDk05cblxuLy8gSW50ZXJmYXogcGFyYSBwYXLDoW1ldHJvcyBkZSBwYWdpbmFjacOzblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uUGFyYW1zIHtcbiAgcGFnZTogbnVtYmVyXG4gIGxpbWl0OiBudW1iZXJcbiAgc2VhcmNoPzogc3RyaW5nXG4gIGZpbHRlcnM/OiB7XG4gICAgaGFzUENBPzogYm9vbGVhblxuICAgIGRpc3Bvc2l0aW9uPzogc3RyaW5nXG4gIH1cbiAgc29ydEJ5Pzogc3RyaW5nXG4gIHNvcnRPcmRlcj86ICdhc2MnIHwgJ2Rlc2MnXG59XG5cbi8vIEludGVyZmF6IHBhcmEgcmVzcHVlc3RhIHBhZ2luYWRhXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRlZFJlc3BvbnNlPFQ+IHtcbiAgZGF0YTogVFtdXG4gIHRvdGFsOiBudW1iZXJcbiAgcGFnZTogbnVtYmVyXG4gIGxpbWl0OiBudW1iZXJcbiAgdG90YWxQYWdlczogbnVtYmVyXG59XG5cbi8vIEZ1bmNpw7NuIE5VRVZBOiBPYnRlbmVyIGxsYW1hZGFzIGNvbiBwYWdpbmFjacOzbiBlbiBzZXJ2aWRvciAoRVNDQUxBQkxFKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxzV2l0aFBhZ2luYXRpb24ocGFyYW1zOiBQYWdpbmF0aW9uUGFyYW1zKTogUHJvbWlzZTxQYWdpbmF0ZWRSZXNwb25zZTxDYWxsV2l0aFBDQUluZm8+PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gT2J0ZW5pZW5kbyBsbGFtYWRhcyBwYWdpbmFkYXM6JywgcGFyYW1zKVxuICAgIFxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbHMnKVxuICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcgfSlcblxuICAgIC8vIEFwbGljYXIgZmlsdHJvcyBkZSBiw7pzcXVlZGFcbiAgICBpZiAocGFyYW1zLnNlYXJjaCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5vcihgYnVzaW5lc3NfbmFtZS5pbGlrZS4lJHtwYXJhbXMuc2VhcmNofSUsb3duZXJfbmFtZS5pbGlrZS4lJHtwYXJhbXMuc2VhcmNofSUsb3duZXJfcGhvbmUuaWxpa2UuJSR7cGFyYW1zLnNlYXJjaH0lYClcbiAgICB9XG5cbiAgICAvLyBBcGxpY2FyIGZpbHRyb3MgYWRpY2lvbmFsZXNcbiAgICBpZiAocGFyYW1zLmZpbHRlcnM/LmRpc3Bvc2l0aW9uKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdkaXNwb3NpdGlvbicsIHBhcmFtcy5maWx0ZXJzLmRpc3Bvc2l0aW9uKVxuICAgIH1cblxuICAgIC8vIEFwbGljYXIgb3JkZW5hbWllbnRvXG4gICAgY29uc3Qgc29ydEJ5ID0gcGFyYW1zLnNvcnRCeSB8fCAnY2FsbF9pZCdcbiAgICBjb25zdCBzb3J0T3JkZXIgPSBwYXJhbXMuc29ydE9yZGVyID09PSAnYXNjJyA/IHsgYXNjZW5kaW5nOiB0cnVlIH0gOiB7IGFzY2VuZGluZzogZmFsc2UgfVxuICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIoc29ydEJ5LCBzb3J0T3JkZXIpXG5cbiAgICAvLyBBcGxpY2FyIHBhZ2luYWNpw7NuXG4gICAgY29uc3Qgb2Zmc2V0ID0gKHBhcmFtcy5wYWdlIC0gMSkgKiBwYXJhbXMubGltaXRcbiAgICBxdWVyeSA9IHF1ZXJ5LnJhbmdlKG9mZnNldCwgb2Zmc2V0ICsgcGFyYW1zLmxpbWl0IC0gMSlcblxuICAgIGNvbnN0IHsgZGF0YTogY2FsbHMsIGNvdW50LCBlcnJvcjogY2FsbHNFcnJvciB9ID0gYXdhaXQgcXVlcnlcblxuICAgIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwYWdpbmF0ZWQgY2FsbHM6JywgY2FsbHNFcnJvcilcbiAgICAgIHRocm93IGNhbGxzRXJyb3JcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxzIHx8IGNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHRvdGFsOiBjb3VudCB8fCAwLFxuICAgICAgICBwYWdlOiBwYXJhbXMucGFnZSxcbiAgICAgICAgbGltaXQ6IHBhcmFtcy5saW1pdCxcbiAgICAgICAgdG90YWxQYWdlczogTWF0aC5jZWlsKChjb3VudCB8fCAwKSAvIHBhcmFtcy5saW1pdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBQQ0Egc29sbyBwYXJhIGxhcyBsbGFtYWRhcyBkZSBlc3RhIHDDoWdpbmFcbiAgICBjb25zdCBjYWxsSWRzID0gY2FsbHMubWFwKGNhbGwgPT4gY2FsbC5jYWxsX2lkKVxuICAgIGNvbnN0IHsgZGF0YTogcGNhRGF0YSwgZXJyb3I6IHBjYUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCdjYWxsX2lkJylcbiAgICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG5cbiAgICBpZiAocGNhRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFBDQSBkYXRhOicsIHBjYUVycm9yKVxuICAgIH1cblxuICAgIGNvbnN0IGNhbGxzV2l0aFBDQSA9IG5ldyBTZXQocGNhRGF0YT8ubWFwKHBjYSA9PiBwY2EuY2FsbF9pZCkgfHwgW10pXG5cbiAgICAvLyBDb21iaW5hciBpbmZvcm1hY2nDs25cbiAgICBjb25zdCBjYWxsc1dpdGhJbmZvOiBDYWxsV2l0aFBDQUluZm9bXSA9IGNhbGxzLm1hcChjYWxsID0+ICh7XG4gICAgICAuLi5jYWxsLFxuICAgICAgaGFzUENBOiBjYWxsc1dpdGhQQ0EuaGFzKGNhbGwuY2FsbF9pZCksXG4gICAgICBoYXNDYWxsYmFja3M6IGZhbHNlXG4gICAgfSkpXG5cbiAgICAvLyBBcGxpY2FyIGZpbHRyb3MgcG9zdC1xdWVyeSBzaSBlcyBuZWNlc2FyaW9cbiAgICBsZXQgZmlsdGVyZWRDYWxscyA9IGNhbGxzV2l0aEluZm9cbiAgICBpZiAocGFyYW1zLmZpbHRlcnM/Lmhhc1BDQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWx0ZXJlZENhbGxzID0gZmlsdGVyZWRDYWxscy5maWx0ZXIoY2FsbCA9PiBjYWxsLmhhc1BDQSA9PT0gcGFyYW1zLmZpbHRlcnMhLmhhc1BDQSlcbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbFBhZ2VzID0gTWF0aC5jZWlsKChjb3VudCB8fCAwKSAvIHBhcmFtcy5saW1pdClcblxuICAgIGNvbnNvbGUubG9nKGDinIUgRGV2b2x2aWVuZG8gJHtmaWx0ZXJlZENhbGxzLmxlbmd0aH0gbGxhbWFkYXMgKHDDoWdpbmEgJHtwYXJhbXMucGFnZX0vJHt0b3RhbFBhZ2VzfSkgZGUgJHtjb3VudH0gdG90YWxgKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBmaWx0ZXJlZENhbGxzLFxuICAgICAgdG90YWw6IGNvdW50IHx8IDAsXG4gICAgICBwYWdlOiBwYXJhbXMucGFnZSxcbiAgICAgIGxpbWl0OiBwYXJhbXMubGltaXQsXG4gICAgICB0b3RhbFBhZ2VzXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENhbGxzV2l0aFBhZ2luYXRpb246JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgY2FsbGJhY2tzIHBvciBjYWxsX2lkXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbGJhY2tzQnlDYWxsSWQoY2FsbElkOiBzdHJpbmcpOiBQcm9taXNlPENhbGxiYWNrW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAgIC5vcmRlcignY2FsbGJhY2tfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYWxsYmFja3M6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2FsbGJhY2tzQnlDYWxsSWQ6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgYW7DoWxpc2lzIFBDQSBwb3IgY2FsbF9pZFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBDQUJ5Q2FsbElkKGNhbGxJZDogc3RyaW5nKTogUHJvbWlzZTxQQ0FbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdjYWxsX2lkJywgY2FsbElkKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFBDQSBkYXRhOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldFBDQUJ5Q2FsbElkOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gTnVldmEgZnVuY2nDs24gcGFyYSBvYnRlbmVyIGluZm9ybWFjacOzbiBjb21wbGV0YSBkZWwgY2xpZW50ZSB5IGFuw6FsaXNpcyAoY2FsbHMgeSBjYWxsYmFja3MpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbERldGFpbHNXaXRoUENBKGNhbGxJZDogc3RyaW5nKTogUHJvbWlzZTx7IGNhbGw6IENhbGwgfCBudWxsLCBwY2E6IFBDQVtdLCBpc0NhbGxiYWNrOiBib29sZWFuLCBjYWxsYmFjaz86IGFueSB9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gZ2V0Q2FsbERldGFpbHNXaXRoUENBIC0gYnVzY2FuZG8gY2FsbElkOicsIGNhbGxJZClcbiAgICBcbiAgICAvLyBQcmltZXJvIGludGVudGFyIG9idGVuZXIgY29tbyBjYWxsIG5vcm1hbFxuICAgIGNvbnN0IHsgZGF0YTogY2FsbERhdGEsIGVycm9yOiBjYWxsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NhbGxfaWQnLCBjYWxsSWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGNvbnNvbGUubG9nKCfwn5OeIFJlc3VsdGFkbyBiw7pzcXVlZGEgZW4gY2FsbHM6JywgeyBjYWxsRGF0YSwgY2FsbEVycm9yIH0pXG5cbiAgICBpZiAoY2FsbERhdGEgJiYgIWNhbGxFcnJvcikge1xuICAgICAgLy8gRXMgdW5hIGNhbGwgbm9ybWFsXG4gICAgICBjb25zdCBwY2FEYXRhID0gYXdhaXQgZ2V0UENBQnlDYWxsSWQoY2FsbElkKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBFbmNvbnRyYWRvIGNvbW8gY2FsbCBub3JtYWwnKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbDogY2FsbERhdGEsXG4gICAgICAgIHBjYTogcGNhRGF0YSxcbiAgICAgICAgaXNDYWxsYmFjazogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaSBubyBzZSBlbmNvbnRyw7MgZW4gY2FsbHMsIGJ1c2NhciBlbiBjYWxsYmFja3MgdXNhbmRvIGVsIGlkXG4gICAgY29uc29sZS5sb2coJ/CflIQgTm8gZW5jb250cmFkbyBlbiBjYWxscywgYnVzY2FuZG8gZW4gY2FsbGJhY2tzIHBvciBpZC4uLicpXG4gICAgY29uc3QgeyBkYXRhOiBjYWxsYmFja0RhdGEsIGVycm9yOiBjYWxsYmFja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnaWQnLCBjYWxsSWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGNvbnNvbGUubG9nKCfwn5OLIFJlc3VsdGFkbyBiw7pzcXVlZGEgZW4gY2FsbGJhY2tzIHBvciBpZDonLCB7IGNhbGxiYWNrRGF0YSwgY2FsbGJhY2tFcnJvciB9KVxuXG4gICAgaWYgKGNhbGxiYWNrRGF0YSAmJiAhY2FsbGJhY2tFcnJvcikge1xuICAgICAgLy8gRXMgdW4gY2FsbGJhY2sgLSBjb252ZXJ0aXIgYSBmb3JtYXRvIENhbGwgcGFyYSBjb21wYXRpYmlsaWRhZFxuICAgICAgY29uc3QgY2FsbEZvcm1hdHRlZDogQ2FsbCA9IHtcbiAgICAgICAgY2FsbF9pZDogY2FsbGJhY2tEYXRhLmlkLFxuICAgICAgICBidXNpbmVzc19uYW1lOiBjYWxsYmFja0RhdGEuY2FsbGJhY2tfb3duZXJfbmFtZSxcbiAgICAgICAgb3duZXJfbmFtZTogY2FsbGJhY2tEYXRhLmNhbGxiYWNrX293bmVyX25hbWUsXG4gICAgICAgIG93bmVyX3Bob25lOiBjYWxsYmFja0RhdGEudG9fbnVtYmVyLFxuICAgICAgICBhZGRyZXNzX3N0cmVldDogY2FsbGJhY2tEYXRhLmxlYWRfYWRkcmVzcyB8fCAnJyxcbiAgICAgICAgYWRkcmVzc19jaXR5OiBjYWxsYmFja0RhdGEubGVhZF9jaXR5LFxuICAgICAgICBhZGRyZXNzX3N0YXRlOiBjYWxsYmFja0RhdGEubGVhZF9zdGF0ZSxcbiAgICAgICAgYWRkcmVzc196aXA6IGNhbGxiYWNrRGF0YS5sZWFkX3ppcCxcbiAgICAgICAgZGlzcG9zaXRpb246IGNhbGxiYWNrRGF0YS5kaXNwb3NpdGlvbiB8fCAnY2FsbGJhY2snXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRW5jb250cmFkbyBjb21vIGNhbGxiYWNrIHBvciBpZCwgZGF0b3MgZm9ybWF0ZWFkb3M6JywgY2FsbEZvcm1hdHRlZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IGNhbGxGb3JtYXR0ZWQsXG4gICAgICAgIHBjYTogW10sIC8vIExvcyBjYWxsYmFja3Mgbm8gdGllbmVuIFBDQVxuICAgICAgICBpc0NhbGxiYWNrOiB0cnVlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tEYXRhXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2kgdGFtcG9jbyBzZSBlbmNvbnRyw7MgcG9yIGlkLCBidXNjYXIgZW4gY2FsbGJhY2tzIHVzYW5kbyBjYWxsX2lkXG4gICAgY29uc29sZS5sb2coJ/CflIQgTm8gZW5jb250cmFkbyBwb3IgaWQsIGJ1c2NhbmRvIGVuIGNhbGxiYWNrcyBwb3IgY2FsbF9pZC4uLicpXG4gICAgY29uc3QgeyBkYXRhOiBjYWxsYmFja0J5Q2FsbElkLCBlcnJvcjogY2FsbGJhY2tCeUNhbGxJZEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgY29uc29sZS5sb2coJ/Cfk4sgUmVzdWx0YWRvIGLDunNxdWVkYSBlbiBjYWxsYmFja3MgcG9yIGNhbGxfaWQ6JywgeyBjYWxsYmFja0J5Q2FsbElkLCBjYWxsYmFja0J5Q2FsbElkRXJyb3IgfSlcblxuICAgIGlmIChjYWxsYmFja0J5Q2FsbElkICYmICFjYWxsYmFja0J5Q2FsbElkRXJyb3IpIHtcbiAgICAgIC8vIEVzIHVuIGNhbGxiYWNrIGVuY29udHJhZG8gcG9yIGNhbGxfaWRcbiAgICAgIGNvbnN0IGNhbGxGb3JtYXR0ZWQ6IENhbGwgPSB7XG4gICAgICAgIGNhbGxfaWQ6IGNhbGxiYWNrQnlDYWxsSWQuaWQsXG4gICAgICAgIGJ1c2luZXNzX25hbWU6IGNhbGxiYWNrQnlDYWxsSWQuY2FsbGJhY2tfb3duZXJfbmFtZSxcbiAgICAgICAgb3duZXJfbmFtZTogY2FsbGJhY2tCeUNhbGxJZC5jYWxsYmFja19vd25lcl9uYW1lLFxuICAgICAgICBvd25lcl9waG9uZTogY2FsbGJhY2tCeUNhbGxJZC50b19udW1iZXIsXG4gICAgICAgIGFkZHJlc3Nfc3RyZWV0OiBjYWxsYmFja0J5Q2FsbElkLmxlYWRfYWRkcmVzcyB8fCAnJyxcbiAgICAgICAgYWRkcmVzc19jaXR5OiBjYWxsYmFja0J5Q2FsbElkLmxlYWRfY2l0eSxcbiAgICAgICAgYWRkcmVzc19zdGF0ZTogY2FsbGJhY2tCeUNhbGxJZC5sZWFkX3N0YXRlLFxuICAgICAgICBhZGRyZXNzX3ppcDogY2FsbGJhY2tCeUNhbGxJZC5sZWFkX3ppcCxcbiAgICAgICAgZGlzcG9zaXRpb246IGNhbGxiYWNrQnlDYWxsSWQuZGlzcG9zaXRpb24gfHwgJ2NhbGxiYWNrJ1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEVuY29udHJhZG8gY29tbyBjYWxsYmFjayBwb3IgY2FsbF9pZCwgZGF0b3MgZm9ybWF0ZWFkb3M6JywgY2FsbEZvcm1hdHRlZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IGNhbGxGb3JtYXR0ZWQsXG4gICAgICAgIHBjYTogW10sIC8vIExvcyBjYWxsYmFja3Mgbm8gdGllbmVuIFBDQVxuICAgICAgICBpc0NhbGxiYWNrOiB0cnVlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tCeUNhbGxJZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmFsbWVudGUsIGJ1c2NhciBlbiBjYWxsYmFja3NfcmV2aWV3XG4gICAgY29uc29sZS5sb2coJ/CflIQgTm8gZW5jb250cmFkbyBlbiBjYWxsYmFja3MsIGJ1c2NhbmRvIGVuIGNhbGxiYWNrc19yZXZpZXcgcG9yIGNhbGxfaWQuLi4nKVxuICAgIGNvbnN0IHsgZGF0YTogY2FsbGJhY2tSZXZpZXcsIGVycm9yOiBjYWxsYmFja1Jldmlld0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxiYWNrc19yZXZpZXcnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NhbGxfaWQnLCBjYWxsSWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGNvbnNvbGUubG9nKCfwn5OLIFJlc3VsdGFkbyBiw7pzcXVlZGEgZW4gY2FsbGJhY2tzX3JldmlldzonLCB7IGNhbGxiYWNrUmV2aWV3LCBjYWxsYmFja1Jldmlld0Vycm9yIH0pXG5cbiAgICBpZiAoY2FsbGJhY2tSZXZpZXcgJiYgIWNhbGxiYWNrUmV2aWV3RXJyb3IpIHtcbiAgICAgIC8vIEVzIHVuIGNhbGxiYWNrIGRlIHJldmlld1xuICAgICAgY29uc3QgY2FsbEZvcm1hdHRlZDogQ2FsbCA9IHtcbiAgICAgICAgY2FsbF9pZDogY2FsbGJhY2tSZXZpZXcuaWQgfHwgY2FsbGJhY2tSZXZpZXcuY2FsbF9pZCxcbiAgICAgICAgYnVzaW5lc3NfbmFtZTogY2FsbGJhY2tSZXZpZXcuY2FsbGJhY2tfb3duZXJfbmFtZSxcbiAgICAgICAgb3duZXJfbmFtZTogY2FsbGJhY2tSZXZpZXcuY2FsbGJhY2tfb3duZXJfbmFtZSxcbiAgICAgICAgb3duZXJfcGhvbmU6IGNhbGxiYWNrUmV2aWV3LnRvX251bWJlcixcbiAgICAgICAgYWRkcmVzc19zdHJlZXQ6IGNhbGxiYWNrUmV2aWV3LmxlYWRfYWRkcmVzcyB8fCAnJyxcbiAgICAgICAgYWRkcmVzc19jaXR5OiBjYWxsYmFja1Jldmlldy5sZWFkX2NpdHksXG4gICAgICAgIGFkZHJlc3Nfc3RhdGU6IGNhbGxiYWNrUmV2aWV3LmxlYWRfc3RhdGUsXG4gICAgICAgIGFkZHJlc3NfemlwOiBjYWxsYmFja1Jldmlldy5sZWFkX3ppcCxcbiAgICAgICAgZGlzcG9zaXRpb246IGNhbGxiYWNrUmV2aWV3LmRpc3Bvc2l0aW9uIHx8ICdjYWxsYmFjaydcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBFbmNvbnRyYWRvIGNvbW8gY2FsbGJhY2tfcmV2aWV3LCBkYXRvcyBmb3JtYXRlYWRvczonLCBjYWxsRm9ybWF0dGVkKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbDogY2FsbEZvcm1hdHRlZCxcbiAgICAgICAgcGNhOiBbXSwgLy8gTG9zIGNhbGxiYWNrcyBubyB0aWVuZW4gUENBXG4gICAgICAgIGlzQ2FsbGJhY2s6IHRydWUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1Jldmlld1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGVuY29udHJhZG8gZW4gbmluZ3VuYSB0YWJsYVxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBObyBzZSBlbmNvbnRyw7MgY2FsbCBuaSBjYWxsYmFjayBjb24gSUQ6JywgY2FsbElkKVxuICAgIHJldHVybiB7XG4gICAgICBjYWxsOiBudWxsLFxuICAgICAgcGNhOiBbXSxcbiAgICAgIGlzQ2FsbGJhY2s6IGZhbHNlXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRDYWxsRGV0YWlsc1dpdGhQQ0E6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBkZSBkZWJ1ZyBwYXJhIHZlciB0b2RvcyBsb3MgUENBIGRpc3BvbmlibGVzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsUENBKCkge1xuICBjb25zb2xlLmxvZygnSW50ZW50YW5kbyBvYnRlbmVyIHRvZG9zIGxvcyBQQ0EuLi4nKVxuICBcbiAgLy8gUHJpbWVybyBpbnRlbnRhbW9zIHNpbiBsw61taXRlc1xuICBjb25zdCB7IGRhdGEsIGVycm9yLCBzdGF0dXMsIHN0YXR1c1RleHQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BjYScpXG4gICAgLnNlbGVjdCgnaWQsIGNhbGxfaWQsIGFnZW50X25hbWUsIGNyZWF0ZWRfYXQnKVxuICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gIGNvbnNvbGUubG9nKCdSZXNwdWVzdGEgUENBOicsIHsgXG4gICAgZGF0YSwgXG4gICAgZXJyb3IsIFxuICAgIHN0YXR1cywgXG4gICAgc3RhdHVzVGV4dCxcbiAgICBkYXRhTGVuZ3RoOiBkYXRhPy5sZW5ndGggfHwgMFxuICB9KVxuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFsbGFkbyBhbCBvYnRlbmVyIFBDQTonLCB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgZGV0YWlsczogZXJyb3IuZGV0YWlscyxcbiAgICAgIGhpbnQ6IGVycm9yLmhpbnQsXG4gICAgICBjb2RlOiBlcnJvci5jb2RlXG4gICAgfSlcbiAgICBcbiAgICAvLyBJbnRlbnRhbW9zIGNvbiB1biBxdWVyeSBtw6FzIHNpbXBsZVxuICAgIGNvbnNvbGUubG9nKCdJbnRlbnRhbmRvIHF1ZXJ5IG3DoXMgc2ltcGxlLi4uJylcbiAgICBjb25zdCB7IGRhdGE6IHNpbXBsZURhdGEsIGVycm9yOiBzaW1wbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAubGltaXQoMSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygnUXVlcnkgc2ltcGxlIHJlc3VsdGFkbzonLCB7IHNpbXBsZURhdGEsIHNpbXBsZUVycm9yIH0pXG4gICAgXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdQQ0Egb2J0ZW5pZG9zIGV4aXRvc2FtZW50ZTonLCBkYXRhKVxuICByZXR1cm4gZGF0YVxufVxuXG4vLyBGdW5jacOzbiBkZSBkZWJ1ZyBzaW1wbGUgcGFyYSB2ZXJpZmljYXIgYWNjZXNvIGEgUENBXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdFBDQUFjY2VzcygpIHtcbiAgY29uc29sZS5sb2coJ1Rlc3RlYW5kbyBhY2Nlc28gYSB0YWJsYSBQQ0EuLi4nKVxuICBcbiAgY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BjYScpXG4gICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcblxuICBjb25zb2xlLmxvZygnVGVzdCBQQ0EgLSBDb3VudDonLCBjb3VudCwgJ0Vycm9yOicsIGVycm9yKVxuICBcbiAgcmV0dXJuIHsgY291bnQsIGVycm9yIH1cbn1cblxuLy8gRnVuY2nDs24gcGFyYSB2ZXJpZmljYXIgdG9kYXMgbGFzIHRhYmxhcyBkaXNwb25pYmxlc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RBbGxUYWJsZXNBY2Nlc3MoKSB7XG4gIGNvbnN0IHRhYmxlcyA9IFsnY2FsbHMnLCAncGNhJywgJ2NhbGxiYWNrcyddXG4gIGNvbnN0IHJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIHsgY291bnQ6IG51bWJlciB8IG51bGwsIGVycm9yOiBzdHJpbmcgfCBudWxsIH0+ID0ge31cbiAgXG4gIGZvciAoY29uc3QgdGFibGUgb2YgdGFibGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBUZXN0ZWFuZG8gdGFibGE6ICR7dGFibGV9YClcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSh0YWJsZSlcbiAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgIFxuICAgICAgcmVzdWx0c1t0YWJsZV0gPSB7IGNvdW50LCBlcnJvcjogZXJyb3I/Lm1lc3NhZ2UgfHwgbnVsbCB9XG4gICAgICBjb25zb2xlLmxvZyhgJHt0YWJsZX06ICR7Y291bnR9IHJlZ2lzdHJvcywgZXJyb3I6YCwgZXJyb3I/Lm1lc3NhZ2UpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJ1xuICAgICAgcmVzdWx0c1t0YWJsZV0gPSB7IGNvdW50OiAwLCBlcnJvcjogZXJyb3JNZXNzYWdlIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVuIHRhYmxhICR7dGFibGV9OmAsIGVycilcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRzXG59XG5cbi8vIEZ1bmNpw7NuIGVzcGVjw61maWNhIHBhcmEgZGlhZ25vc3RpY2FyIGVsIHByb2JsZW1hIGRlIFBDQVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpYWdub3NlUENBQWNjZXNzKCkge1xuICBjb25zb2xlLmxvZygn8J+UjSBEaWFnbm9zdGljYW5kbyBhY2Nlc28gYSB0YWJsYSBQQ0EuLi4nKVxuICBcbiAgY29uc3QgdGVzdHMgPSBbXVxuICBcbiAgLy8gVGVzdCAxOiBDb3VudCBiw6FzaWNvXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncGNhJylcbiAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgXG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnQ291bnQgYsOhc2ljbycsXG4gICAgICBzdWNjZXNzOiAhZXJyb3IsXG4gICAgICByZXN1bHQ6IGBDb3VudDogJHtjb3VudH1gLFxuICAgICAgZXJyb3I6IGVycm9yPy5tZXNzYWdlXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnQ291bnQgYsOhc2ljbycsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIHJlc3VsdDogJ0V4Y2VwY2nDs24nLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gVGVzdCAyOiBTZWxlY3Qgc2ltcGxlIGNvbiBsw61taXRlXG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwY2EnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmxpbWl0KDEpXG4gICAgXG4gICAgdGVzdHMucHVzaCh7XG4gICAgICB0ZXN0OiAnU2VsZWN0IHNpbXBsZSAobGltaXQgMSknLFxuICAgICAgc3VjY2VzczogIWVycm9yLFxuICAgICAgcmVzdWx0OiBgUmVnaXN0cm9zOiAke2RhdGE/Lmxlbmd0aCB8fCAwfWAsXG4gICAgICBlcnJvcjogZXJyb3I/Lm1lc3NhZ2VcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdTZWxlY3Qgc2ltcGxlIChsaW1pdCAxKScsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIHJlc3VsdDogJ0V4Y2VwY2nDs24nLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gVGVzdCAzOiBTZWxlY3QgZXNwZWPDrWZpY29cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3BjYScpXG4gICAgICAuc2VsZWN0KCdpZCwgY2FsbF9pZCcpXG4gICAgICAubGltaXQoMylcbiAgICBcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdTZWxlY3QgZXNwZWPDrWZpY28gKGlkLCBjYWxsX2lkKScsXG4gICAgICBzdWNjZXNzOiAhZXJyb3IsXG4gICAgICByZXN1bHQ6IGBSZWdpc3Ryb3M6ICR7ZGF0YT8ubGVuZ3RoIHx8IDB9YCxcbiAgICAgIGVycm9yOiBlcnJvcj8ubWVzc2FnZSxcbiAgICAgIHNhbXBsZURhdGE6IGRhdGFcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0ZXN0cy5wdXNoKHtcbiAgICAgIHRlc3Q6ICdTZWxlY3QgZXNwZWPDrWZpY28gKGlkLCBjYWxsX2lkKScsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIHJlc3VsdDogJ0V4Y2VwY2nDs24nLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gVGVzdCA0OiBWZXJpZmljYXIgc2kgUkxTIGVzdMOhIGNhdXNhbmRvIGVsIHByb2JsZW1hXG4gIHRyeSB7XG4gICAgLy8gSW50ZW50YW1vcyBoYWNlciB1biBxdWVyeSBjb24gYnlwYXNzIGRlIFJMUyBzaSBlcyBwb3NpYmxlXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5ycGMoJ2dldF9wY2FfY291bnQnKSAgLy8gRXN0YSBmdW5jacOzbiBubyBleGlzdGUsIHBlcm8gZWwgZXJyb3Igbm9zIGRhcsOhIGluZm9ybWFjacOzblxuICAgIFxuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1Rlc3QgUlBDIChwYXJhIHZlcmlmaWNhciBSTFMpJyxcbiAgICAgIHN1Y2Nlc3M6ICFlcnJvcixcbiAgICAgIHJlc3VsdDogJ1JQQyBjYWxsJyxcbiAgICAgIGVycm9yOiBlcnJvcj8ubWVzc2FnZVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRlc3RzLnB1c2goe1xuICAgICAgdGVzdDogJ1Rlc3QgUlBDIChwYXJhIHZlcmlmaWNhciBSTFMpJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgcmVzdWx0OiAnUlBDIG5vIGRpc3BvbmlibGUnLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfSlcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCfwn5OKIFJlc3VsdGFkb3MgZGVsIGRpYWduw7NzdGljbzonLCB0ZXN0cylcbiAgcmV0dXJuIHRlc3RzXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgY3JlYXIgdW5hIHBvbMOtdGljYSB0ZW1wb3JhbCBkZSBSTFNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQQ0FQb2xpY3koKSB7XG4gIGNvbnNvbGUubG9nKCfwn5SnIEludGVudGFuZG8gY3JlYXIgcG9sw610aWNhIGRlIGFjY2VzbyBwYXJhIFBDQS4uLicpXG4gIFxuICB0cnkge1xuICAgIC8vIEludGVudGFtb3MgZWplY3V0YXIgdW4gY29tYW5kbyBTUUwgcGFyYSBjcmVhciB1bmEgcG9sw610aWNhXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5ycGMoJ2NyZWF0ZV9wY2FfcG9saWN5JylcbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiAhZXJyb3IsIGVycm9yOiBlcnJvcj8ubWVzc2FnZSB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7IFxuICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nXG4gICAgfVxuICB9XG59XG5cbi8vIPCfk54gRlVOQ0lPTkVTIFBBUkEgSElTVE9SSUFMIERFIExMQU1BREFTIFBPUiBURUzDiUZPTk9cblxuLy8gSW50ZXJmYXogcGFyYSB1biBMZWFkIChuw7ptZXJvIGRlIHRlbMOpZm9ubyBjb24gaW5mb3JtYWNpw7NuIGRlbCBjbGllbnRlKVxuZXhwb3J0IGludGVyZmFjZSBMZWFkIHtcbiAgcGhvbmVfbnVtYmVyOiBzdHJpbmdcbiAgYnVzaW5lc3NfbmFtZT86IHN0cmluZ1xuICBvd25lcl9uYW1lPzogc3RyaW5nXG4gIG93bmVyX2VtYWlsPzogc3RyaW5nXG4gIGxvY2F0aW9uX3R5cGU/OiBzdHJpbmdcbiAgYWRkcmVzc19zdHJlZXQ/OiBzdHJpbmdcbiAgYWRkcmVzc19jaXR5Pzogc3RyaW5nXG4gIGFkZHJlc3Nfc3RhdGU/OiBzdHJpbmdcbiAgYWRkcmVzc196aXA/OiBzdHJpbmdcbiAgdG90YWxfY2FsbHM6IG51bWJlclxuICBsYXN0X2NhbGxfZGF0ZTogc3RyaW5nXG4gIGxhc3RfZGlzcG9zaXRpb24/OiBzdHJpbmdcbiAgYWdyZWVkX2Ftb3VudD86IG51bWJlclxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgdG9kb3MgbG9zIGxlYWRzIChuw7ptZXJvcyDDum5pY29zIGNvbiBzdSBpbmZvcm1hY2nDs24gbcOhcyByZWNpZW50ZSlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMZWFkcygpOiBQcm9taXNlPExlYWRbXT4ge1xuICBjb25zb2xlLmxvZygn8J+TniBPYnRlbmllbmRvIHRvZG9zIGxvcyBsZWFkcy4uLicpXG4gIFxuICAvLyBQcmltZXJvIG9idGVuZW1vcyB0b2RhcyBsYXMgY2FsbHNcbiAgY29uc3QgeyBkYXRhOiBjYWxsc0RhdGEsIGVycm9yOiBjYWxsc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdjYWxscycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLm5vdCgndG9fbnVtYmVyJywgJ2lzJywgbnVsbClcbiAgICAub3JkZXIoJ2NhbGxfaWQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgXG4gIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG9idGVuaWVuZG8gY2FsbHM6JywgY2FsbHNFcnJvcilcbiAgICB0aHJvdyBjYWxsc0Vycm9yXG4gIH1cbiAgXG4gIGlmICghY2FsbHNEYXRhKSByZXR1cm4gW11cbiAgXG4gIC8vIE9idGVuZXIgdG9kYXMgbGFzIGRpc3Bvc2l0aW9ucyBkZWwgUENBIHBhcmEgbG9zIGNhbGxfaWRzXG4gIGNvbnN0IGNhbGxJZHMgPSBjYWxsc0RhdGEubWFwKGNhbGwgPT4gY2FsbC5jYWxsX2lkKVxuICBjb25zdCB7IGRhdGE6IHBjYURhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3BjYScpXG4gICAgLnNlbGVjdCgnY2FsbF9pZCwgZGlzcG9zaXRpb24nKVxuICAgIC5pbignY2FsbF9pZCcsIGNhbGxJZHMpXG4gIFxuICAvLyBDcmVhciB1biBtYXBhIHBhcmEgYWNjZXNvIHLDoXBpZG8gYSBsYXMgZGlzcG9zaXRpb25zIGRlbCBQQ0FcbiAgY29uc3QgcGNhTWFwID0gbmV3IE1hcCgpXG4gIGlmIChwY2FEYXRhKSB7XG4gICAgcGNhRGF0YS5mb3JFYWNoKHBjYSA9PiB7XG4gICAgICBwY2FNYXAuc2V0KHBjYS5jYWxsX2lkLCBwY2EuZGlzcG9zaXRpb24pXG4gICAgfSlcbiAgfVxuICBcbiAgY29uc3QgZGF0YSA9IGNhbGxzRGF0YVxuICBcbiAgLy8gQWdydXBhbW9zIHBvciB0b19udW1iZXIgeSB0b21hbW9zIGxhIGluZm9ybWFjacOzbiBtw6FzIHJlY2llbnRlXG4gIGNvbnN0IGxlYWRzTWFwID0gbmV3IE1hcDxzdHJpbmcsIExlYWQ+KClcbiAgXG4gIGZvciAoY29uc3QgY2FsbCBvZiBkYXRhKSB7XG4gICAgaWYgKCFjYWxsLnRvX251bWJlcikgY29udGludWVcbiAgICBcbiAgICBjb25zdCBleGlzdGluZ0xlYWQgPSBsZWFkc01hcC5nZXQoY2FsbC50b19udW1iZXIpXG4gICAgXG4gICAgaWYgKCFleGlzdGluZ0xlYWQpIHtcbiAgICAgIC8vIFByaW1lcmEgdmV6IHF1ZSB2ZW1vcyBlc3RlIG7Dum1lcm9cbiAgICAgIGxlYWRzTWFwLnNldChjYWxsLnRvX251bWJlciwge1xuICAgICAgICBwaG9uZV9udW1iZXI6IGNhbGwudG9fbnVtYmVyLFxuICAgICAgICBidXNpbmVzc19uYW1lOiBjYWxsLmJ1c2luZXNzX25hbWUsXG4gICAgICAgIG93bmVyX25hbWU6IGNhbGwub3duZXJfbmFtZSxcbiAgICAgICAgb3duZXJfZW1haWw6IGNhbGwub3duZXJfZW1haWwsXG4gICAgICAgIGxvY2F0aW9uX3R5cGU6IGNhbGwubG9jYXRpb25fdHlwZSxcbiAgICAgICAgYWRkcmVzc19zdHJlZXQ6IGNhbGwuYWRkcmVzc19zdHJlZXQsXG4gICAgICAgIGFkZHJlc3NfY2l0eTogY2FsbC5hZGRyZXNzX2NpdHksXG4gICAgICAgIGFkZHJlc3Nfc3RhdGU6IGNhbGwuYWRkcmVzc19zdGF0ZSxcbiAgICAgICAgYWRkcmVzc196aXA6IGNhbGwuYWRkcmVzc196aXAsXG4gICAgICAgIHRvdGFsX2NhbGxzOiAxLFxuICAgICAgICBsYXN0X2NhbGxfZGF0ZTogY2FsbC5jYWxsX2lkLCAvLyBVc2FuZG8gY2FsbF9pZCBjb21vIHByb3h5IGRlIGZlY2hhXG4gICAgICAgIGxhc3RfZGlzcG9zaXRpb246IHBjYU1hcC5nZXQoY2FsbC5jYWxsX2lkKSB8fCBjYWxsLmRpc3Bvc2l0aW9uLFxuICAgICAgICBhZ3JlZWRfYW1vdW50OiBjYWxsLmFncmVlZF9hbW91bnRcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFjdHVhbGl6YW1vcyBlbCBjb250ZW9cbiAgICAgIGV4aXN0aW5nTGVhZC50b3RhbF9jYWxscysrXG4gICAgICBcbiAgICAgIC8vIFNpIGVzdGEgbGxhbWFkYSBlcyBtw6FzIHJlY2llbnRlIChjYWxsX2lkIG1heW9yKSwgYWN0dWFsaXphbW9zIGxhIGluZm9cbiAgICAgIGlmIChjYWxsLmNhbGxfaWQgPiBleGlzdGluZ0xlYWQubGFzdF9jYWxsX2RhdGUpIHtcbiAgICAgICAgZXhpc3RpbmdMZWFkLmJ1c2luZXNzX25hbWUgPSBjYWxsLmJ1c2luZXNzX25hbWUgfHwgZXhpc3RpbmdMZWFkLmJ1c2luZXNzX25hbWVcbiAgICAgICAgZXhpc3RpbmdMZWFkLm93bmVyX25hbWUgPSBjYWxsLm93bmVyX25hbWUgfHwgZXhpc3RpbmdMZWFkLm93bmVyX25hbWVcbiAgICAgICAgZXhpc3RpbmdMZWFkLm93bmVyX2VtYWlsID0gY2FsbC5vd25lcl9lbWFpbCB8fCBleGlzdGluZ0xlYWQub3duZXJfZW1haWxcbiAgICAgICAgZXhpc3RpbmdMZWFkLmxvY2F0aW9uX3R5cGUgPSBjYWxsLmxvY2F0aW9uX3R5cGUgfHwgZXhpc3RpbmdMZWFkLmxvY2F0aW9uX3R5cGVcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3Nfc3RyZWV0ID0gY2FsbC5hZGRyZXNzX3N0cmVldCB8fCBleGlzdGluZ0xlYWQuYWRkcmVzc19zdHJlZXRcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3NfY2l0eSA9IGNhbGwuYWRkcmVzc19jaXR5IHx8IGV4aXN0aW5nTGVhZC5hZGRyZXNzX2NpdHlcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3Nfc3RhdGUgPSBjYWxsLmFkZHJlc3Nfc3RhdGUgfHwgZXhpc3RpbmdMZWFkLmFkZHJlc3Nfc3RhdGVcbiAgICAgICAgZXhpc3RpbmdMZWFkLmFkZHJlc3NfemlwID0gY2FsbC5hZGRyZXNzX3ppcCB8fCBleGlzdGluZ0xlYWQuYWRkcmVzc196aXBcbiAgICAgICAgZXhpc3RpbmdMZWFkLmxhc3RfY2FsbF9kYXRlID0gY2FsbC5jYWxsX2lkXG4gICAgICAgIGV4aXN0aW5nTGVhZC5sYXN0X2Rpc3Bvc2l0aW9uID0gcGNhTWFwLmdldChjYWxsLmNhbGxfaWQpIHx8IGNhbGwuZGlzcG9zaXRpb25cbiAgICAgICAgZXhpc3RpbmdMZWFkLmFncmVlZF9hbW91bnQgPSBjYWxsLmFncmVlZF9hbW91bnQgfHwgZXhpc3RpbmdMZWFkLmFncmVlZF9hbW91bnRcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IGxlYWRzID0gQXJyYXkuZnJvbShsZWFkc01hcC52YWx1ZXMoKSlcbiAgY29uc29sZS5sb2coYOKchSBFbmNvbnRyYWRvcyAke2xlYWRzLmxlbmd0aH0gbGVhZHMgw7puaWNvc2ApXG4gIHJldHVybiBsZWFkc1xufVxuXG4vLyBJbnRlcmZheiBwYXJhIGludGVyYWNjaW9uZXMgY29tYmluYWRhcyAoY2FsbHMgKyBjYWxsYmFja3MpXG5leHBvcnQgaW50ZXJmYWNlIENhbGxJbnRlcmFjdGlvbiB7XG4gIHR5cGU6ICdjYWxsJyB8ICdjYWxsYmFjaydcbiAgY2FsbF9pZD86IHN0cmluZ1xuICBpZD86IHN0cmluZ1xuICBkaXNwb3NpdGlvbj86IHN0cmluZ1xuICBidXNpbmVzc19uYW1lPzogc3RyaW5nXG4gIG93bmVyX25hbWU/OiBzdHJpbmdcbiAgYWdyZWVkX2Ftb3VudD86IG51bWJlclxuICBhZGRyZXNzX3N0cmVldD86IHN0cmluZ1xuICBhZGRyZXNzX2NpdHk/OiBzdHJpbmdcbiAgYWRkcmVzc19zdGF0ZT86IHN0cmluZ1xuICBjYWxsYmFja190aW1lPzogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ/OiBzdHJpbmdcbiAgZGF0ZTogc3RyaW5nXG4gIGRpc3BsYXlfZGF0ZTogc3RyaW5nXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBoaXN0b3JpYWwgY29tcGxldG8gKGNhbGxzICsgY2FsbGJhY2tzKSBwb3IgbsO6bWVybyBkZSB0ZWzDqWZvbm9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsSGlzdG9yeUJ5UGhvbmUocGhvbmVOdW1iZXI6IHN0cmluZyk6IFByb21pc2U8Q2FsbEludGVyYWN0aW9uW10+IHtcbiAgY29uc29sZS5sb2coYPCfk54gT2J0ZW5pZW5kbyBoaXN0b3JpYWwgY29tcGxldG8gcGFyYTogJHtwaG9uZU51bWJlcn1gKVxuICBcbiAgdHJ5IHtcbiAgICAvLyBPYnRlbmVyIGxsYW1hZGFzIHJlZ3VsYXJlc1xuICAgIGNvbnN0IHsgZGF0YTogY2FsbHMsIGVycm9yOiBjYWxsc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NhbGxzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0b19udW1iZXInLCBwaG9uZU51bWJlcilcbiAgICAgIC5vcmRlcignY2FsbF9pZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgIFxuICAgIGlmIChjYWxsc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igb2J0ZW5pZW5kbyBsbGFtYWRhczonLCBjYWxsc0Vycm9yKVxuICAgICAgdGhyb3cgY2FsbHNFcnJvclxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+TniBFbmNvbnRyYWRhcyAke2NhbGxzPy5sZW5ndGggfHwgMH0gbGxhbWFkYXMgcGFyYSAke3Bob25lTnVtYmVyfWApXG4gICAgXG4gICAgLy8gT2J0ZW5lciBjYWxsYmFja3MgcGFyYSBlc2UgbsO6bWVyb1xuICAgIGNvbnN0IHsgZGF0YTogY2FsbGJhY2tzLCBlcnJvcjogY2FsbGJhY2tzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbGJhY2tzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0b19udW1iZXInLCBwaG9uZU51bWJlcilcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5SEIEVuY29udHJhZG9zICR7Y2FsbGJhY2tzPy5sZW5ndGggfHwgMH0gY2FsbGJhY2tzIHBhcmEgJHtwaG9uZU51bWJlcn1gKVxuICAgIFxuICAgIGlmIChjYWxsYmFja3NFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG9idGVuaWVuZG8gY2FsbGJhY2tzOicsIGNhbGxiYWNrc0Vycm9yKVxuICAgICAgLy8gTm8gbGFuemFtb3MgZXJyb3IsIHNvbG8gbG9ndWVhbW9zXG4gICAgfVxuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzaSB0YW1iacOpbiBoYXkgY2FsbGJhY2tzX3Jldmlld1xuICAgIGNvbnN0IHsgZGF0YTogY2FsbGJhY2tzUmV2aWV3LCBlcnJvcjogY2FsbGJhY2tzUmV2aWV3RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FsbGJhY2tzX3JldmlldycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndG9fbnVtYmVyJywgcGhvbmVOdW1iZXIpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+TiyBFbmNvbnRyYWRvcyAke2NhbGxiYWNrc1Jldmlldz8ubGVuZ3RoIHx8IDB9IGNhbGxiYWNrc19yZXZpZXcgcGFyYSAke3Bob25lTnVtYmVyfWApXG4gICAgXG4gICAgaWYgKGNhbGxiYWNrc1Jldmlld0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZygn4oS577iPIE5vIGV4aXN0ZSB0YWJsYSBjYWxsYmFja3NfcmV2aWV3IG8gZXJyb3I6JywgY2FsbGJhY2tzUmV2aWV3RXJyb3IubWVzc2FnZSlcbiAgICB9XG4gICAgXG4gICAgLy8gT2J0ZW5lciBkaXNwb3NpdGlvbnMgZGVsIFBDQSBwYXJhIGxhcyBjYWxsc1xuICAgIGxldCBwY2FNYXAgPSBuZXcgTWFwKClcbiAgICBcbiAgICBpZiAoY2FsbHMgJiYgY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2FsbElkcyA9IGNhbGxzLm1hcChjYWxsID0+IGNhbGwuY2FsbF9pZClcbiAgICAgIFxuICAgICAgLy8gT2J0ZW5lciBkaXNwb3NpdGlvbnMgZGVsIFBDQVxuICAgICAgY29uc3QgeyBkYXRhOiBwY2FEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGNhJylcbiAgICAgICAgLnNlbGVjdCgnY2FsbF9pZCwgZGlzcG9zaXRpb24nKVxuICAgICAgICAuaW4oJ2NhbGxfaWQnLCBjYWxsSWRzKVxuICAgICAgXG4gICAgICBpZiAocGNhRGF0YSkge1xuICAgICAgICBwY2FEYXRhLmZvckVhY2gocGNhID0+IHtcbiAgICAgICAgICBwY2FNYXAuc2V0KHBjYS5jYWxsX2lkLCBwY2EuZGlzcG9zaXRpb24pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENvbWJpbmFyIHkgbWFyY2FyIGVsIHRpcG9cbiAgICBjb25zdCBhbGxJbnRlcmFjdGlvbnM6IENhbGxJbnRlcmFjdGlvbltdID0gW1xuICAgICAgLy8gVG9kYXMgbGFzIGVudHJpZXMgZGUgbGEgdGFibGEgJ2NhbGxzJyBzb24gbGxhbWFkYXMgbm9ybWFsZXNcbiAgICAgIC4uLihjYWxscyB8fCBbXSkubWFwKGNhbGwgPT4ge1xuICAgICAgICBjb25zdCBwY2FEaXNwb3NpdGlvbiA9IHBjYU1hcC5nZXQoY2FsbC5jYWxsX2lkKSB8fCBjYWxsLmRpc3Bvc2l0aW9uXG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgLi4uY2FsbCxcbiAgICAgICAgICB0eXBlOiAnY2FsbCcgYXMgY29uc3QsXG4gICAgICAgICAgZGF0ZTogY2FsbC5jYWxsX2lkLFxuICAgICAgICAgIGRpc3BsYXlfZGF0ZTogY2FsbC5jYWxsX2lkLFxuICAgICAgICAgIGRpc3Bvc2l0aW9uOiBwY2FEaXNwb3NpdGlvblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TniBDYWxsICR7Y2FsbC5jYWxsX2lkfTogZGlzcG9zaXRpb249XCIke3BjYURpc3Bvc2l0aW9ufVwiLCB0eXBlPVwiY2FsbFwiLCBidXNpbmVzc19uYW1lPVwiJHtjYWxsLmJ1c2luZXNzX25hbWV9XCIsIG93bmVyX25hbWU9XCIke2NhbGwub3duZXJfbmFtZX1cImApXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KSxcbiAgICAgIC8vIFRvZGFzIGxhcyBlbnRyaWVzIGRlIGxhIHRhYmxhICdjYWxsYmFja3MnIHNvbiBjYWxsYmFja3NcbiAgICAgIC4uLihjYWxsYmFja3MgfHwgW10pLm1hcChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIENhbGxiYWNrICR7Y2FsbGJhY2suaWR9OiB0eXBlPVwiY2FsbGJhY2tcIiwgb3duZXJfbmFtZT1cIiR7Y2FsbGJhY2suY2FsbGJhY2tfb3duZXJfbmFtZX1cIiwgdG9fbnVtYmVyPVwiJHtjYWxsYmFjay50b19udW1iZXJ9XCJgKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jYWxsYmFjayxcbiAgICAgICAgICB0eXBlOiAnY2FsbGJhY2snIGFzIGNvbnN0LFxuICAgICAgICAgIGRhdGU6IGNhbGxiYWNrLmNyZWF0ZWRfYXQgfHwgY2FsbGJhY2suaWQsXG4gICAgICAgICAgZGlzcGxheV9kYXRlOiBjYWxsYmFjay5jYWxsYmFja190aW1lIHx8IGNhbGxiYWNrLmNyZWF0ZWRfYXQgfHwgY2FsbGJhY2suaWQsXG4gICAgICAgICAgLy8gTWFwZWFyIGNhbXBvcyBwYXJhIGNvbnNpc3RlbmNpYVxuICAgICAgICAgIGJ1c2luZXNzX25hbWU6IGNhbGxiYWNrLmNhbGxiYWNrX293bmVyX25hbWUsXG4gICAgICAgICAgYWdyZWVkX2Ftb3VudDogdW5kZWZpbmVkIC8vIExvcyBjYWxsYmFja3Mgbm8gdGllbmVuIG1vbnRvXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXVxuICAgIFxuICAgIC8vIE9yZGVuYXIgcG9yIGZlY2hhIChtw6FzIHJlY2llbnRlcyBwcmltZXJvKVxuICAgIGFsbEludGVyYWN0aW9ucy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5kYXRlID4gYi5kYXRlKSByZXR1cm4gLTFcbiAgICAgIGlmIChhLmRhdGUgPCBiLmRhdGUpIHJldHVybiAxXG4gICAgICByZXR1cm4gMFxuICAgIH0pXG4gICAgXG4gICAgY29uc29sZS5sb2coYOKchSBFbmNvbnRyYWRhcyAke2NhbGxzPy5sZW5ndGggfHwgMH0gbGxhbWFkYXMgeSAke2NhbGxiYWNrcz8ubGVuZ3RoIHx8IDB9IGNhbGxiYWNrcyBwYXJhICR7cGhvbmVOdW1iZXJ9YClcbiAgICByZXR1cm4gYWxsSW50ZXJhY3Rpb25zXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG9idGVuaWVuZG8gaGlzdG9yaWFsIGNvbXBsZXRvOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRnVuY2nDs24gcGFyYSBjb250YXIgY3XDoW50YXMgbGxhbWFkYXMgdGllbmUgdW4gbsO6bWVyb1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxDb3VudEJ5UGhvbmUocGhvbmVOdW1iZXI6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdjYWxscycpXG4gICAgLnNlbGVjdCgnY2FsbF9pZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAuZXEoJ3RvX251bWJlcicsIHBob25lTnVtYmVyKVxuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNvbnRhbmRvIGxsYW1hZGFzOicsIGVycm9yKVxuICAgIHJldHVybiAwXG4gIH1cbiAgXG4gIHJldHVybiBjb3VudCB8fCAwXG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgdmVyaWZpY2FyIHNpIHVuYSBsbGFtYWRhIHRpZW5lIGhpc3RvcmlhbFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc0NhbGxIaXN0b3J5KGNhbGxJZDogc3RyaW5nKTogUHJvbWlzZTx7IGhhc0hpc3Rvcnk6IGJvb2xlYW47IGNvdW50OiBudW1iZXI7IHBob25lTnVtYmVyPzogc3RyaW5nIH0+IHtcbiAgLy8gUHJpbWVybyBvYnRlbmVtb3MgZWwgdG9fbnVtYmVyIGRlIGxhIGxsYW1hZGEgYWN0dWFsXG4gIGNvbnN0IHsgZGF0YTogY2FsbERhdGEsIGVycm9yOiBjYWxsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2NhbGxzJylcbiAgICAuc2VsZWN0KCd0b19udW1iZXInKVxuICAgIC5lcSgnY2FsbF9pZCcsIGNhbGxJZClcbiAgICAuc2luZ2xlKClcbiAgXG4gIGlmIChjYWxsRXJyb3IgfHwgIWNhbGxEYXRhPy50b19udW1iZXIpIHtcbiAgICByZXR1cm4geyBoYXNIaXN0b3J5OiBmYWxzZSwgY291bnQ6IDAgfVxuICB9XG4gIFxuICBjb25zdCBwaG9uZU51bWJlciA9IGNhbGxEYXRhLnRvX251bWJlclxuICBjb25zdCBjb3VudCA9IGF3YWl0IGdldENhbGxDb3VudEJ5UGhvbmUocGhvbmVOdW1iZXIpXG4gIFxuICByZXR1cm4geyBcbiAgICBoYXNIaXN0b3J5OiBjb3VudCA+IDEsIFxuICAgIGNvdW50LFxuICAgIHBob25lTnVtYmVyIFxuICB9XG59Il0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2UiLCJnZXRDYWxscyIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsImdldENhbGxzV2l0aFBDQUluZm8iLCJjYWxscyIsImNhbGxzRXJyb3IiLCJjb25zb2xlIiwicGNhRGF0YSIsInBjYUVycm9yIiwiY2FsbHNXaXRoUENBIiwiU2V0IiwibWFwIiwicGNhIiwiY2FsbF9pZCIsImNhbGwiLCJoYXNQQ0EiLCJoYXMiLCJoYXNDYWxsYmFja3MiLCJnZXRDYWxsc1dpdGhQYWdpbmF0aW9uIiwicGFyYW1zIiwibG9nIiwicXVlcnkiLCJjb3VudCIsInNlYXJjaCIsIm9yIiwiZmlsdGVycyIsImRpc3Bvc2l0aW9uIiwiZXEiLCJzb3J0QnkiLCJzb3J0T3JkZXIiLCJvZmZzZXQiLCJwYWdlIiwibGltaXQiLCJyYW5nZSIsImxlbmd0aCIsInRvdGFsIiwidG90YWxQYWdlcyIsIk1hdGgiLCJjZWlsIiwiY2FsbElkcyIsImluIiwiY2FsbHNXaXRoSW5mbyIsImZpbHRlcmVkQ2FsbHMiLCJ1bmRlZmluZWQiLCJmaWx0ZXIiLCJnZXRDYWxsYmFja3NCeUNhbGxJZCIsImNhbGxJZCIsImdldFBDQUJ5Q2FsbElkIiwiZ2V0Q2FsbERldGFpbHNXaXRoUENBIiwiY2FsbERhdGEiLCJjYWxsRXJyb3IiLCJzaW5nbGUiLCJpc0NhbGxiYWNrIiwiY2FsbGJhY2tEYXRhIiwiY2FsbGJhY2tFcnJvciIsImNhbGxGb3JtYXR0ZWQiLCJpZCIsImJ1c2luZXNzX25hbWUiLCJjYWxsYmFja19vd25lcl9uYW1lIiwib3duZXJfbmFtZSIsIm93bmVyX3Bob25lIiwidG9fbnVtYmVyIiwiYWRkcmVzc19zdHJlZXQiLCJsZWFkX2FkZHJlc3MiLCJhZGRyZXNzX2NpdHkiLCJsZWFkX2NpdHkiLCJhZGRyZXNzX3N0YXRlIiwibGVhZF9zdGF0ZSIsImFkZHJlc3NfemlwIiwibGVhZF96aXAiLCJjYWxsYmFjayIsImNhbGxiYWNrQnlDYWxsSWQiLCJjYWxsYmFja0J5Q2FsbElkRXJyb3IiLCJjYWxsYmFja1JldmlldyIsImNhbGxiYWNrUmV2aWV3RXJyb3IiLCJnZXRBbGxQQ0EiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YUxlbmd0aCIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiaGludCIsImNvZGUiLCJzaW1wbGVEYXRhIiwic2ltcGxlRXJyb3IiLCJ0ZXN0UENBQWNjZXNzIiwiaGVhZCIsInRlc3RBbGxUYWJsZXNBY2Nlc3MiLCJ0YWJsZXMiLCJyZXN1bHRzIiwidGFibGUiLCJlcnIiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsImRpYWdub3NlUENBQWNjZXNzIiwidGVzdHMiLCJwdXNoIiwidGVzdCIsInN1Y2Nlc3MiLCJyZXN1bHQiLCJzYW1wbGVEYXRhIiwicnBjIiwiY3JlYXRlUENBUG9saWN5IiwiZ2V0TGVhZHMiLCJjYWxsc0RhdGEiLCJub3QiLCJwY2FNYXAiLCJNYXAiLCJmb3JFYWNoIiwic2V0IiwibGVhZHNNYXAiLCJleGlzdGluZ0xlYWQiLCJnZXQiLCJwaG9uZV9udW1iZXIiLCJvd25lcl9lbWFpbCIsImxvY2F0aW9uX3R5cGUiLCJ0b3RhbF9jYWxscyIsImxhc3RfY2FsbF9kYXRlIiwibGFzdF9kaXNwb3NpdGlvbiIsImFncmVlZF9hbW91bnQiLCJsZWFkcyIsIkFycmF5IiwidmFsdWVzIiwiZ2V0Q2FsbEhpc3RvcnlCeVBob25lIiwicGhvbmVOdW1iZXIiLCJjYWxsYmFja3MiLCJjYWxsYmFja3NFcnJvciIsImNhbGxiYWNrc1JldmlldyIsImNhbGxiYWNrc1Jldmlld0Vycm9yIiwiYWxsSW50ZXJhY3Rpb25zIiwicGNhRGlzcG9zaXRpb24iLCJ0eXBlIiwiZGF0ZSIsImRpc3BsYXlfZGF0ZSIsImNyZWF0ZWRfYXQiLCJjYWxsYmFja190aW1lIiwic29ydCIsImEiLCJiIiwiZ2V0Q2FsbENvdW50QnlQaG9uZSIsImhhc0NhbGxIaXN0b3J5IiwiaGFzSGlzdG9yeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});